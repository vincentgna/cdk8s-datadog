import * as path from "path";
import { ProjenStruct, Struct } from "@mrgrain/jsii-struct-builder";
import { Component, TextFile } from "projen";
import { ConstructLibraryCdk8s } from "projen/lib/cdk8s/cdk8s-construct";
import { TypeScriptProject } from "projen/lib/typescript";
import { findInterface } from "../util";

//https://github.com/DataDog/datadog-api-client-go/blob/v2.18.0/api/datadogV1/model_monitor_type.go#L16-L35
const monitorTypes = {
  AuditAlert: "audit alert",
  CiPipelinesAlert: "ci-pipelines alert",
  CiTestsAlert: "ci-tests alert",
  Composite: "composite",
  DatabaseMonitoringAlert: "database-monitoring alert",
  ErrorTrackingAlert: "error-tracking alert",
  EventAlert: "event alert",
  EventV2Alert: "event-v2 alert",
  LogAlert: "log alert",
  MetricAlert: "metric alert",
  ProcessAlert: "process alert",
  QueryAlert: "query alert",
  RumAlert: "rum alert",
  ServiceCheck: "service check",
  SloAlert: "slo alert",
  SyntheticsAlert: "synthetics alert",
  TraceAnalyticsAlert: "trace-analytics alert",
};

// https://github.com/DataDog/datadog-operator/blob/v1.2.1/controllers/datadogmonitor/controller.go#L45
const supportedMonitorTypeNames = [
  "AuditAlert",
  "EventAlert",
  "EventV2Alert",
  "LogAlert",
  "MetricAlert",
  "ProcessAlert",
  "QueryAlert",
  "RumAlert",
  "ServiceCheck",
  "SloAlert",
  "TraceAnalyticsAlert",
];

const outputDir = "util";
export class DatadogMonitorPropsBuilder extends Component {
  public project: TypeScriptProject;
  private supportedMonitorTypes: { [k: string]: string };

  public constructor(project: ConstructLibraryCdk8s) {
    super(project);
    this.project = project;
    // filter down to only supported monitor types
    this.supportedMonitorTypes = Object.fromEntries(
      Object.entries(monitorTypes).filter(([name, _]) =>
        supportedMonitorTypeNames.includes(name),
      ),
    );

    const monitorTypesBase = "Types.generated";
    // Generate a type alias for each monitorType string literal into Types.generated.ts
    const typesFilePath =
      this.generateSupportedMonitorTypeLiterals(monitorTypesBase);

    // Combine monitorType alias types into union type for "DatadogMonitor.type"
    // to express only a certain set of known values is accepted by consumers of this library
    const structFilePath = this.buildStruct(
      "datadog-operator",
      monitorTypesBase,
    );

    // index outputDir to export generated files
    new TextFile(
      this.project,
      path.join(project.srcdir, outputDir, "index.ts"),
      {
        lines: [
          `export * from "./${path.basename(typesFilePath, ".ts")}";`,
          `export * from "./${path.basename(structFilePath, ".ts")}";`,
        ],
      },
    );
  }

  /**
   * Build DatadogMonitorProps from the DataDogMonitorSpec interface in the imported module
   *
   * @param importedModuleName imported module name in project src directory
   * @param monitorTypesBase baseName for module with type literals for monitor types
   */
  private buildStruct(
    importedModuleName: string,
    monitorTypesBase: string,
  ): string {
    const name = "DatadogMonitorProps";
    const description = "Strongly typed Datadog Monitor props";
    const filePath = path.join(
      this.project.srcdir,
      outputDir,
      `${name}.generated.ts`,
    );
    const datadogMonitorSpec = findInterface(
      this.project,
      importedModuleName,
      "DatadogMonitorSpec",
    );

    const struct = new ProjenStruct(this.project, {
      name,
      description,
      importLocations: {
        // relative path from util filePath (src/util)
        [importedModuleName]: `../${importedModuleName}`,
        // reference generated Literal Type aliases
        types: `./${monitorTypesBase}`,
      },
      filePath,
    });

    struct
      .mixin(datadogMonitorSpec)
      .withoutDeprecated()
      // replace "string" with "literal type aliases union"
      // of only Operator supported Monitor Types
      // from monitorTypesBase ("types" import location)
      .update("type", {
        type: {
          union: {
            types: Object.keys(this.supportedMonitorTypes).map((s) => ({
              fqn: `types.${s}Type`,
            })),
          },
        },
        optional: false,
        immutable: true,
      })
      .update("query", {
        optional: false,
      })
      .add({
        name: "kubeMetadata",
        type: Struct.fromFqn("cdk8s.ApiObjectMetadata"),
        immutable: true,
        optional: true,
        docs: {
          default: "Generated by Chart",
          custom: {
            schema: "DatadogMonitor#metadata",
          },
        },
      });
    return filePath;
  }

  /**
   * Create a Typescript source file with a string literal type for each supported monitorType
   */
  private generateSupportedMonitorTypeLiterals(
    monitorTypesBase: string,
  ): string {
    const filePath = path.join(
      this.project.srcdir,
      outputDir,
      `${monitorTypesBase}.ts`,
    );
    const monitorTypesSrc = new TextFile(this.project, filePath);
    // Add projen marker
    monitorTypesSrc.addLine(`// ${monitorTypesSrc.marker}`);
    // Create Type alias for string literal from each supported monitorType
    Object.entries(this.supportedMonitorTypes).forEach(
      ([monitorType, stringLiteral]) => {
        monitorTypesSrc.addLine(
          `export type ${monitorType}Type = "${stringLiteral}";`,
        );
      },
    );
    return filePath;
  }
}
