// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DatadogAgent Deployment with Datadog Operator.
 *
 * @schema DatadogAgent
 */
export class DatadogAgent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatadogAgent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datadoghq.com/v1alpha1',
    kind: 'DatadogAgent',
  }

  /**
   * Renders a Kubernetes manifest for "DatadogAgent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatadogAgentProps = {}): any {
    return {
      ...DatadogAgent.GVK,
      ...toJson_DatadogAgentProps(props),
    };
  }

  /**
   * Defines a "DatadogAgent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatadogAgentProps = {}) {
    super(scope, id, {
      ...DatadogAgent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatadogAgent.GVK,
      ...toJson_DatadogAgentProps(resolved),
    };
  }
}

/**
 * DatadogAgent Deployment with Datadog Operator.
 *
 * @schema DatadogAgent
 */
export interface DatadogAgentProps {
  /**
   * @schema DatadogAgent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatadogAgentSpec defines the desired state of DatadogAgent.
   *
   * @schema DatadogAgent#spec
   */
  readonly spec?: DatadogAgentSpec;

}

/**
 * Converts an object of type 'DatadogAgentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentProps(obj: DatadogAgentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatadogAgentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatadogAgentSpec defines the desired state of DatadogAgent.
 *
 * @schema DatadogAgentSpec
 */
export interface DatadogAgentSpec {
  /**
   * The desired state of the Agent as an extended daemonset. Contains the Node Agent configuration and deployment strategy.
   *
   * @schema DatadogAgentSpec#agent
   */
  readonly agent?: DatadogAgentSpecAgent;

  /**
   * The desired state of the Cluster Agent as a deployment.
   *
   * @schema DatadogAgentSpec#clusterAgent
   */
  readonly clusterAgent?: DatadogAgentSpecClusterAgent;

  /**
   * The desired state of the Cluster Checks Runner as a deployment.
   *
   * @schema DatadogAgentSpec#clusterChecksRunner
   */
  readonly clusterChecksRunner?: DatadogAgentSpecClusterChecksRunner;

  /**
   * Set a unique cluster name to allow scoping hosts and Cluster Checks Runner easily.
   *
   * @schema DatadogAgentSpec#clusterName
   */
  readonly clusterName?: string;

  /**
   * Configure the credentials needed to run Agents. If not set, then the credentials set in the DatadogOperator will be used.
   *
   * @schema DatadogAgentSpec#credentials
   */
  readonly credentials?: DatadogAgentSpecCredentials;

  /**
   * Features running on the Agent and Cluster Agent.
   *
   * @schema DatadogAgentSpec#features
   */
  readonly features?: DatadogAgentSpecFeatures;

  /**
   * Registry to use for all Agent images (default gcr.io/datadoghq). Use public.ecr.aws/datadog for AWS Use docker.io/datadog for DockerHub
   *
   * @schema DatadogAgentSpec#registry
   */
  readonly registry?: string;

  /**
   * The site of the Datadog intake to send Agent data to. Set to 'datadoghq.eu' to send data to the EU site.
   *
   * @schema DatadogAgentSpec#site
   */
  readonly site?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpec(obj: DatadogAgentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agent': toJson_DatadogAgentSpecAgent(obj.agent),
    'clusterAgent': toJson_DatadogAgentSpecClusterAgent(obj.clusterAgent),
    'clusterChecksRunner': toJson_DatadogAgentSpecClusterChecksRunner(obj.clusterChecksRunner),
    'clusterName': obj.clusterName,
    'credentials': toJson_DatadogAgentSpecCredentials(obj.credentials),
    'features': toJson_DatadogAgentSpecFeatures(obj.features),
    'registry': obj.registry,
    'site': obj.site,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The desired state of the Agent as an extended daemonset. Contains the Node Agent configuration and deployment strategy.
 *
 * @schema DatadogAgentSpecAgent
 */
export interface DatadogAgentSpecAgent {
  /**
   * AdditionalAnnotations provide annotations that will be added to the Agent Pods.
   *
   * @schema DatadogAgentSpecAgent#additionalAnnotations
   */
  readonly additionalAnnotations?: { [key: string]: string };

  /**
   * AdditionalLabels provide labels that will be added to the Agent Pods.
   *
   * @schema DatadogAgentSpecAgent#additionalLabels
   */
  readonly additionalLabels?: { [key: string]: string };

  /**
   * If specified, the pod's scheduling constraints.
   *
   * @schema DatadogAgentSpecAgent#affinity
   */
  readonly affinity?: DatadogAgentSpecAgentAffinity;

  /**
   * Trace Agent configuration
   *
   * @schema DatadogAgentSpecAgent#apm
   */
  readonly apm?: DatadogAgentSpecAgentApm;

  /**
   * Agent configuration.
   *
   * @schema DatadogAgentSpecAgent#config
   */
  readonly config?: DatadogAgentSpecAgentConfig;

  /**
   * Allow to put custom configuration for the agent, corresponding to the datadog.yaml config file. See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
   *
   * @schema DatadogAgentSpecAgent#customConfig
   */
  readonly customConfig?: DatadogAgentSpecAgentCustomConfig;

  /**
   * Name of the Daemonset to create or migrate from.
   *
   * @schema DatadogAgentSpecAgent#daemonsetName
   */
  readonly daemonsetName?: string;

  /**
   * Update strategy configuration for the DaemonSet.
   *
   * @schema DatadogAgentSpecAgent#deploymentStrategy
   */
  readonly deploymentStrategy?: DatadogAgentSpecAgentDeploymentStrategy;

  /**
   * Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
   *
   * @schema DatadogAgentSpecAgent#dnsConfig
   */
  readonly dnsConfig?: DatadogAgentSpecAgentDnsConfig;

  /**
   * Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
   *
   * @default ClusterFirst". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
   * @schema DatadogAgentSpecAgent#dnsPolicy
   */
  readonly dnsPolicy?: string;

  /**
   * Enabled
   *
   * @schema DatadogAgentSpecAgent#enabled
   */
  readonly enabled?: boolean;

  /**
   * Environment variables for all Datadog Agents. See also: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables
   *
   * @schema DatadogAgentSpecAgent#env
   */
  readonly env?: DatadogAgentSpecAgentEnv[];

  /**
   * Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
   *
   * @default false.
   * @schema DatadogAgentSpecAgent#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's pid namespace. Optional: Default to false.
   *
   * @default false.
   * @schema DatadogAgentSpecAgent#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * The container image of the Datadog Agent.
   *
   * @schema DatadogAgentSpecAgent#image
   */
  readonly image?: DatadogAgentSpecAgentImage;

  /**
   * KeepAnnotations allows the specification of annotations not managed by the Operator that will be kept on Agent DaemonSet. All annotations containing 'datadoghq.com' are always included. This field uses glob syntax.
   *
   * @schema DatadogAgentSpecAgent#keepAnnotations
   */
  readonly keepAnnotations?: string;

  /**
   * KeepLabels allows the specification of labels not managed by the Operator that will be kept on Agent DaemonSet. All labels containing 'datadoghq.com' are always included. This field uses glob syntax.
   *
   * @schema DatadogAgentSpecAgent#keepLabels
   */
  readonly keepLabels?: string;

  /**
   * Options to customize the internal traffic policy service
   *
   * @schema DatadogAgentSpecAgent#localService
   */
  readonly localService?: DatadogAgentSpecAgentLocalService;

  /**
   * Log Agent configuration
   *
   * @schema DatadogAgentSpecAgent#log
   */
  readonly log?: DatadogAgentSpecAgentLog;

  /**
   * Provide Agent Network Policy configuration
   *
   * @schema DatadogAgentSpecAgent#networkPolicy
   */
  readonly networkPolicy?: DatadogAgentSpecAgentNetworkPolicy;

  /**
   * OTLP ingest configuration
   *
   * @schema DatadogAgentSpecAgent#otlp
   */
  readonly otlp?: DatadogAgentSpecAgentOtlp;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema DatadogAgentSpecAgent#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Process Agent configuration
   *
   * @schema DatadogAgentSpecAgent#process
   */
  readonly process?: DatadogAgentSpecAgentProcess;

  /**
   * RBAC configuration of the Agent.
   *
   * @schema DatadogAgentSpecAgent#rbac
   */
  readonly rbac?: DatadogAgentSpecAgentRbac;

  /**
   * Security Agent configuration
   *
   * @schema DatadogAgentSpecAgent#security
   */
  readonly security?: DatadogAgentSpecAgentSecurity;

  /**
   * SystemProbe configuration
   *
   * @schema DatadogAgentSpecAgent#systemProbe
   */
  readonly systemProbe?: DatadogAgentSpecAgentSystemProbe;

  /**
   * UseExtendedDaemonset use ExtendedDaemonset for Agent deployment. default value is false.
   *
   * @schema DatadogAgentSpecAgent#useExtendedDaemonset
   */
  readonly useExtendedDaemonset?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgent(obj: DatadogAgentSpecAgent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalAnnotations': ((obj.additionalAnnotations) === undefined) ? undefined : (Object.entries(obj.additionalAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'additionalLabels': ((obj.additionalLabels) === undefined) ? undefined : (Object.entries(obj.additionalLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'affinity': toJson_DatadogAgentSpecAgentAffinity(obj.affinity),
    'apm': toJson_DatadogAgentSpecAgentApm(obj.apm),
    'config': toJson_DatadogAgentSpecAgentConfig(obj.config),
    'customConfig': toJson_DatadogAgentSpecAgentCustomConfig(obj.customConfig),
    'daemonsetName': obj.daemonsetName,
    'deploymentStrategy': toJson_DatadogAgentSpecAgentDeploymentStrategy(obj.deploymentStrategy),
    'dnsConfig': toJson_DatadogAgentSpecAgentDnsConfig(obj.dnsConfig),
    'dnsPolicy': obj.dnsPolicy,
    'enabled': obj.enabled,
    'env': obj.env?.map(y => toJson_DatadogAgentSpecAgentEnv(y)),
    'hostNetwork': obj.hostNetwork,
    'hostPID': obj.hostPid,
    'image': toJson_DatadogAgentSpecAgentImage(obj.image),
    'keepAnnotations': obj.keepAnnotations,
    'keepLabels': obj.keepLabels,
    'localService': toJson_DatadogAgentSpecAgentLocalService(obj.localService),
    'log': toJson_DatadogAgentSpecAgentLog(obj.log),
    'networkPolicy': toJson_DatadogAgentSpecAgentNetworkPolicy(obj.networkPolicy),
    'otlp': toJson_DatadogAgentSpecAgentOtlp(obj.otlp),
    'priorityClassName': obj.priorityClassName,
    'process': toJson_DatadogAgentSpecAgentProcess(obj.process),
    'rbac': toJson_DatadogAgentSpecAgentRbac(obj.rbac),
    'security': toJson_DatadogAgentSpecAgentSecurity(obj.security),
    'systemProbe': toJson_DatadogAgentSpecAgentSystemProbe(obj.systemProbe),
    'useExtendedDaemonset': obj.useExtendedDaemonset,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The desired state of the Cluster Agent as a deployment.
 *
 * @schema DatadogAgentSpecClusterAgent
 */
export interface DatadogAgentSpecClusterAgent {
  /**
   * AdditionalAnnotations provide annotations that will be added to the Cluster Agent Pods.
   *
   * @schema DatadogAgentSpecClusterAgent#additionalAnnotations
   */
  readonly additionalAnnotations?: { [key: string]: string };

  /**
   * AdditionalLabels provide labels that will be added to the Cluster Agent Pods.
   *
   * @schema DatadogAgentSpecClusterAgent#additionalLabels
   */
  readonly additionalLabels?: { [key: string]: string };

  /**
   * If specified, the pod's scheduling constraints.
   *
   * @schema DatadogAgentSpecClusterAgent#affinity
   */
  readonly affinity?: DatadogAgentSpecClusterAgentAffinity;

  /**
   * Cluster Agent configuration.
   *
   * @schema DatadogAgentSpecClusterAgent#config
   */
  readonly config?: DatadogAgentSpecClusterAgentConfig;

  /**
   * Allow to put custom configuration for the Agent, corresponding to the datadog-cluster.yaml config file.
   *
   * @schema DatadogAgentSpecClusterAgent#customConfig
   */
  readonly customConfig?: DatadogAgentSpecClusterAgentCustomConfig;

  /**
   * Name of the Cluster Agent Deployment to create or migrate from.
   *
   * @schema DatadogAgentSpecClusterAgent#deploymentName
   */
  readonly deploymentName?: string;

  /**
   * Enabled
   *
   * @schema DatadogAgentSpecClusterAgent#enabled
   */
  readonly enabled?: boolean;

  /**
   * The container image of the Datadog Cluster Agent.
   *
   * @schema DatadogAgentSpecClusterAgent#image
   */
  readonly image?: DatadogAgentSpecClusterAgentImage;

  /**
   * KeepAnnotations allows the specification of annotations not managed by the Operator that will be kept on ClusterAgent Deployment. All annotations containing 'datadoghq.com' are always included. This field uses glob syntax.
   *
   * @schema DatadogAgentSpecClusterAgent#keepAnnotations
   */
  readonly keepAnnotations?: string;

  /**
   * KeepLabels allows the specification of labels not managed by the Operator that will be kept on ClusterAgent Deployment. All labels containing 'datadoghq.com' are always included. This field uses glob syntax.
   *
   * @schema DatadogAgentSpecClusterAgent#keepLabels
   */
  readonly keepLabels?: string;

  /**
   * Provide Cluster Agent Network Policy configuration.
   *
   * @schema DatadogAgentSpecClusterAgent#networkPolicy
   */
  readonly networkPolicy?: DatadogAgentSpecClusterAgentNetworkPolicy;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema DatadogAgentSpecClusterAgent#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema DatadogAgentSpecClusterAgent#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * RBAC configuration of the Datadog Cluster Agent.
   *
   * @schema DatadogAgentSpecClusterAgent#rbac
   */
  readonly rbac?: DatadogAgentSpecClusterAgentRbac;

  /**
   * Number of the Cluster Agent replicas.
   *
   * @schema DatadogAgentSpecClusterAgent#replicas
   */
  readonly replicas?: number;

  /**
   * If specified, the Cluster-Agent pod's tolerations.
   *
   * @schema DatadogAgentSpecClusterAgent#tolerations
   */
  readonly tolerations?: DatadogAgentSpecClusterAgentTolerations[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgent(obj: DatadogAgentSpecClusterAgent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalAnnotations': ((obj.additionalAnnotations) === undefined) ? undefined : (Object.entries(obj.additionalAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'additionalLabels': ((obj.additionalLabels) === undefined) ? undefined : (Object.entries(obj.additionalLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'affinity': toJson_DatadogAgentSpecClusterAgentAffinity(obj.affinity),
    'config': toJson_DatadogAgentSpecClusterAgentConfig(obj.config),
    'customConfig': toJson_DatadogAgentSpecClusterAgentCustomConfig(obj.customConfig),
    'deploymentName': obj.deploymentName,
    'enabled': obj.enabled,
    'image': toJson_DatadogAgentSpecClusterAgentImage(obj.image),
    'keepAnnotations': obj.keepAnnotations,
    'keepLabels': obj.keepLabels,
    'networkPolicy': toJson_DatadogAgentSpecClusterAgentNetworkPolicy(obj.networkPolicy),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'priorityClassName': obj.priorityClassName,
    'rbac': toJson_DatadogAgentSpecClusterAgentRbac(obj.rbac),
    'replicas': obj.replicas,
    'tolerations': obj.tolerations?.map(y => toJson_DatadogAgentSpecClusterAgentTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The desired state of the Cluster Checks Runner as a deployment.
 *
 * @schema DatadogAgentSpecClusterChecksRunner
 */
export interface DatadogAgentSpecClusterChecksRunner {
  /**
   * AdditionalAnnotations provide annotations that will be added to the cluster checks runner Pods.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#additionalAnnotations
   */
  readonly additionalAnnotations?: { [key: string]: string };

  /**
   * AdditionalLabels provide labels that will be added to the cluster checks runner Pods.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#additionalLabels
   */
  readonly additionalLabels?: { [key: string]: string };

  /**
   * If specified, the pod's scheduling constraints.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#affinity
   */
  readonly affinity?: DatadogAgentSpecClusterChecksRunnerAffinity;

  /**
   * Agent configuration.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#config
   */
  readonly config?: DatadogAgentSpecClusterChecksRunnerConfig;

  /**
   * Allow to put custom configuration for the Agent, corresponding to the datadog.yaml config file. See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#customConfig
   */
  readonly customConfig?: DatadogAgentSpecClusterChecksRunnerCustomConfig;

  /**
   * Name of the cluster checks deployment to create or migrate from.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#deploymentName
   */
  readonly deploymentName?: string;

  /**
   * Enabled
   *
   * @schema DatadogAgentSpecClusterChecksRunner#enabled
   */
  readonly enabled?: boolean;

  /**
   * The container image of the Datadog Cluster Checks Runner.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#image
   */
  readonly image?: DatadogAgentSpecClusterChecksRunnerImage;

  /**
   * Provide Cluster Checks Runner Network Policy configuration.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#networkPolicy
   */
  readonly networkPolicy?: DatadogAgentSpecClusterChecksRunnerNetworkPolicy;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema DatadogAgentSpecClusterChecksRunner#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * RBAC configuration of the Datadog Cluster Checks Runner.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#rbac
   */
  readonly rbac?: DatadogAgentSpecClusterChecksRunnerRbac;

  /**
   * Number of the Cluster Checks Runner replicas.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#replicas
   */
  readonly replicas?: number;

  /**
   * If specified, the Cluster-Checks pod's tolerations.
   *
   * @schema DatadogAgentSpecClusterChecksRunner#tolerations
   */
  readonly tolerations?: DatadogAgentSpecClusterChecksRunnerTolerations[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunner' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunner(obj: DatadogAgentSpecClusterChecksRunner | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalAnnotations': ((obj.additionalAnnotations) === undefined) ? undefined : (Object.entries(obj.additionalAnnotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'additionalLabels': ((obj.additionalLabels) === undefined) ? undefined : (Object.entries(obj.additionalLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'affinity': toJson_DatadogAgentSpecClusterChecksRunnerAffinity(obj.affinity),
    'config': toJson_DatadogAgentSpecClusterChecksRunnerConfig(obj.config),
    'customConfig': toJson_DatadogAgentSpecClusterChecksRunnerCustomConfig(obj.customConfig),
    'deploymentName': obj.deploymentName,
    'enabled': obj.enabled,
    'image': toJson_DatadogAgentSpecClusterChecksRunnerImage(obj.image),
    'networkPolicy': toJson_DatadogAgentSpecClusterChecksRunnerNetworkPolicy(obj.networkPolicy),
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'priorityClassName': obj.priorityClassName,
    'rbac': toJson_DatadogAgentSpecClusterChecksRunnerRbac(obj.rbac),
    'replicas': obj.replicas,
    'tolerations': obj.tolerations?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerTolerations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the credentials needed to run Agents. If not set, then the credentials set in the DatadogOperator will be used.
 *
 * @schema DatadogAgentSpecCredentials
 */
export interface DatadogAgentSpecCredentials {
  /**
   * APIKey Set this to your Datadog API key before the Agent runs. See also: https://app.datadoghq.com/account/settings#agent/kubernetes
   *
   * @schema DatadogAgentSpecCredentials#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIKeyExistingSecret is DEPRECATED. In order to pass the API key through an existing secret, please consider "apiSecret" instead. If set, this parameter takes precedence over "apiKey".
   *
   * @schema DatadogAgentSpecCredentials#apiKeyExistingSecret
   */
  readonly apiKeyExistingSecret?: string;

  /**
   * APISecret Use existing Secret which stores API key instead of creating a new one. If set, this parameter takes precedence over "apiKey" and "apiKeyExistingSecret".
   *
   * @schema DatadogAgentSpecCredentials#apiSecret
   */
  readonly apiSecret?: DatadogAgentSpecCredentialsApiSecret;

  /**
   * If you are using clusterAgent.metricsProvider.enabled = true, you must set a Datadog application key for read access to your metrics.
   *
   * @schema DatadogAgentSpecCredentials#appKey
   */
  readonly appKey?: string;

  /**
   * AppKeyExistingSecret is DEPRECATED. In order to pass the APP key through an existing secret, please consider "appSecret" instead. If set, this parameter takes precedence over "appKey".
   *
   * @schema DatadogAgentSpecCredentials#appKeyExistingSecret
   */
  readonly appKeyExistingSecret?: string;

  /**
   * APPSecret Use existing Secret which stores API key instead of creating a new one. If set, this parameter takes precedence over "apiKey" and "appKeyExistingSecret".
   *
   * @schema DatadogAgentSpecCredentials#appSecret
   */
  readonly appSecret?: DatadogAgentSpecCredentialsAppSecret;

  /**
   * This needs to be at least 32 characters a-zA-z. It is a preshared key between the node agents and the cluster agent.
   *
   * @schema DatadogAgentSpecCredentials#token
   */
  readonly token?: string;

  /**
   * UseSecretBackend use the Agent secret backend feature for retreiving all credentials needed by the different components: Agent, Cluster, Cluster-Checks. default value is false.
   *
   * @schema DatadogAgentSpecCredentials#useSecretBackend
   */
  readonly useSecretBackend?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecCredentials(obj: DatadogAgentSpecCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiKeyExistingSecret': obj.apiKeyExistingSecret,
    'apiSecret': toJson_DatadogAgentSpecCredentialsApiSecret(obj.apiSecret),
    'appKey': obj.appKey,
    'appKeyExistingSecret': obj.appKeyExistingSecret,
    'appSecret': toJson_DatadogAgentSpecCredentialsAppSecret(obj.appSecret),
    'token': obj.token,
    'useSecretBackend': obj.useSecretBackend,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Features running on the Agent and Cluster Agent.
 *
 * @schema DatadogAgentSpecFeatures
 */
export interface DatadogAgentSpecFeatures {
  /**
   * KubeStateMetricsCore configuration.
   *
   * @schema DatadogAgentSpecFeatures#kubeStateMetricsCore
   */
  readonly kubeStateMetricsCore?: DatadogAgentSpecFeaturesKubeStateMetricsCore;

  /**
   * LogCollection configuration.
   *
   * @schema DatadogAgentSpecFeatures#logCollection
   */
  readonly logCollection?: DatadogAgentSpecFeaturesLogCollection;

  /**
   * NetworkMonitoring configuration.
   *
   * @schema DatadogAgentSpecFeatures#networkMonitoring
   */
  readonly networkMonitoring?: DatadogAgentSpecFeaturesNetworkMonitoring;

  /**
   * OrchestratorExplorer configuration.
   *
   * @schema DatadogAgentSpecFeatures#orchestratorExplorer
   */
  readonly orchestratorExplorer?: DatadogAgentSpecFeaturesOrchestratorExplorer;

  /**
   * PrometheusScrape configuration.
   *
   * @schema DatadogAgentSpecFeatures#prometheusScrape
   */
  readonly prometheusScrape?: DatadogAgentSpecFeaturesPrometheusScrape;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeatures' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeatures(obj: DatadogAgentSpecFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubeStateMetricsCore': toJson_DatadogAgentSpecFeaturesKubeStateMetricsCore(obj.kubeStateMetricsCore),
    'logCollection': toJson_DatadogAgentSpecFeaturesLogCollection(obj.logCollection),
    'networkMonitoring': toJson_DatadogAgentSpecFeaturesNetworkMonitoring(obj.networkMonitoring),
    'orchestratorExplorer': toJson_DatadogAgentSpecFeaturesOrchestratorExplorer(obj.orchestratorExplorer),
    'prometheusScrape': toJson_DatadogAgentSpecFeaturesPrometheusScrape(obj.prometheusScrape),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints.
 *
 * @schema DatadogAgentSpecAgentAffinity
 */
export interface DatadogAgentSpecAgentAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema DatadogAgentSpecAgentAffinity#nodeAffinity
   */
  readonly nodeAffinity?: DatadogAgentSpecAgentAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema DatadogAgentSpecAgentAffinity#podAffinity
   */
  readonly podAffinity?: DatadogAgentSpecAgentAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema DatadogAgentSpecAgentAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: DatadogAgentSpecAgentAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinity(obj: DatadogAgentSpecAgentAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_DatadogAgentSpecAgentAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_DatadogAgentSpecAgentAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_DatadogAgentSpecAgentAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Trace Agent configuration
 *
 * @schema DatadogAgentSpecAgentApm
 */
export interface DatadogAgentSpecAgentApm {
  /**
   * Args allows the specification of extra args to `Command` parameter
   *
   * @schema DatadogAgentSpecAgentApm#args
   */
  readonly args?: string[];

  /**
   * Command allows the specification of custom entrypoint for Trace Agent container
   *
   * @schema DatadogAgentSpecAgentApm#command
   */
  readonly command?: string[];

  /**
   * Enable this to enable APM and tracing, on port 8126. See also: https://github.com/DataDog/docker-dd-agent#tracing-from-the-host
   *
   * @schema DatadogAgentSpecAgentApm#enabled
   */
  readonly enabled?: boolean;

  /**
   * The Datadog Agent supports many environment variables. See also: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables
   *
   * @schema DatadogAgentSpecAgentApm#env
   */
  readonly env?: DatadogAgentSpecAgentApmEnv[];

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema DatadogAgentSpecAgentApm#hostPort
   */
  readonly hostPort?: number;

  /**
   * Configure the Liveness Probe of the APM container
   *
   * @schema DatadogAgentSpecAgentApm#livenessProbe
   */
  readonly livenessProbe?: DatadogAgentSpecAgentApmLivenessProbe;

  /**
   * Datadog APM Agent resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
   *
   * @schema DatadogAgentSpecAgentApm#resources
   */
  readonly resources?: DatadogAgentSpecAgentApmResources;

  /**
   * UnixDomainSocket socket configuration. See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables
   *
   * @schema DatadogAgentSpecAgentApm#unixDomainSocket
   */
  readonly unixDomainSocket?: DatadogAgentSpecAgentApmUnixDomainSocket;

  /**
   * Specify additional volume mounts in the APM Agent container.
   *
   * @schema DatadogAgentSpecAgentApm#volumeMounts
   */
  readonly volumeMounts?: DatadogAgentSpecAgentApmVolumeMounts[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApm(obj: DatadogAgentSpecAgentApm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'enabled': obj.enabled,
    'env': obj.env?.map(y => toJson_DatadogAgentSpecAgentApmEnv(y)),
    'hostPort': obj.hostPort,
    'livenessProbe': toJson_DatadogAgentSpecAgentApmLivenessProbe(obj.livenessProbe),
    'resources': toJson_DatadogAgentSpecAgentApmResources(obj.resources),
    'unixDomainSocket': toJson_DatadogAgentSpecAgentApmUnixDomainSocket(obj.unixDomainSocket),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_DatadogAgentSpecAgentApmVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Agent configuration.
 *
 * @schema DatadogAgentSpecAgentConfig
 */
export interface DatadogAgentSpecAgentConfig {
  /**
   * Args allows the specification of extra args to `Command` parameter
   *
   * @schema DatadogAgentSpecAgentConfig#args
   */
  readonly args?: string[];

  /**
   * Checksd configuration allowing to specify custom checks placed under /etc/datadog-agent/checks.d/ See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
   *
   * @schema DatadogAgentSpecAgentConfig#checksd
   */
  readonly checksd?: DatadogAgentSpecAgentConfigChecksd;

  /**
   * Enables this to start event collection from the Kubernetes API. See also: https://docs.datadoghq.com/agent/kubernetes/event_collection/
   *
   * @schema DatadogAgentSpecAgentConfig#collectEvents
   */
  readonly collectEvents?: boolean;

  /**
   * Command allows the specification of custom entrypoint for the Agent container
   *
   * @schema DatadogAgentSpecAgentConfig#command
   */
  readonly command?: string[];

  /**
   * Confd configuration allowing to specify config files for custom checks placed under /etc/datadog-agent/conf.d/. See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
   *
   * @schema DatadogAgentSpecAgentConfig#confd
   */
  readonly confd?: DatadogAgentSpecAgentConfigConfd;

  /**
   * Configure the CRI Socket.
   *
   * @schema DatadogAgentSpecAgentConfig#criSocket
   */
  readonly criSocket?: DatadogAgentSpecAgentConfigCriSocket;

  /**
   * The host of the Datadog intake server to send Agent data to, only set this option if you need the Agent to send data to a custom URL. Overrides the site setting defined in "site".
   *
   * @schema DatadogAgentSpecAgentConfig#ddUrl
   */
  readonly ddUrl?: string;

  /**
   * Configure Dogstatsd.
   *
   * @schema DatadogAgentSpecAgentConfig#dogstatsd
   */
  readonly dogstatsd?: DatadogAgentSpecAgentConfigDogstatsd;

  /**
   * The Datadog Agent supports many environment variables. See also: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables
   *
   * @schema DatadogAgentSpecAgentConfig#env
   */
  readonly env?: DatadogAgentSpecAgentConfigEnv[];

  /**
   * HealthPort of the Agent container for internal liveness probe. Must be the same as the Liveness/Readiness probes.
   *
   * @schema DatadogAgentSpecAgentConfig#healthPort
   */
  readonly healthPort?: number;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema DatadogAgentSpecAgentConfig#hostPort
   */
  readonly hostPort?: number;

  /**
   * KubeletConfig contains the Kubelet configuration parameters
   *
   * @schema DatadogAgentSpecAgentConfig#kubelet
   */
  readonly kubelet?: DatadogAgentSpecAgentConfigKubelet;

  /**
   * Enables leader election mechanism for event collection.
   *
   * @schema DatadogAgentSpecAgentConfig#leaderElection
   */
  readonly leaderElection?: boolean;

  /**
   * Configure the Liveness Probe of the Agent container
   *
   * @schema DatadogAgentSpecAgentConfig#livenessProbe
   */
  readonly livenessProbe?: DatadogAgentSpecAgentConfigLivenessProbe;

  /**
   * Set logging verbosity, valid log levels are: trace, debug, info, warn, error, critical, and off
   *
   * @schema DatadogAgentSpecAgentConfig#logLevel
   */
  readonly logLevel?: string;

  /**
   * Provide a mapping of Kubernetes Namespace Labels to Datadog Tags. <KUBERNETES_LABEL>: <DATADOG_TAG_KEY>
   *
   * @schema DatadogAgentSpecAgentConfig#namespaceLabelsAsTags
   */
  readonly namespaceLabelsAsTags?: { [key: string]: string };

  /**
   * Provide a mapping of Kubernetes Node Labels to Datadog Tags. <KUBERNETES_LABEL>: <DATADOG_TAG_KEY>
   *
   * @schema DatadogAgentSpecAgentConfig#nodeLabelsAsTags
   */
  readonly nodeLabelsAsTags?: { [key: string]: string };

  /**
   * Provide a mapping of Kubernetes Pod Annotations to Datadog Tags. <KUBERNETES_ANNOTATIONS>: <DATADOG_TAG_KEY>
   *
   * @schema DatadogAgentSpecAgentConfig#podAnnotationsAsTags
   */
  readonly podAnnotationsAsTags?: { [key: string]: string };

  /**
   * Provide a mapping of Kubernetes Pod Labels to Datadog Tags. <KUBERNETES_LABEL>: <DATADOG_TAG_KEY>
   *
   * @schema DatadogAgentSpecAgentConfig#podLabelsAsTags
   */
  readonly podLabelsAsTags?: { [key: string]: string };

  /**
   * Configure the Readiness Probe of the Agent container
   *
   * @schema DatadogAgentSpecAgentConfig#readinessProbe
   */
  readonly readinessProbe?: DatadogAgentSpecAgentConfigReadinessProbe;

  /**
   * Datadog Agent resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
   *
   * @schema DatadogAgentSpecAgentConfig#resources
   */
  readonly resources?: DatadogAgentSpecAgentConfigResources;

  /**
   * Pod-level SecurityContext.
   *
   * @schema DatadogAgentSpecAgentConfig#securityContext
   */
  readonly securityContext?: DatadogAgentSpecAgentConfigSecurityContext;

  /**
   * List of tags to attach to every metric, event and service check collected by this Agent. Learn more about tagging: https://docs.datadoghq.com/tagging/
   *
   * @schema DatadogAgentSpecAgentConfig#tags
   */
  readonly tags?: string[];

  /**
   * If specified, the Agent pod's tolerations.
   *
   * @schema DatadogAgentSpecAgentConfig#tolerations
   */
  readonly tolerations?: DatadogAgentSpecAgentConfigTolerations[];

  /**
   * Specify additional volume mounts in the Datadog Agent container.
   *
   * @schema DatadogAgentSpecAgentConfig#volumeMounts
   */
  readonly volumeMounts?: DatadogAgentSpecAgentConfigVolumeMounts[];

  /**
   * Specify additional volumes in the Datadog Agent container.
   *
   * @schema DatadogAgentSpecAgentConfig#volumes
   */
  readonly volumes?: DatadogAgentSpecAgentConfigVolumes[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfig(obj: DatadogAgentSpecAgentConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'checksd': toJson_DatadogAgentSpecAgentConfigChecksd(obj.checksd),
    'collectEvents': obj.collectEvents,
    'command': obj.command?.map(y => y),
    'confd': toJson_DatadogAgentSpecAgentConfigConfd(obj.confd),
    'criSocket': toJson_DatadogAgentSpecAgentConfigCriSocket(obj.criSocket),
    'ddUrl': obj.ddUrl,
    'dogstatsd': toJson_DatadogAgentSpecAgentConfigDogstatsd(obj.dogstatsd),
    'env': obj.env?.map(y => toJson_DatadogAgentSpecAgentConfigEnv(y)),
    'healthPort': obj.healthPort,
    'hostPort': obj.hostPort,
    'kubelet': toJson_DatadogAgentSpecAgentConfigKubelet(obj.kubelet),
    'leaderElection': obj.leaderElection,
    'livenessProbe': toJson_DatadogAgentSpecAgentConfigLivenessProbe(obj.livenessProbe),
    'logLevel': obj.logLevel,
    'namespaceLabelsAsTags': ((obj.namespaceLabelsAsTags) === undefined) ? undefined : (Object.entries(obj.namespaceLabelsAsTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'nodeLabelsAsTags': ((obj.nodeLabelsAsTags) === undefined) ? undefined : (Object.entries(obj.nodeLabelsAsTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podAnnotationsAsTags': ((obj.podAnnotationsAsTags) === undefined) ? undefined : (Object.entries(obj.podAnnotationsAsTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podLabelsAsTags': ((obj.podLabelsAsTags) === undefined) ? undefined : (Object.entries(obj.podLabelsAsTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readinessProbe': toJson_DatadogAgentSpecAgentConfigReadinessProbe(obj.readinessProbe),
    'resources': toJson_DatadogAgentSpecAgentConfigResources(obj.resources),
    'securityContext': toJson_DatadogAgentSpecAgentConfigSecurityContext(obj.securityContext),
    'tags': obj.tags?.map(y => y),
    'tolerations': obj.tolerations?.map(y => toJson_DatadogAgentSpecAgentConfigTolerations(y)),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_DatadogAgentSpecAgentConfigVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => toJson_DatadogAgentSpecAgentConfigVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Allow to put custom configuration for the agent, corresponding to the datadog.yaml config file. See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
 *
 * @schema DatadogAgentSpecAgentCustomConfig
 */
export interface DatadogAgentSpecAgentCustomConfig {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentSpecAgentCustomConfig#configData
   */
  readonly configData?: string;

  /**
   * Enable to specify a reference to an already existing ConfigMap.
   *
   * @schema DatadogAgentSpecAgentCustomConfig#configMap
   */
  readonly configMap?: DatadogAgentSpecAgentCustomConfigConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentCustomConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentCustomConfig(obj: DatadogAgentSpecAgentCustomConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentSpecAgentCustomConfigConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Update strategy configuration for the DaemonSet.
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategy
 */
export interface DatadogAgentSpecAgentDeploymentStrategy {
  /**
   * Configure the canary deployment configuration using ExtendedDaemonSet.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategy#canary
   */
  readonly canary?: DatadogAgentSpecAgentDeploymentStrategyCanary;

  /**
   * The reconcile frequency of the ExtendDaemonSet.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategy#reconcileFrequency
   */
  readonly reconcileFrequency?: string;

  /**
   * Configure the rolling updater strategy of the DaemonSet or the ExtendedDaemonSet.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategy#rollingUpdate
   */
  readonly rollingUpdate?: DatadogAgentSpecAgentDeploymentStrategyRollingUpdate;

  /**
   * The update strategy used for the DaemonSet.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategy#updateStrategyType
   */
  readonly updateStrategyType?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentDeploymentStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentDeploymentStrategy(obj: DatadogAgentSpecAgentDeploymentStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'canary': toJson_DatadogAgentSpecAgentDeploymentStrategyCanary(obj.canary),
    'reconcileFrequency': obj.reconcileFrequency,
    'rollingUpdate': toJson_DatadogAgentSpecAgentDeploymentStrategyRollingUpdate(obj.rollingUpdate),
    'updateStrategyType': obj.updateStrategyType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
 *
 * @schema DatadogAgentSpecAgentDnsConfig
 */
export interface DatadogAgentSpecAgentDnsConfig {
  /**
   * A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
   *
   * @schema DatadogAgentSpecAgentDnsConfig#nameservers
   */
  readonly nameservers?: string[];

  /**
   * A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
   *
   * @schema DatadogAgentSpecAgentDnsConfig#options
   */
  readonly options?: DatadogAgentSpecAgentDnsConfigOptions[];

  /**
   * A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
   *
   * @schema DatadogAgentSpecAgentDnsConfig#searches
   */
  readonly searches?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentDnsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentDnsConfig(obj: DatadogAgentSpecAgentDnsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nameservers': obj.nameservers?.map(y => y),
    'options': obj.options?.map(y => toJson_DatadogAgentSpecAgentDnsConfigOptions(y)),
    'searches': obj.searches?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentSpecAgentEnv
 */
export interface DatadogAgentSpecAgentEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentSpecAgentEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentSpecAgentEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentSpecAgentEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentSpecAgentEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentEnv(obj: DatadogAgentSpecAgentEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentSpecAgentEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The container image of the Datadog Agent.
 *
 * @schema DatadogAgentSpecAgentImage
 */
export interface DatadogAgentSpecAgentImage {
  /**
   * Define whether the Agent image should support JMX. To be used if the Name field does not correspond to a full image string.
   *
   * @schema DatadogAgentSpecAgentImage#jmxEnabled
   */
  readonly jmxEnabled?: boolean;

  /**
   * Define the image to use: Use "gcr.io/datadoghq/agent:latest" for Datadog Agent 7. Use "datadog/dogstatsd:latest" for standalone Datadog Agent DogStatsD 7. Use "gcr.io/datadoghq/cluster-agent:latest" for Datadog Cluster Agent. Use "agent" with the registry and tag configurations for <registry>/agent:<tag>. Use "cluster-agent" with the registry and tag configurations for <registry>/cluster-agent:<tag>. If the name is the full image string`<name>:<tag>` or `<registry>/<name>:<tag>`, then `tag`, `jmxEnabled`, and `global.registry` values are ignored. Otherwise, image string is created by overriding default settings with supplied `name`, `tag`, and `jmxEnabled` values; image string is created using default registry unless `global.registry` is configured.
   *
   * @schema DatadogAgentSpecAgentImage#name
   */
  readonly name?: string;

  /**
   * The Kubernetes pull policy: Use Always, Never, or IfNotPresent.
   *
   * @schema DatadogAgentSpecAgentImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
   *
   * @schema DatadogAgentSpecAgentImage#pullSecrets
   */
  readonly pullSecrets?: DatadogAgentSpecAgentImagePullSecrets[];

  /**
   * Define the image tag to use. To be used if the Name field does not correspond to a full image string.
   *
   * @schema DatadogAgentSpecAgentImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentImage(obj: DatadogAgentSpecAgentImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmxEnabled': obj.jmxEnabled,
    'name': obj.name,
    'pullPolicy': obj.pullPolicy,
    'pullSecrets': obj.pullSecrets?.map(y => toJson_DatadogAgentSpecAgentImagePullSecrets(y)),
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options to customize the internal traffic policy service
 *
 * @schema DatadogAgentSpecAgentLocalService
 */
export interface DatadogAgentSpecAgentLocalService {
  /**
   * Force the creation of the internal traffic policy service to target the agent running on the local node. By default, the internal traffic service is created only on Kubernetes 1.22+ where the feature became beta and enabled by default. This option allows to force the creation of the internal traffic service on kubernetes 1.21 where the feature was alpha and required a feature gate to be explicitly enabled.
   *
   * @schema DatadogAgentSpecAgentLocalService#forceLocalServiceEnable
   */
  readonly forceLocalServiceEnable?: boolean;

  /**
   * Name of the internal traffic service to target the agent running on the local node
   *
   * @schema DatadogAgentSpecAgentLocalService#overrideName
   */
  readonly overrideName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentLocalService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentLocalService(obj: DatadogAgentSpecAgentLocalService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceLocalServiceEnable': obj.forceLocalServiceEnable,
    'overrideName': obj.overrideName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Log Agent configuration
 *
 * @schema DatadogAgentSpecAgentLog
 */
export interface DatadogAgentSpecAgentLog {
  /**
   * Collect logs from files in `/var/log/pods instead` of using the container runtime API. Collecting logs from files is usually the most efficient way of collecting logs. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup Default is true
   *
   * @default true
   * @schema DatadogAgentSpecAgentLog#containerCollectUsingFiles
   */
  readonly containerCollectUsingFiles?: boolean;

  /**
   * Allows log collection from the container log path. Set to a different path if you are not using the Docker runtime. See also: https://docs.datadoghq.com/agent/kubernetes/daemonset_setup/?tab=k8sfile#create-manifest Defaults to `/var/lib/docker/containers`
   *
   * @default var/lib/docker/containers`
   * @schema DatadogAgentSpecAgentLog#containerLogsPath
   */
  readonly containerLogsPath?: string;

  /**
   * Allows the log collection to use symbolic links in this directory to validate container ID -> pod. Defaults to `/var/log/containers`
   *
   * @default var/log/containers`
   * @schema DatadogAgentSpecAgentLog#containerSymlinksPath
   */
  readonly containerSymlinksPath?: string;

  /**
   * Enable this option to activate Datadog Agent log collection. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup
   *
   * @schema DatadogAgentSpecAgentLog#enabled
   */
  readonly enabled?: boolean;

  /**
   * Enable this option to allow log collection for all containers. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup
   *
   * @schema DatadogAgentSpecAgentLog#logsConfigContainerCollectAll
   */
  readonly logsConfigContainerCollectAll?: boolean;

  /**
   * Sets the maximum number of log files that the Datadog Agent tails. Increasing this limit can increase resource consumption of the Agent. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup Default is 100
   *
   * @default 100
   * @schema DatadogAgentSpecAgentLog#openFilesLimit
   */
  readonly openFilesLimit?: number;

  /**
   * Allows log collection from pod log path. Defaults to `/var/log/pods`.
   *
   * @default var/log/pods`.
   * @schema DatadogAgentSpecAgentLog#podLogsPath
   */
  readonly podLogsPath?: string;

  /**
   * This path (always mounted from the host) is used by Datadog Agent to store information about processed log files. If the Datadog Agent is restarted, it starts tailing the log files immediately. Default to `/var/lib/datadog-agent/logs`
   *
   * @default var/lib/datadog-agent/logs`
   * @schema DatadogAgentSpecAgentLog#tempStoragePath
   */
  readonly tempStoragePath?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentLog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentLog(obj: DatadogAgentSpecAgentLog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerCollectUsingFiles': obj.containerCollectUsingFiles,
    'containerLogsPath': obj.containerLogsPath,
    'containerSymlinksPath': obj.containerSymlinksPath,
    'enabled': obj.enabled,
    'logsConfigContainerCollectAll': obj.logsConfigContainerCollectAll,
    'openFilesLimit': obj.openFilesLimit,
    'podLogsPath': obj.podLogsPath,
    'tempStoragePath': obj.tempStoragePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Provide Agent Network Policy configuration
 *
 * @schema DatadogAgentSpecAgentNetworkPolicy
 */
export interface DatadogAgentSpecAgentNetworkPolicy {
  /**
   * If true, create a NetworkPolicy for the current agent.
   *
   * @schema DatadogAgentSpecAgentNetworkPolicy#create
   */
  readonly create?: boolean;

  /**
   * Cilium selector of the DNSserver entity.
   *
   * @schema DatadogAgentSpecAgentNetworkPolicy#dnsSelectorEndpoints
   */
  readonly dnsSelectorEndpoints?: DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpoints[];

  /**
   * Which network policy to use. Can be `kubernetes` or `cilium`.
   *
   * @schema DatadogAgentSpecAgentNetworkPolicy#flavor
   */
  readonly flavor?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentNetworkPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentNetworkPolicy(obj: DatadogAgentSpecAgentNetworkPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'create': obj.create,
    'dnsSelectorEndpoints': obj.dnsSelectorEndpoints?.map(y => toJson_DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpoints(y)),
    'flavor': obj.flavor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OTLP ingest configuration
 *
 * @schema DatadogAgentSpecAgentOtlp
 */
export interface DatadogAgentSpecAgentOtlp {
  /**
   * Receiver contains configuration for the OTLP ingest receiver.
   *
   * @schema DatadogAgentSpecAgentOtlp#receiver
   */
  readonly receiver?: DatadogAgentSpecAgentOtlpReceiver;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentOtlp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentOtlp(obj: DatadogAgentSpecAgentOtlp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receiver': toJson_DatadogAgentSpecAgentOtlpReceiver(obj.receiver),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Process Agent configuration
 *
 * @schema DatadogAgentSpecAgentProcess
 */
export interface DatadogAgentSpecAgentProcess {
  /**
   * Args allows the specification of extra args to `Command` parameter
   *
   * @schema DatadogAgentSpecAgentProcess#args
   */
  readonly args?: string[];

  /**
   * Command allows the specification of custom entrypoint for Process Agent container
   *
   * @schema DatadogAgentSpecAgentProcess#command
   */
  readonly command?: string[];

  /**
   * Enable the Process Agent container. See also: https://docs.datadoghq.com/infrastructure/process/?tab=kubernetes#installation
   *
   * @schema DatadogAgentSpecAgentProcess#enabled
   */
  readonly enabled?: boolean;

  /**
   * The Datadog Agent supports many environment variables. See also: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables
   *
   * @schema DatadogAgentSpecAgentProcess#env
   */
  readonly env?: DatadogAgentSpecAgentProcessEnv[];

  /**
   * false (default): Only collect containers if available. true: collect process information as well. Note: If enabled, /etc/passwd is automatically mounted to allow username resolution.
   *
   * @schema DatadogAgentSpecAgentProcess#processCollectionEnabled
   */
  readonly processCollectionEnabled?: boolean;

  /**
   * Datadog Process Agent resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
   *
   * @schema DatadogAgentSpecAgentProcess#resources
   */
  readonly resources?: DatadogAgentSpecAgentProcessResources;

  /**
   * Specify additional volume mounts in the Process Agent container.
   *
   * @schema DatadogAgentSpecAgentProcess#volumeMounts
   */
  readonly volumeMounts?: DatadogAgentSpecAgentProcessVolumeMounts[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentProcess' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentProcess(obj: DatadogAgentSpecAgentProcess | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'enabled': obj.enabled,
    'env': obj.env?.map(y => toJson_DatadogAgentSpecAgentProcessEnv(y)),
    'processCollectionEnabled': obj.processCollectionEnabled,
    'resources': toJson_DatadogAgentSpecAgentProcessResources(obj.resources),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_DatadogAgentSpecAgentProcessVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBAC configuration of the Agent.
 *
 * @schema DatadogAgentSpecAgentRbac
 */
export interface DatadogAgentSpecAgentRbac {
  /**
   * Used to configure RBAC resources creation.
   *
   * @schema DatadogAgentSpecAgentRbac#create
   */
  readonly create?: boolean;

  /**
   * Used to set up the service account name to use. Ignored if the field Create is true.
   *
   * @schema DatadogAgentSpecAgentRbac#serviceAccountName
   */
  readonly serviceAccountName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentRbac' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentRbac(obj: DatadogAgentSpecAgentRbac | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'create': obj.create,
    'serviceAccountName': obj.serviceAccountName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security Agent configuration
 *
 * @schema DatadogAgentSpecAgentSecurity
 */
export interface DatadogAgentSpecAgentSecurity {
  /**
   * Args allows the specification of extra args to `Command` parameter
   *
   * @schema DatadogAgentSpecAgentSecurity#args
   */
  readonly args?: string[];

  /**
   * Command allows the specification of custom entrypoint for Security Agent container
   *
   * @schema DatadogAgentSpecAgentSecurity#command
   */
  readonly command?: string[];

  /**
   * Compliance configuration.
   *
   * @schema DatadogAgentSpecAgentSecurity#compliance
   */
  readonly compliance?: DatadogAgentSpecAgentSecurityCompliance;

  /**
   * The Datadog Security Agent supports many environment variables. See also: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables
   *
   * @schema DatadogAgentSpecAgentSecurity#env
   */
  readonly env?: DatadogAgentSpecAgentSecurityEnv[];

  /**
   * Datadog Security Agent resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
   *
   * @schema DatadogAgentSpecAgentSecurity#resources
   */
  readonly resources?: DatadogAgentSpecAgentSecurityResources;

  /**
   * Runtime security configuration.
   *
   * @schema DatadogAgentSpecAgentSecurity#runtime
   */
  readonly runtime?: DatadogAgentSpecAgentSecurityRuntime;

  /**
   * Specify additional volume mounts in the Security Agent container.
   *
   * @schema DatadogAgentSpecAgentSecurity#volumeMounts
   */
  readonly volumeMounts?: DatadogAgentSpecAgentSecurityVolumeMounts[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurity(obj: DatadogAgentSpecAgentSecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'compliance': toJson_DatadogAgentSpecAgentSecurityCompliance(obj.compliance),
    'env': obj.env?.map(y => toJson_DatadogAgentSpecAgentSecurityEnv(y)),
    'resources': toJson_DatadogAgentSpecAgentSecurityResources(obj.resources),
    'runtime': toJson_DatadogAgentSpecAgentSecurityRuntime(obj.runtime),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_DatadogAgentSpecAgentSecurityVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SystemProbe configuration
 *
 * @schema DatadogAgentSpecAgentSystemProbe
 */
export interface DatadogAgentSpecAgentSystemProbe {
  /**
   * AppArmorProfileName specify a apparmor profile.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#appArmorProfileName
   */
  readonly appArmorProfileName?: string;

  /**
   * Args allows the specification of extra args to `Command` parameter
   *
   * @schema DatadogAgentSpecAgentSystemProbe#args
   */
  readonly args?: string[];

  /**
   * BPFDebugEnabled logging for kernel debug.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#bpfDebugEnabled
   */
  readonly bpfDebugEnabled?: boolean;

  /**
   * CollectDNSStats enables DNS stat collection.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#collectDNSStats
   */
  readonly collectDnsStats?: boolean;

  /**
   * Command allows the specification of custom entrypoint for System Probe container
   *
   * @schema DatadogAgentSpecAgentSystemProbe#command
   */
  readonly command?: string[];

  /**
   * ConntrackEnabled enable the system-probe agent to connect to the netlink/conntrack subsystem to add NAT information to connection data. See also: http://conntrack-tools.netfilter.org/
   *
   * @schema DatadogAgentSpecAgentSystemProbe#conntrackEnabled
   */
  readonly conntrackEnabled?: boolean;

  /**
   * Enable custom configuration for system-probe, corresponding to the system-probe.yaml config file. This custom configuration has less priority than all settings above.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#customConfig
   */
  readonly customConfig?: DatadogAgentSpecAgentSystemProbeCustomConfig;

  /**
   * DebugPort Specify the port to expose pprof and expvar for system-probe agent.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#debugPort
   */
  readonly debugPort?: number;

  /**
   * EnableOOMKill enables the OOM kill eBPF-based check.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#enableOOMKill
   */
  readonly enableOomKill?: boolean;

  /**
   * EnableTCPQueueLength enables the TCP queue length eBPF-based check.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#enableTCPQueueLength
   */
  readonly enableTcpQueueLength?: boolean;

  /**
   * Enable this to activate live process monitoring. Note: /etc/passwd is automatically mounted to allow username resolution. See also: https://docs.datadoghq.com/infrastructure/process/?tab=kubernetes#installation
   *
   * @schema DatadogAgentSpecAgentSystemProbe#enabled
   */
  readonly enabled?: boolean;

  /**
   * The Datadog SystemProbe supports many environment variables. See also: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables
   *
   * @schema DatadogAgentSpecAgentSystemProbe#env
   */
  readonly env?: DatadogAgentSpecAgentSystemProbeEnv[];

  /**
   * Datadog SystemProbe resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
   *
   * @schema DatadogAgentSpecAgentSystemProbe#resources
   */
  readonly resources?: DatadogAgentSpecAgentSystemProbeResources;

  /**
   * SecCompCustomProfileConfigMap specify a pre-existing ConfigMap containing a custom SecComp profile. This ConfigMap must contain a file named system-probe-seccomp.json.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#secCompCustomProfileConfigMap
   */
  readonly secCompCustomProfileConfigMap?: string;

  /**
   * SecCompProfileName specify a seccomp profile.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#secCompProfileName
   */
  readonly secCompProfileName?: string;

  /**
   * SecCompRootPath specify the seccomp profile root directory.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#secCompRootPath
   */
  readonly secCompRootPath?: string;

  /**
   * You can modify the security context used to run the containers by modifying the label type.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#securityContext
   */
  readonly securityContext?: DatadogAgentSpecAgentSystemProbeSecurityContext;

  /**
   * Specify additional volume mounts in the Security Agent container.
   *
   * @schema DatadogAgentSpecAgentSystemProbe#volumeMounts
   */
  readonly volumeMounts?: DatadogAgentSpecAgentSystemProbeVolumeMounts[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbe(obj: DatadogAgentSpecAgentSystemProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfileName': obj.appArmorProfileName,
    'args': obj.args?.map(y => y),
    'bpfDebugEnabled': obj.bpfDebugEnabled,
    'collectDNSStats': obj.collectDnsStats,
    'command': obj.command?.map(y => y),
    'conntrackEnabled': obj.conntrackEnabled,
    'customConfig': toJson_DatadogAgentSpecAgentSystemProbeCustomConfig(obj.customConfig),
    'debugPort': obj.debugPort,
    'enableOOMKill': obj.enableOomKill,
    'enableTCPQueueLength': obj.enableTcpQueueLength,
    'enabled': obj.enabled,
    'env': obj.env?.map(y => toJson_DatadogAgentSpecAgentSystemProbeEnv(y)),
    'resources': toJson_DatadogAgentSpecAgentSystemProbeResources(obj.resources),
    'secCompCustomProfileConfigMap': obj.secCompCustomProfileConfigMap,
    'secCompProfileName': obj.secCompProfileName,
    'secCompRootPath': obj.secCompRootPath,
    'securityContext': toJson_DatadogAgentSpecAgentSystemProbeSecurityContext(obj.securityContext),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_DatadogAgentSpecAgentSystemProbeVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints.
 *
 * @schema DatadogAgentSpecClusterAgentAffinity
 */
export interface DatadogAgentSpecClusterAgentAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema DatadogAgentSpecClusterAgentAffinity#nodeAffinity
   */
  readonly nodeAffinity?: DatadogAgentSpecClusterAgentAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema DatadogAgentSpecClusterAgentAffinity#podAffinity
   */
  readonly podAffinity?: DatadogAgentSpecClusterAgentAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema DatadogAgentSpecClusterAgentAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinity(obj: DatadogAgentSpecClusterAgentAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_DatadogAgentSpecClusterAgentAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cluster Agent configuration.
 *
 * @schema DatadogAgentSpecClusterAgentConfig
 */
export interface DatadogAgentSpecClusterAgentConfig {
  /**
   * Configure the Admission Controller.
   *
   * @schema DatadogAgentSpecClusterAgentConfig#admissionController
   */
  readonly admissionController?: DatadogAgentSpecClusterAgentConfigAdmissionController;

  /**
   * Args allows the specification of extra args to `Command` parameter
   *
   * @schema DatadogAgentSpecClusterAgentConfig#args
   */
  readonly args?: string[];

  /**
   * Enable the Cluster Checks and Endpoint Checks feature on both the Cluster Agent and the daemonset. See also: https://docs.datadoghq.com/agent/cluster_agent/clusterchecks/ https://docs.datadoghq.com/agent/cluster_agent/endpointschecks/ Autodiscovery via Kube Service annotations is automatically enabled.
   *
   * @schema DatadogAgentSpecClusterAgentConfig#clusterChecksEnabled
   */
  readonly clusterChecksEnabled?: boolean;

  /**
   * Enable this to start event collection from the kubernetes API. See also: https://docs.datadoghq.com/agent/cluster_agent/event_collection/
   *
   * @schema DatadogAgentSpecClusterAgentConfig#collectEvents
   */
  readonly collectEvents?: boolean;

  /**
   * Command allows the specification of custom entrypoint for Cluster Agent container
   *
   * @schema DatadogAgentSpecClusterAgentConfig#command
   */
  readonly command?: string[];

  /**
   * Confd Provide additional cluster check configurations. Each key will become a file in /conf.d. see https://docs.datadoghq.com/agent/autodiscovery/ for more details.
   *
   * @schema DatadogAgentSpecClusterAgentConfig#confd
   */
  readonly confd?: DatadogAgentSpecClusterAgentConfigConfd;

  /**
   * The Datadog Agent supports many environment variables. See also: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables
   *
   * @schema DatadogAgentSpecClusterAgentConfig#env
   */
  readonly env?: DatadogAgentSpecClusterAgentConfigEnv[];

  /**
   * ExternalMetricsConfig contains the configuration of the external metrics provider in Cluster Agent.
   *
   * @schema DatadogAgentSpecClusterAgentConfig#externalMetrics
   */
  readonly externalMetrics?: DatadogAgentSpecClusterAgentConfigExternalMetrics;

  /**
   * HealthPort of the Agent container for internal liveness probe. Must be the same as the Liveness/Readiness probes.
   *
   * @schema DatadogAgentSpecClusterAgentConfig#healthPort
   */
  readonly healthPort?: number;

  /**
   * Set logging verbosity, valid log levels are: trace, debug, info, warn, error, critical, and off
   *
   * @schema DatadogAgentSpecClusterAgentConfig#logLevel
   */
  readonly logLevel?: string;

  /**
   * Datadog Cluster Agent resource requests and limits.
   *
   * @schema DatadogAgentSpecClusterAgentConfig#resources
   */
  readonly resources?: DatadogAgentSpecClusterAgentConfigResources;

  /**
   * Pod-level SecurityContext.
   *
   * @schema DatadogAgentSpecClusterAgentConfig#securityContext
   */
  readonly securityContext?: DatadogAgentSpecClusterAgentConfigSecurityContext;

  /**
   * Specify additional volume mounts in the Datadog Cluster Agent container.
   *
   * @schema DatadogAgentSpecClusterAgentConfig#volumeMounts
   */
  readonly volumeMounts?: DatadogAgentSpecClusterAgentConfigVolumeMounts[];

  /**
   * Specify additional volumes in the Datadog Cluster Agent container.
   *
   * @schema DatadogAgentSpecClusterAgentConfig#volumes
   */
  readonly volumes?: DatadogAgentSpecClusterAgentConfigVolumes[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfig(obj: DatadogAgentSpecClusterAgentConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admissionController': toJson_DatadogAgentSpecClusterAgentConfigAdmissionController(obj.admissionController),
    'args': obj.args?.map(y => y),
    'clusterChecksEnabled': obj.clusterChecksEnabled,
    'collectEvents': obj.collectEvents,
    'command': obj.command?.map(y => y),
    'confd': toJson_DatadogAgentSpecClusterAgentConfigConfd(obj.confd),
    'env': obj.env?.map(y => toJson_DatadogAgentSpecClusterAgentConfigEnv(y)),
    'externalMetrics': toJson_DatadogAgentSpecClusterAgentConfigExternalMetrics(obj.externalMetrics),
    'healthPort': obj.healthPort,
    'logLevel': obj.logLevel,
    'resources': toJson_DatadogAgentSpecClusterAgentConfigResources(obj.resources),
    'securityContext': toJson_DatadogAgentSpecClusterAgentConfigSecurityContext(obj.securityContext),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Allow to put custom configuration for the Agent, corresponding to the datadog-cluster.yaml config file.
 *
 * @schema DatadogAgentSpecClusterAgentCustomConfig
 */
export interface DatadogAgentSpecClusterAgentCustomConfig {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentSpecClusterAgentCustomConfig#configData
   */
  readonly configData?: string;

  /**
   * Enable to specify a reference to an already existing ConfigMap.
   *
   * @schema DatadogAgentSpecClusterAgentCustomConfig#configMap
   */
  readonly configMap?: DatadogAgentSpecClusterAgentCustomConfigConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentCustomConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentCustomConfig(obj: DatadogAgentSpecClusterAgentCustomConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentSpecClusterAgentCustomConfigConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The container image of the Datadog Cluster Agent.
 *
 * @schema DatadogAgentSpecClusterAgentImage
 */
export interface DatadogAgentSpecClusterAgentImage {
  /**
   * Define whether the Agent image should support JMX. To be used if the Name field does not correspond to a full image string.
   *
   * @schema DatadogAgentSpecClusterAgentImage#jmxEnabled
   */
  readonly jmxEnabled?: boolean;

  /**
   * Define the image to use: Use "gcr.io/datadoghq/agent:latest" for Datadog Agent 7. Use "datadog/dogstatsd:latest" for standalone Datadog Agent DogStatsD 7. Use "gcr.io/datadoghq/cluster-agent:latest" for Datadog Cluster Agent. Use "agent" with the registry and tag configurations for <registry>/agent:<tag>. Use "cluster-agent" with the registry and tag configurations for <registry>/cluster-agent:<tag>. If the name is the full image string`<name>:<tag>` or `<registry>/<name>:<tag>`, then `tag`, `jmxEnabled`, and `global.registry` values are ignored. Otherwise, image string is created by overriding default settings with supplied `name`, `tag`, and `jmxEnabled` values; image string is created using default registry unless `global.registry` is configured.
   *
   * @schema DatadogAgentSpecClusterAgentImage#name
   */
  readonly name?: string;

  /**
   * The Kubernetes pull policy: Use Always, Never, or IfNotPresent.
   *
   * @schema DatadogAgentSpecClusterAgentImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
   *
   * @schema DatadogAgentSpecClusterAgentImage#pullSecrets
   */
  readonly pullSecrets?: DatadogAgentSpecClusterAgentImagePullSecrets[];

  /**
   * Define the image tag to use. To be used if the Name field does not correspond to a full image string.
   *
   * @schema DatadogAgentSpecClusterAgentImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentImage(obj: DatadogAgentSpecClusterAgentImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmxEnabled': obj.jmxEnabled,
    'name': obj.name,
    'pullPolicy': obj.pullPolicy,
    'pullSecrets': obj.pullSecrets?.map(y => toJson_DatadogAgentSpecClusterAgentImagePullSecrets(y)),
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Provide Cluster Agent Network Policy configuration.
 *
 * @schema DatadogAgentSpecClusterAgentNetworkPolicy
 */
export interface DatadogAgentSpecClusterAgentNetworkPolicy {
  /**
   * If true, create a NetworkPolicy for the current agent.
   *
   * @schema DatadogAgentSpecClusterAgentNetworkPolicy#create
   */
  readonly create?: boolean;

  /**
   * Cilium selector of the DNSserver entity.
   *
   * @schema DatadogAgentSpecClusterAgentNetworkPolicy#dnsSelectorEndpoints
   */
  readonly dnsSelectorEndpoints?: DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpoints[];

  /**
   * Which network policy to use. Can be `kubernetes` or `cilium`.
   *
   * @schema DatadogAgentSpecClusterAgentNetworkPolicy#flavor
   */
  readonly flavor?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentNetworkPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentNetworkPolicy(obj: DatadogAgentSpecClusterAgentNetworkPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'create': obj.create,
    'dnsSelectorEndpoints': obj.dnsSelectorEndpoints?.map(y => toJson_DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpoints(y)),
    'flavor': obj.flavor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBAC configuration of the Datadog Cluster Agent.
 *
 * @schema DatadogAgentSpecClusterAgentRbac
 */
export interface DatadogAgentSpecClusterAgentRbac {
  /**
   * Used to configure RBAC resources creation.
   *
   * @schema DatadogAgentSpecClusterAgentRbac#create
   */
  readonly create?: boolean;

  /**
   * Used to set up the service account name to use. Ignored if the field Create is true.
   *
   * @schema DatadogAgentSpecClusterAgentRbac#serviceAccountName
   */
  readonly serviceAccountName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentRbac' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentRbac(obj: DatadogAgentSpecClusterAgentRbac | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'create': obj.create,
    'serviceAccountName': obj.serviceAccountName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DatadogAgentSpecClusterAgentTolerations
 */
export interface DatadogAgentSpecClusterAgentTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DatadogAgentSpecClusterAgentTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DatadogAgentSpecClusterAgentTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema DatadogAgentSpecClusterAgentTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema DatadogAgentSpecClusterAgentTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DatadogAgentSpecClusterAgentTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentTolerations(obj: DatadogAgentSpecClusterAgentTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinity
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinity#nodeAffinity
   */
  readonly nodeAffinity?: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinity#podAffinity
   */
  readonly podAffinity?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinity(obj: DatadogAgentSpecClusterChecksRunnerAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Agent configuration.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfig
 */
export interface DatadogAgentSpecClusterChecksRunnerConfig {
  /**
   * Args allows the specification of extra args to `Command` parameter
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#args
   */
  readonly args?: string[];

  /**
   * Command allows the specification of custom entrypoint for Cluster Checks Runner container
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#command
   */
  readonly command?: string[];

  /**
   * The Datadog Agent supports many environment variables. See also: https://docs.datadoghq.com/agent/docker/?tab=standard#environment-variables
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#env
   */
  readonly env?: DatadogAgentSpecClusterChecksRunnerConfigEnv[];

  /**
   * HealthPort of the Agent container for internal liveness probe. Must be the same as the Liveness/Readiness probes.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#healthPort
   */
  readonly healthPort?: number;

  /**
   * Configure the Liveness Probe of the CLC container
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#livenessProbe
   */
  readonly livenessProbe?: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe;

  /**
   * Set logging verbosity, valid log levels are: trace, debug, info, warn, error, critical, and off
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#logLevel
   */
  readonly logLevel?: string;

  /**
   * Configure the Readiness Probe of the CLC container
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#readinessProbe
   */
  readonly readinessProbe?: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe;

  /**
   * Datadog Cluster Checks Runner resource requests and limits.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#resources
   */
  readonly resources?: DatadogAgentSpecClusterChecksRunnerConfigResources;

  /**
   * Pod-level SecurityContext.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#securityContext
   */
  readonly securityContext?: DatadogAgentSpecClusterChecksRunnerConfigSecurityContext;

  /**
   * Specify additional volume mounts in the Datadog Cluster Check Runner container.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#volumeMounts
   */
  readonly volumeMounts?: DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts[];

  /**
   * Specify additional volumes in the Datadog Cluster Check Runner container.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfig#volumes
   */
  readonly volumes?: DatadogAgentSpecClusterChecksRunnerConfigVolumes[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfig(obj: DatadogAgentSpecClusterChecksRunnerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigEnv(y)),
    'healthPort': obj.healthPort,
    'livenessProbe': toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe(obj.livenessProbe),
    'logLevel': obj.logLevel,
    'readinessProbe': toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe(obj.readinessProbe),
    'resources': toJson_DatadogAgentSpecClusterChecksRunnerConfigResources(obj.resources),
    'securityContext': toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContext(obj.securityContext),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts(y)),
    'volumes': obj.volumes?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Allow to put custom configuration for the Agent, corresponding to the datadog.yaml config file. See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerCustomConfig
 */
export interface DatadogAgentSpecClusterChecksRunnerCustomConfig {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerCustomConfig#configData
   */
  readonly configData?: string;

  /**
   * Enable to specify a reference to an already existing ConfigMap.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerCustomConfig#configMap
   */
  readonly configMap?: DatadogAgentSpecClusterChecksRunnerCustomConfigConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerCustomConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerCustomConfig(obj: DatadogAgentSpecClusterChecksRunnerCustomConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentSpecClusterChecksRunnerCustomConfigConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The container image of the Datadog Cluster Checks Runner.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerImage
 */
export interface DatadogAgentSpecClusterChecksRunnerImage {
  /**
   * Define whether the Agent image should support JMX. To be used if the Name field does not correspond to a full image string.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerImage#jmxEnabled
   */
  readonly jmxEnabled?: boolean;

  /**
   * Define the image to use: Use "gcr.io/datadoghq/agent:latest" for Datadog Agent 7. Use "datadog/dogstatsd:latest" for standalone Datadog Agent DogStatsD 7. Use "gcr.io/datadoghq/cluster-agent:latest" for Datadog Cluster Agent. Use "agent" with the registry and tag configurations for <registry>/agent:<tag>. Use "cluster-agent" with the registry and tag configurations for <registry>/cluster-agent:<tag>. If the name is the full image string`<name>:<tag>` or `<registry>/<name>:<tag>`, then `tag`, `jmxEnabled`, and `global.registry` values are ignored. Otherwise, image string is created by overriding default settings with supplied `name`, `tag`, and `jmxEnabled` values; image string is created using default registry unless `global.registry` is configured.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerImage#name
   */
  readonly name?: string;

  /**
   * The Kubernetes pull policy: Use Always, Never, or IfNotPresent.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
   *
   * @schema DatadogAgentSpecClusterChecksRunnerImage#pullSecrets
   */
  readonly pullSecrets?: DatadogAgentSpecClusterChecksRunnerImagePullSecrets[];

  /**
   * Define the image tag to use. To be used if the Name field does not correspond to a full image string.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerImage(obj: DatadogAgentSpecClusterChecksRunnerImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmxEnabled': obj.jmxEnabled,
    'name': obj.name,
    'pullPolicy': obj.pullPolicy,
    'pullSecrets': obj.pullSecrets?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerImagePullSecrets(y)),
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Provide Cluster Checks Runner Network Policy configuration.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicy
 */
export interface DatadogAgentSpecClusterChecksRunnerNetworkPolicy {
  /**
   * If true, create a NetworkPolicy for the current agent.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicy#create
   */
  readonly create?: boolean;

  /**
   * Cilium selector of the DNSserver entity.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicy#dnsSelectorEndpoints
   */
  readonly dnsSelectorEndpoints?: DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpoints[];

  /**
   * Which network policy to use. Can be `kubernetes` or `cilium`.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicy#flavor
   */
  readonly flavor?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerNetworkPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerNetworkPolicy(obj: DatadogAgentSpecClusterChecksRunnerNetworkPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'create': obj.create,
    'dnsSelectorEndpoints': obj.dnsSelectorEndpoints?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpoints(y)),
    'flavor': obj.flavor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBAC configuration of the Datadog Cluster Checks Runner.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerRbac
 */
export interface DatadogAgentSpecClusterChecksRunnerRbac {
  /**
   * Used to configure RBAC resources creation.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerRbac#create
   */
  readonly create?: boolean;

  /**
   * Used to set up the service account name to use. Ignored if the field Create is true.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerRbac#serviceAccountName
   */
  readonly serviceAccountName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerRbac' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerRbac(obj: DatadogAgentSpecClusterChecksRunnerRbac | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'create': obj.create,
    'serviceAccountName': obj.serviceAccountName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerTolerations
 */
export interface DatadogAgentSpecClusterChecksRunnerTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema DatadogAgentSpecClusterChecksRunnerTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerTolerations(obj: DatadogAgentSpecClusterChecksRunnerTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APISecret Use existing Secret which stores API key instead of creating a new one. If set, this parameter takes precedence over "apiKey" and "apiKeyExistingSecret".
 *
 * @schema DatadogAgentSpecCredentialsApiSecret
 */
export interface DatadogAgentSpecCredentialsApiSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentSpecCredentialsApiSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentSpecCredentialsApiSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecCredentialsApiSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecCredentialsApiSecret(obj: DatadogAgentSpecCredentialsApiSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APPSecret Use existing Secret which stores API key instead of creating a new one. If set, this parameter takes precedence over "apiKey" and "appKeyExistingSecret".
 *
 * @schema DatadogAgentSpecCredentialsAppSecret
 */
export interface DatadogAgentSpecCredentialsAppSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentSpecCredentialsAppSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentSpecCredentialsAppSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecCredentialsAppSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecCredentialsAppSecret(obj: DatadogAgentSpecCredentialsAppSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KubeStateMetricsCore configuration.
 *
 * @schema DatadogAgentSpecFeaturesKubeStateMetricsCore
 */
export interface DatadogAgentSpecFeaturesKubeStateMetricsCore {
  /**
   * ClusterCheck configures the Kubernetes State Metrics Core check as a cluster check.
   *
   * @schema DatadogAgentSpecFeaturesKubeStateMetricsCore#clusterCheck
   */
  readonly clusterCheck?: boolean;

  /**
   * To override the configuration for the default Kubernetes State Metrics Core check. Must point to a ConfigMap containing a valid cluster check configuration.
   *
   * @schema DatadogAgentSpecFeaturesKubeStateMetricsCore#conf
   */
  readonly conf?: DatadogAgentSpecFeaturesKubeStateMetricsCoreConf;

  /**
   * Enable this to start the Kubernetes State Metrics Core check. Refer to https://docs.datadoghq.com/integrations/kubernetes_state_core
   *
   * @schema DatadogAgentSpecFeaturesKubeStateMetricsCore#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesKubeStateMetricsCore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesKubeStateMetricsCore(obj: DatadogAgentSpecFeaturesKubeStateMetricsCore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterCheck': obj.clusterCheck,
    'conf': toJson_DatadogAgentSpecFeaturesKubeStateMetricsCoreConf(obj.conf),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LogCollection configuration.
 *
 * @schema DatadogAgentSpecFeaturesLogCollection
 */
export interface DatadogAgentSpecFeaturesLogCollection {
  /**
   * Collect logs from files in `/var/log/pods instead` of using the container runtime API. Collecting logs from files is usually the most efficient way of collecting logs. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup Default is true
   *
   * @default true
   * @schema DatadogAgentSpecFeaturesLogCollection#containerCollectUsingFiles
   */
  readonly containerCollectUsingFiles?: boolean;

  /**
   * Allows log collection from the container log path. Set to a different path if you are not using the Docker runtime. See also: https://docs.datadoghq.com/agent/kubernetes/daemonset_setup/?tab=k8sfile#create-manifest Defaults to `/var/lib/docker/containers`
   *
   * @default var/lib/docker/containers`
   * @schema DatadogAgentSpecFeaturesLogCollection#containerLogsPath
   */
  readonly containerLogsPath?: string;

  /**
   * Allows the log collection to use symbolic links in this directory to validate container ID -> pod. Defaults to `/var/log/containers`
   *
   * @default var/log/containers`
   * @schema DatadogAgentSpecFeaturesLogCollection#containerSymlinksPath
   */
  readonly containerSymlinksPath?: string;

  /**
   * Enable this option to activate Datadog Agent log collection. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup
   *
   * @schema DatadogAgentSpecFeaturesLogCollection#enabled
   */
  readonly enabled?: boolean;

  /**
   * Enable this option to allow log collection for all containers. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup
   *
   * @schema DatadogAgentSpecFeaturesLogCollection#logsConfigContainerCollectAll
   */
  readonly logsConfigContainerCollectAll?: boolean;

  /**
   * Sets the maximum number of log files that the Datadog Agent tails. Increasing this limit can increase resource consumption of the Agent. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup Default is 100
   *
   * @default 100
   * @schema DatadogAgentSpecFeaturesLogCollection#openFilesLimit
   */
  readonly openFilesLimit?: number;

  /**
   * Allows log collection from pod log path. Defaults to `/var/log/pods`.
   *
   * @default var/log/pods`.
   * @schema DatadogAgentSpecFeaturesLogCollection#podLogsPath
   */
  readonly podLogsPath?: string;

  /**
   * This path (always mounted from the host) is used by Datadog Agent to store information about processed log files. If the Datadog Agent is restarted, it starts tailing the log files immediately. Default to `/var/lib/datadog-agent/logs`
   *
   * @default var/lib/datadog-agent/logs`
   * @schema DatadogAgentSpecFeaturesLogCollection#tempStoragePath
   */
  readonly tempStoragePath?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesLogCollection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesLogCollection(obj: DatadogAgentSpecFeaturesLogCollection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerCollectUsingFiles': obj.containerCollectUsingFiles,
    'containerLogsPath': obj.containerLogsPath,
    'containerSymlinksPath': obj.containerSymlinksPath,
    'enabled': obj.enabled,
    'logsConfigContainerCollectAll': obj.logsConfigContainerCollectAll,
    'openFilesLimit': obj.openFilesLimit,
    'podLogsPath': obj.podLogsPath,
    'tempStoragePath': obj.tempStoragePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NetworkMonitoring configuration.
 *
 * @schema DatadogAgentSpecFeaturesNetworkMonitoring
 */
export interface DatadogAgentSpecFeaturesNetworkMonitoring {
  /**
   * @schema DatadogAgentSpecFeaturesNetworkMonitoring#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesNetworkMonitoring' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesNetworkMonitoring(obj: DatadogAgentSpecFeaturesNetworkMonitoring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrchestratorExplorer configuration.
 *
 * @schema DatadogAgentSpecFeaturesOrchestratorExplorer
 */
export interface DatadogAgentSpecFeaturesOrchestratorExplorer {
  /**
   * Additional endpoints for shipping the collected data as json in the form of {"https://process.agent.datadoghq.com": ["apikey1", ...], ...}'.
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorer#additionalEndpoints
   */
  readonly additionalEndpoints?: string;

  /**
   * ClusterCheck configures the Orchestrator Explorer check as a cluster check.
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorer#clusterCheck
   */
  readonly clusterCheck?: boolean;

  /**
   * To override the configuration for the default Orchestrator Explorer check. Must point to a ConfigMap containing a valid cluster check configuration.
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorer#conf
   */
  readonly conf?: DatadogAgentSpecFeaturesOrchestratorExplorerConf;

  /**
   * Set this for the Datadog endpoint for the orchestrator explorer
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorer#ddUrl
   */
  readonly ddUrl?: string;

  /**
   * Enable this to activate live Kubernetes monitoring. See also: https://docs.datadoghq.com/infrastructure/livecontainers/#kubernetes-resources
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorer#enabled
   */
  readonly enabled?: boolean;

  /**
   * Additional tags for the collected data in the form of `a b c` Difference to DD_TAGS: this is a cluster agent option that is used to define custom cluster tags
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorer#extraTags
   */
  readonly extraTags?: string[];

  /**
   * Option to disable scrubbing of sensitive container data (passwords, tokens, etc. ).
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorer#scrubbing
   */
  readonly scrubbing?: DatadogAgentSpecFeaturesOrchestratorExplorerScrubbing;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesOrchestratorExplorer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesOrchestratorExplorer(obj: DatadogAgentSpecFeaturesOrchestratorExplorer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalEndpoints': obj.additionalEndpoints,
    'clusterCheck': obj.clusterCheck,
    'conf': toJson_DatadogAgentSpecFeaturesOrchestratorExplorerConf(obj.conf),
    'ddUrl': obj.ddUrl,
    'enabled': obj.enabled,
    'extraTags': obj.extraTags?.map(y => y),
    'scrubbing': toJson_DatadogAgentSpecFeaturesOrchestratorExplorerScrubbing(obj.scrubbing),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrometheusScrape configuration.
 *
 * @schema DatadogAgentSpecFeaturesPrometheusScrape
 */
export interface DatadogAgentSpecFeaturesPrometheusScrape {
  /**
   * AdditionalConfigs allows adding advanced prometheus check configurations with custom discovery rules.
   *
   * @schema DatadogAgentSpecFeaturesPrometheusScrape#additionalConfigs
   */
  readonly additionalConfigs?: string;

  /**
   * Enable autodiscovering pods and services exposing prometheus metrics.
   *
   * @schema DatadogAgentSpecFeaturesPrometheusScrape#enabled
   */
  readonly enabled?: boolean;

  /**
   * ServiceEndpoints enables generating dedicated checks for service endpoints.
   *
   * @schema DatadogAgentSpecFeaturesPrometheusScrape#serviceEndpoints
   */
  readonly serviceEndpoints?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesPrometheusScrape' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesPrometheusScrape(obj: DatadogAgentSpecFeaturesPrometheusScrape | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalConfigs': obj.additionalConfigs,
    'enabled': obj.enabled,
    'serviceEndpoints': obj.serviceEndpoints,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema DatadogAgentSpecAgentAffinityNodeAffinity
 */
export interface DatadogAgentSpecAgentAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityNodeAffinity(obj: DatadogAgentSpecAgentAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinity
 */
export interface DatadogAgentSpecAgentAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinity(obj: DatadogAgentSpecAgentAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinity
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinity(obj: DatadogAgentSpecAgentAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentSpecAgentApmEnv
 */
export interface DatadogAgentSpecAgentApmEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentSpecAgentApmEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentSpecAgentApmEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentSpecAgentApmEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentSpecAgentApmEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmEnv(obj: DatadogAgentSpecAgentApmEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentSpecAgentApmEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Liveness Probe of the APM container
 *
 * @schema DatadogAgentSpecAgentApmLivenessProbe
 */
export interface DatadogAgentSpecAgentApmLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbe#exec
   */
  readonly exec?: DatadogAgentSpecAgentApmLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema DatadogAgentSpecAgentApmLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbe#grpc
   */
  readonly grpc?: DatadogAgentSpecAgentApmLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbe#httpGet
   */
  readonly httpGet?: DatadogAgentSpecAgentApmLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema DatadogAgentSpecAgentApmLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema DatadogAgentSpecAgentApmLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: DatadogAgentSpecAgentApmLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema DatadogAgentSpecAgentApmLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmLivenessProbe(obj: DatadogAgentSpecAgentApmLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_DatadogAgentSpecAgentApmLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_DatadogAgentSpecAgentApmLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_DatadogAgentSpecAgentApmLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_DatadogAgentSpecAgentApmLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Datadog APM Agent resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
 *
 * @schema DatadogAgentSpecAgentApmResources
 */
export interface DatadogAgentSpecAgentApmResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentApmResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecAgentApmResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentApmResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecAgentApmResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmResources(obj: DatadogAgentSpecAgentApmResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UnixDomainSocket socket configuration. See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables
 *
 * @schema DatadogAgentSpecAgentApmUnixDomainSocket
 */
export interface DatadogAgentSpecAgentApmUnixDomainSocket {
  /**
   * Enable APM over Unix Domain Socket See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables
   *
   * @schema DatadogAgentSpecAgentApmUnixDomainSocket#enabled
   */
  readonly enabled?: boolean;

  /**
   * Define the host APM socket filepath used when APM over Unix Domain Socket is enabled. (default value: /var/run/datadog/apm.sock) See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables
   *
   * @schema DatadogAgentSpecAgentApmUnixDomainSocket#hostFilepath
   */
  readonly hostFilepath?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmUnixDomainSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmUnixDomainSocket(obj: DatadogAgentSpecAgentApmUnixDomainSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'hostFilepath': obj.hostFilepath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema DatadogAgentSpecAgentApmVolumeMounts
 */
export interface DatadogAgentSpecAgentApmVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema DatadogAgentSpecAgentApmVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema DatadogAgentSpecAgentApmVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema DatadogAgentSpecAgentApmVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecAgentApmVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema DatadogAgentSpecAgentApmVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema DatadogAgentSpecAgentApmVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmVolumeMounts(obj: DatadogAgentSpecAgentApmVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Checksd configuration allowing to specify custom checks placed under /etc/datadog-agent/checks.d/ See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
 *
 * @schema DatadogAgentSpecAgentConfigChecksd
 */
export interface DatadogAgentSpecAgentConfigChecksd {
  /**
   * ConfigMapName name of a ConfigMap used to mount a directory.
   *
   * @schema DatadogAgentSpecAgentConfigChecksd#configMapName
   */
  readonly configMapName?: string;

  /**
   * items mapping between configMap data key and file path mount.
   *
   * @schema DatadogAgentSpecAgentConfigChecksd#items
   */
  readonly items?: DatadogAgentSpecAgentConfigChecksdItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigChecksd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigChecksd(obj: DatadogAgentSpecAgentConfigChecksd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapName': obj.configMapName,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentConfigChecksdItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Confd configuration allowing to specify config files for custom checks placed under /etc/datadog-agent/conf.d/. See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
 *
 * @schema DatadogAgentSpecAgentConfigConfd
 */
export interface DatadogAgentSpecAgentConfigConfd {
  /**
   * ConfigMapName name of a ConfigMap used to mount a directory.
   *
   * @schema DatadogAgentSpecAgentConfigConfd#configMapName
   */
  readonly configMapName?: string;

  /**
   * items mapping between configMap data key and file path mount.
   *
   * @schema DatadogAgentSpecAgentConfigConfd#items
   */
  readonly items?: DatadogAgentSpecAgentConfigConfdItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigConfd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigConfd(obj: DatadogAgentSpecAgentConfigConfd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapName': obj.configMapName,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentConfigConfdItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the CRI Socket.
 *
 * @schema DatadogAgentSpecAgentConfigCriSocket
 */
export interface DatadogAgentSpecAgentConfigCriSocket {
  /**
   * Path to the container runtime socket (if different from Docker). This is supported starting from agent 6.6.0.
   *
   * @schema DatadogAgentSpecAgentConfigCriSocket#criSocketPath
   */
  readonly criSocketPath?: string;

  /**
   * Path to the docker runtime socket.
   *
   * @schema DatadogAgentSpecAgentConfigCriSocket#dockerSocketPath
   */
  readonly dockerSocketPath?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigCriSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigCriSocket(obj: DatadogAgentSpecAgentConfigCriSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'criSocketPath': obj.criSocketPath,
    'dockerSocketPath': obj.dockerSocketPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure Dogstatsd.
 *
 * @schema DatadogAgentSpecAgentConfigDogstatsd
 */
export interface DatadogAgentSpecAgentConfigDogstatsd {
  /**
   * Enable origin detection for container tagging. See also: https://docs.datadoghq.com/developers/dogstatsd/unix_socket/#using-origin-detection-for-container-tagging
   *
   * @schema DatadogAgentSpecAgentConfigDogstatsd#dogstatsdOriginDetection
   */
  readonly dogstatsdOriginDetection?: boolean;

  /**
   * Configure the Dogstasd Mapper Profiles. Can be passed as raw data or via a json encoded string in a config map. See also: https://docs.datadoghq.com/developers/dogstatsd/dogstatsd_mapper/
   *
   * @schema DatadogAgentSpecAgentConfigDogstatsd#mapperProfiles
   */
  readonly mapperProfiles?: DatadogAgentSpecAgentConfigDogstatsdMapperProfiles;

  /**
   * Configure the Dogstatsd Unix Domain Socket. See also: https://docs.datadoghq.com/developers/dogstatsd/unix_socket/
   *
   * @schema DatadogAgentSpecAgentConfigDogstatsd#unixDomainSocket
   */
  readonly unixDomainSocket?: DatadogAgentSpecAgentConfigDogstatsdUnixDomainSocket;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigDogstatsd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigDogstatsd(obj: DatadogAgentSpecAgentConfigDogstatsd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dogstatsdOriginDetection': obj.dogstatsdOriginDetection,
    'mapperProfiles': toJson_DatadogAgentSpecAgentConfigDogstatsdMapperProfiles(obj.mapperProfiles),
    'unixDomainSocket': toJson_DatadogAgentSpecAgentConfigDogstatsdUnixDomainSocket(obj.unixDomainSocket),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentSpecAgentConfigEnv
 */
export interface DatadogAgentSpecAgentConfigEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentSpecAgentConfigEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentSpecAgentConfigEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentSpecAgentConfigEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentSpecAgentConfigEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigEnv(obj: DatadogAgentSpecAgentConfigEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentSpecAgentConfigEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KubeletConfig contains the Kubelet configuration parameters
 *
 * @schema DatadogAgentSpecAgentConfigKubelet
 */
export interface DatadogAgentSpecAgentConfigKubelet {
  /**
   * AgentCAPath is the container path where the kubelet CA certificate is stored. Default: '/var/run/host-kubelet-ca.crt' if hostCAPath is set, else '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
   *
   * @schema DatadogAgentSpecAgentConfigKubelet#agentCAPath
   */
  readonly agentCaPath?: string;

  /**
   * Host overrides the host used to contact kubelet API (default to status.hostIP).
   *
   * @schema DatadogAgentSpecAgentConfigKubelet#host
   */
  readonly host?: DatadogAgentSpecAgentConfigKubeletHost;

  /**
   * HostCAPath is the host path where the kubelet CA certificate is stored.
   *
   * @schema DatadogAgentSpecAgentConfigKubelet#hostCAPath
   */
  readonly hostCaPath?: string;

  /**
   * TLSVerify toggles kubelet TLS verification. Default: true
   *
   * @schema DatadogAgentSpecAgentConfigKubelet#tlsVerify
   */
  readonly tlsVerify?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigKubelet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigKubelet(obj: DatadogAgentSpecAgentConfigKubelet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agentCAPath': obj.agentCaPath,
    'host': toJson_DatadogAgentSpecAgentConfigKubeletHost(obj.host),
    'hostCAPath': obj.hostCaPath,
    'tlsVerify': obj.tlsVerify,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Liveness Probe of the Agent container
 *
 * @schema DatadogAgentSpecAgentConfigLivenessProbe
 */
export interface DatadogAgentSpecAgentConfigLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#exec
   */
  readonly exec?: DatadogAgentSpecAgentConfigLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#grpc
   */
  readonly grpc?: DatadogAgentSpecAgentConfigLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#httpGet
   */
  readonly httpGet?: DatadogAgentSpecAgentConfigLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: DatadogAgentSpecAgentConfigLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema DatadogAgentSpecAgentConfigLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigLivenessProbe(obj: DatadogAgentSpecAgentConfigLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_DatadogAgentSpecAgentConfigLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_DatadogAgentSpecAgentConfigLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_DatadogAgentSpecAgentConfigLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_DatadogAgentSpecAgentConfigLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Readiness Probe of the Agent container
 *
 * @schema DatadogAgentSpecAgentConfigReadinessProbe
 */
export interface DatadogAgentSpecAgentConfigReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#exec
   */
  readonly exec?: DatadogAgentSpecAgentConfigReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#grpc
   */
  readonly grpc?: DatadogAgentSpecAgentConfigReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#httpGet
   */
  readonly httpGet?: DatadogAgentSpecAgentConfigReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: DatadogAgentSpecAgentConfigReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema DatadogAgentSpecAgentConfigReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigReadinessProbe(obj: DatadogAgentSpecAgentConfigReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_DatadogAgentSpecAgentConfigReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_DatadogAgentSpecAgentConfigReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_DatadogAgentSpecAgentConfigReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_DatadogAgentSpecAgentConfigReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Datadog Agent resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
 *
 * @schema DatadogAgentSpecAgentConfigResources
 */
export interface DatadogAgentSpecAgentConfigResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentConfigResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecAgentConfigResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentConfigResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecAgentConfigResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigResources(obj: DatadogAgentSpecAgentConfigResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod-level SecurityContext.
 *
 * @schema DatadogAgentSpecAgentConfigSecurityContext
 */
export interface DatadogAgentSpecAgentConfigSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentSpecAgentConfigSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContext#seccompProfile
   */
  readonly seccompProfile?: DatadogAgentSpecAgentConfigSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContext#sysctls
   */
  readonly sysctls?: DatadogAgentSpecAgentConfigSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContext#windowsOptions
   */
  readonly windowsOptions?: DatadogAgentSpecAgentConfigSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigSecurityContext(obj: DatadogAgentSpecAgentConfigSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_DatadogAgentSpecAgentConfigSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_DatadogAgentSpecAgentConfigSecurityContextSysctls(y)),
    'windowsOptions': toJson_DatadogAgentSpecAgentConfigSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DatadogAgentSpecAgentConfigTolerations
 */
export interface DatadogAgentSpecAgentConfigTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DatadogAgentSpecAgentConfigTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DatadogAgentSpecAgentConfigTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema DatadogAgentSpecAgentConfigTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema DatadogAgentSpecAgentConfigTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DatadogAgentSpecAgentConfigTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigTolerations(obj: DatadogAgentSpecAgentConfigTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema DatadogAgentSpecAgentConfigVolumeMounts
 */
export interface DatadogAgentSpecAgentConfigVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema DatadogAgentSpecAgentConfigVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema DatadogAgentSpecAgentConfigVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema DatadogAgentSpecAgentConfigVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecAgentConfigVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema DatadogAgentSpecAgentConfigVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema DatadogAgentSpecAgentConfigVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumeMounts(obj: DatadogAgentSpecAgentConfigVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema DatadogAgentSpecAgentConfigVolumes
 */
export interface DatadogAgentSpecAgentConfigVolumes {
  /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#azureDisk
   */
  readonly azureDisk?: DatadogAgentSpecAgentConfigVolumesAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#azureFile
   */
  readonly azureFile?: DatadogAgentSpecAgentConfigVolumesAzureFile;

  /**
   * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#cephfs
   */
  readonly cephfs?: DatadogAgentSpecAgentConfigVolumesCephfs;

  /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#cinder
   */
  readonly cinder?: DatadogAgentSpecAgentConfigVolumesCinder;

  /**
   * ConfigMap represents a configMap that should populate this volume
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#configMap
   */
  readonly configMap?: DatadogAgentSpecAgentConfigVolumesConfigMap;

  /**
   * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#csi
   */
  readonly csi?: DatadogAgentSpecAgentConfigVolumesCsi;

  /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#downwardAPI
   */
  readonly downwardApi?: DatadogAgentSpecAgentConfigVolumesDownwardApi;

  /**
   * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#emptyDir
   */
  readonly emptyDir?: DatadogAgentSpecAgentConfigVolumesEmptyDir;

  /**
   * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#ephemeral
   */
  readonly ephemeral?: DatadogAgentSpecAgentConfigVolumesEphemeral;

  /**
   * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#fc
   */
  readonly fc?: DatadogAgentSpecAgentConfigVolumesFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#flexVolume
   */
  readonly flexVolume?: DatadogAgentSpecAgentConfigVolumesFlexVolume;

  /**
   * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#flocker
   */
  readonly flocker?: DatadogAgentSpecAgentConfigVolumesFlocker;

  /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: DatadogAgentSpecAgentConfigVolumesGcePersistentDisk;

  /**
   * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#gitRepo
   */
  readonly gitRepo?: DatadogAgentSpecAgentConfigVolumesGitRepo;

  /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#glusterfs
   */
  readonly glusterfs?: DatadogAgentSpecAgentConfigVolumesGlusterfs;

  /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#hostPath
   */
  readonly hostPath?: DatadogAgentSpecAgentConfigVolumesHostPath;

  /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#iscsi
   */
  readonly iscsi?: DatadogAgentSpecAgentConfigVolumesIscsi;

  /**
   * Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#name
   */
  readonly name: string;

  /**
   * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#nfs
   */
  readonly nfs?: DatadogAgentSpecAgentConfigVolumesNfs;

  /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: DatadogAgentSpecAgentConfigVolumesPersistentVolumeClaim;

  /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: DatadogAgentSpecAgentConfigVolumesPhotonPersistentDisk;

  /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#portworxVolume
   */
  readonly portworxVolume?: DatadogAgentSpecAgentConfigVolumesPortworxVolume;

  /**
   * Items for all in one resources secrets, configmaps, and downward API
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#projected
   */
  readonly projected?: DatadogAgentSpecAgentConfigVolumesProjected;

  /**
   * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#quobyte
   */
  readonly quobyte?: DatadogAgentSpecAgentConfigVolumesQuobyte;

  /**
   * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#rbd
   */
  readonly rbd?: DatadogAgentSpecAgentConfigVolumesRbd;

  /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#scaleIO
   */
  readonly scaleIo?: DatadogAgentSpecAgentConfigVolumesScaleIo;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#secret
   */
  readonly secret?: DatadogAgentSpecAgentConfigVolumesSecret;

  /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#storageos
   */
  readonly storageos?: DatadogAgentSpecAgentConfigVolumesStorageos;

  /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentSpecAgentConfigVolumes#vsphereVolume
   */
  readonly vsphereVolume?: DatadogAgentSpecAgentConfigVolumesVsphereVolume;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumes(obj: DatadogAgentSpecAgentConfigVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_DatadogAgentSpecAgentConfigVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_DatadogAgentSpecAgentConfigVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_DatadogAgentSpecAgentConfigVolumesCephfs(obj.cephfs),
    'cinder': toJson_DatadogAgentSpecAgentConfigVolumesCinder(obj.cinder),
    'configMap': toJson_DatadogAgentSpecAgentConfigVolumesConfigMap(obj.configMap),
    'csi': toJson_DatadogAgentSpecAgentConfigVolumesCsi(obj.csi),
    'downwardAPI': toJson_DatadogAgentSpecAgentConfigVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_DatadogAgentSpecAgentConfigVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_DatadogAgentSpecAgentConfigVolumesEphemeral(obj.ephemeral),
    'fc': toJson_DatadogAgentSpecAgentConfigVolumesFc(obj.fc),
    'flexVolume': toJson_DatadogAgentSpecAgentConfigVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_DatadogAgentSpecAgentConfigVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_DatadogAgentSpecAgentConfigVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_DatadogAgentSpecAgentConfigVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_DatadogAgentSpecAgentConfigVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_DatadogAgentSpecAgentConfigVolumesHostPath(obj.hostPath),
    'iscsi': toJson_DatadogAgentSpecAgentConfigVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_DatadogAgentSpecAgentConfigVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_DatadogAgentSpecAgentConfigVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_DatadogAgentSpecAgentConfigVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_DatadogAgentSpecAgentConfigVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_DatadogAgentSpecAgentConfigVolumesProjected(obj.projected),
    'quobyte': toJson_DatadogAgentSpecAgentConfigVolumesQuobyte(obj.quobyte),
    'rbd': toJson_DatadogAgentSpecAgentConfigVolumesRbd(obj.rbd),
    'scaleIO': toJson_DatadogAgentSpecAgentConfigVolumesScaleIo(obj.scaleIo),
    'secret': toJson_DatadogAgentSpecAgentConfigVolumesSecret(obj.secret),
    'storageos': toJson_DatadogAgentSpecAgentConfigVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_DatadogAgentSpecAgentConfigVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enable to specify a reference to an already existing ConfigMap.
 *
 * @schema DatadogAgentSpecAgentCustomConfigConfigMap
 */
export interface DatadogAgentSpecAgentCustomConfigConfigMap {
  /**
   * FileKey corresponds to the key used in the ConfigMap.Data to store the configuration file content.
   *
   * @schema DatadogAgentSpecAgentCustomConfigConfigMap#fileKey
   */
  readonly fileKey?: string;

  /**
   * The name of source ConfigMap.
   *
   * @schema DatadogAgentSpecAgentCustomConfigConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentCustomConfigConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentCustomConfigConfigMap(obj: DatadogAgentSpecAgentCustomConfigConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileKey': obj.fileKey,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the canary deployment configuration using ExtendedDaemonSet.
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyCanary
 */
export interface DatadogAgentSpecAgentDeploymentStrategyCanary {
  /**
   * ExtendedDaemonSetSpecStrategyCanaryAutoFail defines the canary deployment AutoFail parameters of the ExtendedDaemonSet.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanary#autoFail
   */
  readonly autoFail?: DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail;

  /**
   * ExtendedDaemonSetSpecStrategyCanaryAutoPause defines the canary deployment AutoPause parameters of the ExtendedDaemonSet.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanary#autoPause
   */
  readonly autoPause?: DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause;

  /**
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanary#duration
   */
  readonly duration?: string;

  /**
   * NoRestartsDuration defines min duration since last restart to end the canary phase.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanary#noRestartsDuration
   */
  readonly noRestartsDuration?: string;

  /**
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanary#nodeAntiAffinityKeys
   */
  readonly nodeAntiAffinityKeys?: string[];

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanary#nodeSelector
   */
  readonly nodeSelector?: DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelector;

  /**
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanary#replicas
   */
  readonly replicas?: DatadogAgentSpecAgentDeploymentStrategyCanaryReplicas;

  /**
   * ValidationMode used to configure how a canary deployment is validated. Possible values are 'auto' (default) and 'manual'
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanary#validationMode
   */
  readonly validationMode?: DatadogAgentSpecAgentDeploymentStrategyCanaryValidationMode;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentDeploymentStrategyCanary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentDeploymentStrategyCanary(obj: DatadogAgentSpecAgentDeploymentStrategyCanary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoFail': toJson_DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail(obj.autoFail),
    'autoPause': toJson_DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause(obj.autoPause),
    'duration': obj.duration,
    'noRestartsDuration': obj.noRestartsDuration,
    'nodeAntiAffinityKeys': obj.nodeAntiAffinityKeys?.map(y => y),
    'nodeSelector': toJson_DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelector(obj.nodeSelector),
    'replicas': obj.replicas?.value,
    'validationMode': obj.validationMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the rolling updater strategy of the DaemonSet or the ExtendedDaemonSet.
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyRollingUpdate
 */
export interface DatadogAgentSpecAgentDeploymentStrategyRollingUpdate {
  /**
   * The maxium number of pods created in parallel. Default value is 250.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyRollingUpdate#maxParallelPodCreation
   */
  readonly maxParallelPodCreation?: number;

  /**
   * MaxPodSchedulerFailure the maxinum number of not scheduled on its Node due to a scheduler failure: resource constraints. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyRollingUpdate#maxPodSchedulerFailure
   */
  readonly maxPodSchedulerFailure?: DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxPodSchedulerFailure;

  /**
   * The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyRollingUpdate#maxUnavailable
   */
  readonly maxUnavailable?: DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxUnavailable;

  /**
   * SlowStartAdditiveIncrease Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Default value is 5.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyRollingUpdate#slowStartAdditiveIncrease
   */
  readonly slowStartAdditiveIncrease?: DatadogAgentSpecAgentDeploymentStrategyRollingUpdateSlowStartAdditiveIncrease;

  /**
   * SlowStartIntervalDuration the duration between to 2 Default value is 1min.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyRollingUpdate#slowStartIntervalDuration
   */
  readonly slowStartIntervalDuration?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentDeploymentStrategyRollingUpdate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentDeploymentStrategyRollingUpdate(obj: DatadogAgentSpecAgentDeploymentStrategyRollingUpdate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxParallelPodCreation': obj.maxParallelPodCreation,
    'maxPodSchedulerFailure': obj.maxPodSchedulerFailure?.value,
    'maxUnavailable': obj.maxUnavailable?.value,
    'slowStartAdditiveIncrease': obj.slowStartAdditiveIncrease?.value,
    'slowStartIntervalDuration': obj.slowStartIntervalDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @schema DatadogAgentSpecAgentDnsConfigOptions
 */
export interface DatadogAgentSpecAgentDnsConfigOptions {
  /**
   * Required.
   *
   * @schema DatadogAgentSpecAgentDnsConfigOptions#name
   */
  readonly name?: string;

  /**
   * @schema DatadogAgentSpecAgentDnsConfigOptions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentDnsConfigOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentDnsConfigOptions(obj: DatadogAgentSpecAgentDnsConfigOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentSpecAgentEnvValueFrom
 */
export interface DatadogAgentSpecAgentEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentSpecAgentEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentSpecAgentEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecAgentEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentSpecAgentEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecAgentEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentSpecAgentEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentSpecAgentEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentEnvValueFrom(obj: DatadogAgentSpecAgentEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentSpecAgentEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentSpecAgentEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentSpecAgentEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema DatadogAgentSpecAgentImagePullSecrets
 */
export interface DatadogAgentSpecAgentImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentImagePullSecrets(obj: DatadogAgentSpecAgentImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpoints
 */
export interface DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpoints#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpoints(obj: DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Receiver contains configuration for the OTLP ingest receiver.
 *
 * @schema DatadogAgentSpecAgentOtlpReceiver
 */
export interface DatadogAgentSpecAgentOtlpReceiver {
  /**
   * Protocols contains configuration for the OTLP ingest receiver protocols.
   *
   * @schema DatadogAgentSpecAgentOtlpReceiver#protocols
   */
  readonly protocols?: DatadogAgentSpecAgentOtlpReceiverProtocols;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentOtlpReceiver' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentOtlpReceiver(obj: DatadogAgentSpecAgentOtlpReceiver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocols': toJson_DatadogAgentSpecAgentOtlpReceiverProtocols(obj.protocols),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentSpecAgentProcessEnv
 */
export interface DatadogAgentSpecAgentProcessEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentSpecAgentProcessEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentSpecAgentProcessEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentSpecAgentProcessEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentSpecAgentProcessEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentProcessEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentProcessEnv(obj: DatadogAgentSpecAgentProcessEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentSpecAgentProcessEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Datadog Process Agent resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
 *
 * @schema DatadogAgentSpecAgentProcessResources
 */
export interface DatadogAgentSpecAgentProcessResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentProcessResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecAgentProcessResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentProcessResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecAgentProcessResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentProcessResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentProcessResources(obj: DatadogAgentSpecAgentProcessResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema DatadogAgentSpecAgentProcessVolumeMounts
 */
export interface DatadogAgentSpecAgentProcessVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema DatadogAgentSpecAgentProcessVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema DatadogAgentSpecAgentProcessVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema DatadogAgentSpecAgentProcessVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecAgentProcessVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema DatadogAgentSpecAgentProcessVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema DatadogAgentSpecAgentProcessVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentProcessVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentProcessVolumeMounts(obj: DatadogAgentSpecAgentProcessVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Compliance configuration.
 *
 * @schema DatadogAgentSpecAgentSecurityCompliance
 */
export interface DatadogAgentSpecAgentSecurityCompliance {
  /**
   * Check interval.
   *
   * @schema DatadogAgentSpecAgentSecurityCompliance#checkInterval
   */
  readonly checkInterval?: string;

  /**
   * Config dir containing compliance benchmarks.
   *
   * @schema DatadogAgentSpecAgentSecurityCompliance#configDir
   */
  readonly configDir?: DatadogAgentSpecAgentSecurityComplianceConfigDir;

  /**
   * Enables continuous compliance monitoring.
   *
   * @schema DatadogAgentSpecAgentSecurityCompliance#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityCompliance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityCompliance(obj: DatadogAgentSpecAgentSecurityCompliance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkInterval': obj.checkInterval,
    'configDir': toJson_DatadogAgentSpecAgentSecurityComplianceConfigDir(obj.configDir),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentSpecAgentSecurityEnv
 */
export interface DatadogAgentSpecAgentSecurityEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentSpecAgentSecurityEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentSpecAgentSecurityEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentSpecAgentSecurityEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentSpecAgentSecurityEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityEnv(obj: DatadogAgentSpecAgentSecurityEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentSpecAgentSecurityEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Datadog Security Agent resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
 *
 * @schema DatadogAgentSpecAgentSecurityResources
 */
export interface DatadogAgentSpecAgentSecurityResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentSecurityResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecAgentSecurityResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentSecurityResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecAgentSecurityResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityResources(obj: DatadogAgentSpecAgentSecurityResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Runtime security configuration.
 *
 * @schema DatadogAgentSpecAgentSecurityRuntime
 */
export interface DatadogAgentSpecAgentSecurityRuntime {
  /**
   * Enables runtime security features.
   *
   * @schema DatadogAgentSpecAgentSecurityRuntime#enabled
   */
  readonly enabled?: boolean;

  /**
   * ConfigDir containing security policies.
   *
   * @schema DatadogAgentSpecAgentSecurityRuntime#policiesDir
   */
  readonly policiesDir?: DatadogAgentSpecAgentSecurityRuntimePoliciesDir;

  /**
   * Syscall monitor configuration.
   *
   * @schema DatadogAgentSpecAgentSecurityRuntime#syscallMonitor
   */
  readonly syscallMonitor?: DatadogAgentSpecAgentSecurityRuntimeSyscallMonitor;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityRuntime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityRuntime(obj: DatadogAgentSpecAgentSecurityRuntime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'policiesDir': toJson_DatadogAgentSpecAgentSecurityRuntimePoliciesDir(obj.policiesDir),
    'syscallMonitor': toJson_DatadogAgentSpecAgentSecurityRuntimeSyscallMonitor(obj.syscallMonitor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema DatadogAgentSpecAgentSecurityVolumeMounts
 */
export interface DatadogAgentSpecAgentSecurityVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema DatadogAgentSpecAgentSecurityVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema DatadogAgentSpecAgentSecurityVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema DatadogAgentSpecAgentSecurityVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecAgentSecurityVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema DatadogAgentSpecAgentSecurityVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema DatadogAgentSpecAgentSecurityVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityVolumeMounts(obj: DatadogAgentSpecAgentSecurityVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enable custom configuration for system-probe, corresponding to the system-probe.yaml config file. This custom configuration has less priority than all settings above.
 *
 * @schema DatadogAgentSpecAgentSystemProbeCustomConfig
 */
export interface DatadogAgentSpecAgentSystemProbeCustomConfig {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentSpecAgentSystemProbeCustomConfig#configData
   */
  readonly configData?: string;

  /**
   * Enable to specify a reference to an already existing ConfigMap.
   *
   * @schema DatadogAgentSpecAgentSystemProbeCustomConfig#configMap
   */
  readonly configMap?: DatadogAgentSpecAgentSystemProbeCustomConfigConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeCustomConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeCustomConfig(obj: DatadogAgentSpecAgentSystemProbeCustomConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentSpecAgentSystemProbeCustomConfigConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentSpecAgentSystemProbeEnv
 */
export interface DatadogAgentSpecAgentSystemProbeEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentSpecAgentSystemProbeEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentSpecAgentSystemProbeEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeEnv(obj: DatadogAgentSpecAgentSystemProbeEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentSpecAgentSystemProbeEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Datadog SystemProbe resource requests and limits. Make sure to keep requests and limits equal to keep the pods in the Guaranteed QoS class. See also: http://kubernetes.io/docs/user-guide/compute-resources/
 *
 * @schema DatadogAgentSpecAgentSystemProbeResources
 */
export interface DatadogAgentSpecAgentSystemProbeResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentSystemProbeResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecAgentSystemProbeResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentSystemProbeResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecAgentSystemProbeResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeResources(obj: DatadogAgentSpecAgentSystemProbeResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * You can modify the security context used to run the containers by modifying the label type.
 *
 * @schema DatadogAgentSpecAgentSystemProbeSecurityContext
 */
export interface DatadogAgentSpecAgentSystemProbeSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#capabilities
   */
  readonly capabilities?: DatadogAgentSpecAgentSystemProbeSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#seccompProfile
   */
  readonly seccompProfile?: DatadogAgentSpecAgentSystemProbeSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContext#windowsOptions
   */
  readonly windowsOptions?: DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeSecurityContext(obj: DatadogAgentSpecAgentSystemProbeSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_DatadogAgentSpecAgentSystemProbeSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_DatadogAgentSpecAgentSystemProbeSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema DatadogAgentSpecAgentSystemProbeVolumeMounts
 */
export interface DatadogAgentSpecAgentSystemProbeVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema DatadogAgentSpecAgentSystemProbeVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema DatadogAgentSpecAgentSystemProbeVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema DatadogAgentSpecAgentSystemProbeVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecAgentSystemProbeVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema DatadogAgentSpecAgentSystemProbeVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema DatadogAgentSpecAgentSystemProbeVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeVolumeMounts(obj: DatadogAgentSpecAgentSystemProbeVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinity
 */
export interface DatadogAgentSpecClusterAgentAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinity(obj: DatadogAgentSpecClusterAgentAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinity
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinity(obj: DatadogAgentSpecClusterAgentAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinity
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinity(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Admission Controller.
 *
 * @schema DatadogAgentSpecClusterAgentConfigAdmissionController
 */
export interface DatadogAgentSpecClusterAgentConfigAdmissionController {
  /**
   * agentCommunicationMode corresponds to the mode used by the Datadog application libraries to communicate with the Agent. It can be "hostip", "service", or "socket".
   *
   * @schema DatadogAgentSpecClusterAgentConfigAdmissionController#agentCommunicationMode
   */
  readonly agentCommunicationMode?: string;

  /**
   * Enable the admission controller to be able to inject APM/Dogstatsd config and standard tags (env, service, version) automatically into your pods.
   *
   * @schema DatadogAgentSpecClusterAgentConfigAdmissionController#enabled
   */
  readonly enabled?: boolean;

  /**
   * MutateUnlabelled enables injecting config without having the pod label 'admission.datadoghq.com/enabled="true"'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigAdmissionController#mutateUnlabelled
   */
  readonly mutateUnlabelled?: boolean;

  /**
   * ServiceName corresponds to the webhook service name.
   *
   * @schema DatadogAgentSpecClusterAgentConfigAdmissionController#serviceName
   */
  readonly serviceName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigAdmissionController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigAdmissionController(obj: DatadogAgentSpecClusterAgentConfigAdmissionController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agentCommunicationMode': obj.agentCommunicationMode,
    'enabled': obj.enabled,
    'mutateUnlabelled': obj.mutateUnlabelled,
    'serviceName': obj.serviceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Confd Provide additional cluster check configurations. Each key will become a file in /conf.d. see https://docs.datadoghq.com/agent/autodiscovery/ for more details.
 *
 * @schema DatadogAgentSpecClusterAgentConfigConfd
 */
export interface DatadogAgentSpecClusterAgentConfigConfd {
  /**
   * ConfigMapName name of a ConfigMap used to mount a directory.
   *
   * @schema DatadogAgentSpecClusterAgentConfigConfd#configMapName
   */
  readonly configMapName?: string;

  /**
   * items mapping between configMap data key and file path mount.
   *
   * @schema DatadogAgentSpecClusterAgentConfigConfd#items
   */
  readonly items?: DatadogAgentSpecClusterAgentConfigConfdItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigConfd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigConfd(obj: DatadogAgentSpecClusterAgentConfigConfd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapName': obj.configMapName,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterAgentConfigConfdItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentSpecClusterAgentConfigEnv
 */
export interface DatadogAgentSpecClusterAgentConfigEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentSpecClusterAgentConfigEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentSpecClusterAgentConfigEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigEnv(obj: DatadogAgentSpecClusterAgentConfigEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentSpecClusterAgentConfigEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalMetricsConfig contains the configuration of the external metrics provider in Cluster Agent.
 *
 * @schema DatadogAgentSpecClusterAgentConfigExternalMetrics
 */
export interface DatadogAgentSpecClusterAgentConfigExternalMetrics {
  /**
   * Datadog credentials used by external metrics server to query Datadog. If not set, the external metrics server uses the global .spec.Credentials
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetrics#credentials
   */
  readonly credentials?: DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials;

  /**
   * Enable the metricsProvider to be able to scale based on metrics in Datadog.
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetrics#enabled
   */
  readonly enabled?: boolean;

  /**
   * Override the API endpoint for the external metrics server. Defaults to .spec.agent.config.ddUrl or "https://app.datadoghq.com" if that's empty.
   *
   * @default spec.agent.config.ddUrl or "https://app.datadoghq.com" if that's empty.
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetrics#endpoint
   */
  readonly endpoint?: string;

  /**
   * If specified configures the metricsProvider external metrics service port.
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetrics#port
   */
  readonly port?: number;

  /**
   * Enable usage of DatadogMetrics CRD (allow to scale on arbitrary queries).
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetrics#useDatadogMetrics
   */
  readonly useDatadogMetrics?: boolean;

  /**
   * Enable informer and controller of the watermark pod autoscaler. NOTE: The WatermarkPodAutoscaler controller needs to be installed. See also: https://github.com/DataDog/watermarkpodautoscaler.
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetrics#wpaController
   */
  readonly wpaController?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigExternalMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigExternalMetrics(obj: DatadogAgentSpecClusterAgentConfigExternalMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials(obj.credentials),
    'enabled': obj.enabled,
    'endpoint': obj.endpoint,
    'port': obj.port,
    'useDatadogMetrics': obj.useDatadogMetrics,
    'wpaController': obj.wpaController,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Datadog Cluster Agent resource requests and limits.
 *
 * @schema DatadogAgentSpecClusterAgentConfigResources
 */
export interface DatadogAgentSpecClusterAgentConfigResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecClusterAgentConfigResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecClusterAgentConfigResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecClusterAgentConfigResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecClusterAgentConfigResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigResources(obj: DatadogAgentSpecClusterAgentConfigResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod-level SecurityContext.
 *
 * @schema DatadogAgentSpecClusterAgentConfigSecurityContext
 */
export interface DatadogAgentSpecClusterAgentConfigSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#seccompProfile
   */
  readonly seccompProfile?: DatadogAgentSpecClusterAgentConfigSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#sysctls
   */
  readonly sysctls?: DatadogAgentSpecClusterAgentConfigSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContext#windowsOptions
   */
  readonly windowsOptions?: DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigSecurityContext(obj: DatadogAgentSpecClusterAgentConfigSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_DatadogAgentSpecClusterAgentConfigSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_DatadogAgentSpecClusterAgentConfigSecurityContextSysctls(y)),
    'windowsOptions': toJson_DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumeMounts
 */
export interface DatadogAgentSpecClusterAgentConfigVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecClusterAgentConfigVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema DatadogAgentSpecClusterAgentConfigVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema DatadogAgentSpecClusterAgentConfigVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumeMounts(obj: DatadogAgentSpecClusterAgentConfigVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumes
 */
export interface DatadogAgentSpecClusterAgentConfigVolumes {
  /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#azureDisk
   */
  readonly azureDisk?: DatadogAgentSpecClusterAgentConfigVolumesAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#azureFile
   */
  readonly azureFile?: DatadogAgentSpecClusterAgentConfigVolumesAzureFile;

  /**
   * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#cephfs
   */
  readonly cephfs?: DatadogAgentSpecClusterAgentConfigVolumesCephfs;

  /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#cinder
   */
  readonly cinder?: DatadogAgentSpecClusterAgentConfigVolumesCinder;

  /**
   * ConfigMap represents a configMap that should populate this volume
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#configMap
   */
  readonly configMap?: DatadogAgentSpecClusterAgentConfigVolumesConfigMap;

  /**
   * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#csi
   */
  readonly csi?: DatadogAgentSpecClusterAgentConfigVolumesCsi;

  /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#downwardAPI
   */
  readonly downwardApi?: DatadogAgentSpecClusterAgentConfigVolumesDownwardApi;

  /**
   * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#emptyDir
   */
  readonly emptyDir?: DatadogAgentSpecClusterAgentConfigVolumesEmptyDir;

  /**
   * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#ephemeral
   */
  readonly ephemeral?: DatadogAgentSpecClusterAgentConfigVolumesEphemeral;

  /**
   * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#fc
   */
  readonly fc?: DatadogAgentSpecClusterAgentConfigVolumesFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#flexVolume
   */
  readonly flexVolume?: DatadogAgentSpecClusterAgentConfigVolumesFlexVolume;

  /**
   * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#flocker
   */
  readonly flocker?: DatadogAgentSpecClusterAgentConfigVolumesFlocker;

  /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk;

  /**
   * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#gitRepo
   */
  readonly gitRepo?: DatadogAgentSpecClusterAgentConfigVolumesGitRepo;

  /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#glusterfs
   */
  readonly glusterfs?: DatadogAgentSpecClusterAgentConfigVolumesGlusterfs;

  /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#hostPath
   */
  readonly hostPath?: DatadogAgentSpecClusterAgentConfigVolumesHostPath;

  /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#iscsi
   */
  readonly iscsi?: DatadogAgentSpecClusterAgentConfigVolumesIscsi;

  /**
   * Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#name
   */
  readonly name: string;

  /**
   * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#nfs
   */
  readonly nfs?: DatadogAgentSpecClusterAgentConfigVolumesNfs;

  /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: DatadogAgentSpecClusterAgentConfigVolumesPersistentVolumeClaim;

  /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: DatadogAgentSpecClusterAgentConfigVolumesPhotonPersistentDisk;

  /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#portworxVolume
   */
  readonly portworxVolume?: DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume;

  /**
   * Items for all in one resources secrets, configmaps, and downward API
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#projected
   */
  readonly projected?: DatadogAgentSpecClusterAgentConfigVolumesProjected;

  /**
   * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#quobyte
   */
  readonly quobyte?: DatadogAgentSpecClusterAgentConfigVolumesQuobyte;

  /**
   * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#rbd
   */
  readonly rbd?: DatadogAgentSpecClusterAgentConfigVolumesRbd;

  /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#scaleIO
   */
  readonly scaleIo?: DatadogAgentSpecClusterAgentConfigVolumesScaleIo;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#secret
   */
  readonly secret?: DatadogAgentSpecClusterAgentConfigVolumesSecret;

  /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#storageos
   */
  readonly storageos?: DatadogAgentSpecClusterAgentConfigVolumesStorageos;

  /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumes#vsphereVolume
   */
  readonly vsphereVolume?: DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumes(obj: DatadogAgentSpecClusterAgentConfigVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_DatadogAgentSpecClusterAgentConfigVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_DatadogAgentSpecClusterAgentConfigVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_DatadogAgentSpecClusterAgentConfigVolumesCephfs(obj.cephfs),
    'cinder': toJson_DatadogAgentSpecClusterAgentConfigVolumesCinder(obj.cinder),
    'configMap': toJson_DatadogAgentSpecClusterAgentConfigVolumesConfigMap(obj.configMap),
    'csi': toJson_DatadogAgentSpecClusterAgentConfigVolumesCsi(obj.csi),
    'downwardAPI': toJson_DatadogAgentSpecClusterAgentConfigVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_DatadogAgentSpecClusterAgentConfigVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeral(obj.ephemeral),
    'fc': toJson_DatadogAgentSpecClusterAgentConfigVolumesFc(obj.fc),
    'flexVolume': toJson_DatadogAgentSpecClusterAgentConfigVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_DatadogAgentSpecClusterAgentConfigVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_DatadogAgentSpecClusterAgentConfigVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_DatadogAgentSpecClusterAgentConfigVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_DatadogAgentSpecClusterAgentConfigVolumesHostPath(obj.hostPath),
    'iscsi': toJson_DatadogAgentSpecClusterAgentConfigVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_DatadogAgentSpecClusterAgentConfigVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_DatadogAgentSpecClusterAgentConfigVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_DatadogAgentSpecClusterAgentConfigVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_DatadogAgentSpecClusterAgentConfigVolumesProjected(obj.projected),
    'quobyte': toJson_DatadogAgentSpecClusterAgentConfigVolumesQuobyte(obj.quobyte),
    'rbd': toJson_DatadogAgentSpecClusterAgentConfigVolumesRbd(obj.rbd),
    'scaleIO': toJson_DatadogAgentSpecClusterAgentConfigVolumesScaleIo(obj.scaleIo),
    'secret': toJson_DatadogAgentSpecClusterAgentConfigVolumesSecret(obj.secret),
    'storageos': toJson_DatadogAgentSpecClusterAgentConfigVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enable to specify a reference to an already existing ConfigMap.
 *
 * @schema DatadogAgentSpecClusterAgentCustomConfigConfigMap
 */
export interface DatadogAgentSpecClusterAgentCustomConfigConfigMap {
  /**
   * FileKey corresponds to the key used in the ConfigMap.Data to store the configuration file content.
   *
   * @schema DatadogAgentSpecClusterAgentCustomConfigConfigMap#fileKey
   */
  readonly fileKey?: string;

  /**
   * The name of source ConfigMap.
   *
   * @schema DatadogAgentSpecClusterAgentCustomConfigConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentCustomConfigConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentCustomConfigConfigMap(obj: DatadogAgentSpecClusterAgentCustomConfigConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileKey': obj.fileKey,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema DatadogAgentSpecClusterAgentImagePullSecrets
 */
export interface DatadogAgentSpecClusterAgentImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentImagePullSecrets(obj: DatadogAgentSpecClusterAgentImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpoints
 */
export interface DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpoints#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpoints(obj: DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinity
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinity(obj: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinity
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinity(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinity
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinity(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigEnv
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigEnv(obj: DatadogAgentSpecClusterChecksRunnerConfigEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Liveness Probe of the CLC container
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#exec
   */
  readonly exec?: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#grpc
   */
  readonly grpc?: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#httpGet
   */
  readonly httpGet?: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe(obj: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Readiness Probe of the CLC container
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#exec
   */
  readonly exec?: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#grpc
   */
  readonly grpc?: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#httpGet
   */
  readonly httpGet?: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe(obj: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Datadog Cluster Checks Runner resource requests and limits.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigResources
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecClusterChecksRunnerConfigResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecClusterChecksRunnerConfigResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigResources(obj: DatadogAgentSpecClusterChecksRunnerConfigResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod-level SecurityContext.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#seccompProfile
   */
  readonly seccompProfile?: DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#sysctls
   */
  readonly sysctls?: DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContext#windowsOptions
   */
  readonly windowsOptions?: DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContext(obj: DatadogAgentSpecClusterChecksRunnerConfigSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSysctls(y)),
    'windowsOptions': toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumes {
  /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#azureDisk
   */
  readonly azureDisk?: DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#azureFile
   */
  readonly azureFile?: DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile;

  /**
   * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#cephfs
   */
  readonly cephfs?: DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs;

  /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#cinder
   */
  readonly cinder?: DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder;

  /**
   * ConfigMap represents a configMap that should populate this volume
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#configMap
   */
  readonly configMap?: DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap;

  /**
   * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#csi
   */
  readonly csi?: DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi;

  /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#downwardAPI
   */
  readonly downwardApi?: DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApi;

  /**
   * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#emptyDir
   */
  readonly emptyDir?: DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDir;

  /**
   * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#ephemeral
   */
  readonly ephemeral?: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeral;

  /**
   * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#fc
   */
  readonly fc?: DatadogAgentSpecClusterChecksRunnerConfigVolumesFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#flexVolume
   */
  readonly flexVolume?: DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume;

  /**
   * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#flocker
   */
  readonly flocker?: DatadogAgentSpecClusterChecksRunnerConfigVolumesFlocker;

  /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk;

  /**
   * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#gitRepo
   */
  readonly gitRepo?: DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo;

  /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#glusterfs
   */
  readonly glusterfs?: DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs;

  /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#hostPath
   */
  readonly hostPath?: DatadogAgentSpecClusterChecksRunnerConfigVolumesHostPath;

  /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#iscsi
   */
  readonly iscsi?: DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi;

  /**
   * Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#name
   */
  readonly name: string;

  /**
   * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#nfs
   */
  readonly nfs?: DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs;

  /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: DatadogAgentSpecClusterChecksRunnerConfigVolumesPersistentVolumeClaim;

  /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: DatadogAgentSpecClusterChecksRunnerConfigVolumesPhotonPersistentDisk;

  /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#portworxVolume
   */
  readonly portworxVolume?: DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume;

  /**
   * Items for all in one resources secrets, configmaps, and downward API
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#projected
   */
  readonly projected?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjected;

  /**
   * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#quobyte
   */
  readonly quobyte?: DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte;

  /**
   * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#rbd
   */
  readonly rbd?: DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd;

  /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#scaleIO
   */
  readonly scaleIo?: DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#secret
   */
  readonly secret?: DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret;

  /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#storageos
   */
  readonly storageos?: DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos;

  /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumes#vsphereVolume
   */
  readonly vsphereVolume?: DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumes(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs(obj.cephfs),
    'cinder': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder(obj.cinder),
    'configMap': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap(obj.configMap),
    'csi': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi(obj.csi),
    'downwardAPI': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeral(obj.ephemeral),
    'fc': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesFc(obj.fc),
    'flexVolume': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesHostPath(obj.hostPath),
    'iscsi': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjected(obj.projected),
    'quobyte': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte(obj.quobyte),
    'rbd': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd(obj.rbd),
    'scaleIO': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo(obj.scaleIo),
    'secret': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret(obj.secret),
    'storageos': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enable to specify a reference to an already existing ConfigMap.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerCustomConfigConfigMap
 */
export interface DatadogAgentSpecClusterChecksRunnerCustomConfigConfigMap {
  /**
   * FileKey corresponds to the key used in the ConfigMap.Data to store the configuration file content.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerCustomConfigConfigMap#fileKey
   */
  readonly fileKey?: string;

  /**
   * The name of source ConfigMap.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerCustomConfigConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerCustomConfigConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerCustomConfigConfigMap(obj: DatadogAgentSpecClusterChecksRunnerCustomConfigConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileKey': obj.fileKey,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerImagePullSecrets
 */
export interface DatadogAgentSpecClusterChecksRunnerImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerImagePullSecrets(obj: DatadogAgentSpecClusterChecksRunnerImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpoints
 */
export interface DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpoints#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpoints(obj: DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * To override the configuration for the default Kubernetes State Metrics Core check. Must point to a ConfigMap containing a valid cluster check configuration.
 *
 * @schema DatadogAgentSpecFeaturesKubeStateMetricsCoreConf
 */
export interface DatadogAgentSpecFeaturesKubeStateMetricsCoreConf {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentSpecFeaturesKubeStateMetricsCoreConf#configData
   */
  readonly configData?: string;

  /**
   * Enable to specify a reference to an already existing ConfigMap.
   *
   * @schema DatadogAgentSpecFeaturesKubeStateMetricsCoreConf#configMap
   */
  readonly configMap?: DatadogAgentSpecFeaturesKubeStateMetricsCoreConfConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesKubeStateMetricsCoreConf' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesKubeStateMetricsCoreConf(obj: DatadogAgentSpecFeaturesKubeStateMetricsCoreConf | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentSpecFeaturesKubeStateMetricsCoreConfConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * To override the configuration for the default Orchestrator Explorer check. Must point to a ConfigMap containing a valid cluster check configuration.
 *
 * @schema DatadogAgentSpecFeaturesOrchestratorExplorerConf
 */
export interface DatadogAgentSpecFeaturesOrchestratorExplorerConf {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorerConf#configData
   */
  readonly configData?: string;

  /**
   * Enable to specify a reference to an already existing ConfigMap.
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorerConf#configMap
   */
  readonly configMap?: DatadogAgentSpecFeaturesOrchestratorExplorerConfConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesOrchestratorExplorerConf' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesOrchestratorExplorerConf(obj: DatadogAgentSpecFeaturesOrchestratorExplorerConf | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentSpecFeaturesOrchestratorExplorerConfConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Option to disable scrubbing of sensitive container data (passwords, tokens, etc. ).
 *
 * @schema DatadogAgentSpecFeaturesOrchestratorExplorerScrubbing
 */
export interface DatadogAgentSpecFeaturesOrchestratorExplorerScrubbing {
  /**
   * Deactivate this to stop the scrubbing of sensitive container data (passwords, tokens, etc. ).
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorerScrubbing#containers
   */
  readonly containers?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesOrchestratorExplorerScrubbing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesOrchestratorExplorerScrubbing(obj: DatadogAgentSpecFeaturesOrchestratorExplorerScrubbing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containers': obj.containers,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentSpecAgentApmEnvValueFrom
 */
export interface DatadogAgentSpecAgentApmEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecAgentApmEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmEnvValueFrom(obj: DatadogAgentSpecAgentApmEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentSpecAgentApmEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema DatadogAgentSpecAgentApmLivenessProbeExec
 */
export interface DatadogAgentSpecAgentApmLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmLivenessProbeExec(obj: DatadogAgentSpecAgentApmLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema DatadogAgentSpecAgentApmLivenessProbeGrpc
 */
export interface DatadogAgentSpecAgentApmLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmLivenessProbeGrpc(obj: DatadogAgentSpecAgentApmLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGet
 */
export interface DatadogAgentSpecAgentApmLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: DatadogAgentSpecAgentApmLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGet#port
   */
  readonly port: DatadogAgentSpecAgentApmLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmLivenessProbeHttpGet(obj: DatadogAgentSpecAgentApmLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_DatadogAgentSpecAgentApmLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema DatadogAgentSpecAgentApmLivenessProbeTcpSocket
 */
export interface DatadogAgentSpecAgentApmLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeTcpSocket#port
   */
  readonly port: DatadogAgentSpecAgentApmLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmLivenessProbeTcpSocket(obj: DatadogAgentSpecAgentApmLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecAgentApmResourcesLimits
 */
export class DatadogAgentSpecAgentApmResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecAgentApmResourcesLimits {
    return new DatadogAgentSpecAgentApmResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentApmResourcesLimits {
    return new DatadogAgentSpecAgentApmResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecAgentApmResourcesRequests
 */
export class DatadogAgentSpecAgentApmResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecAgentApmResourcesRequests {
    return new DatadogAgentSpecAgentApmResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentApmResourcesRequests {
    return new DatadogAgentSpecAgentApmResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecAgentConfigChecksdItems
 */
export interface DatadogAgentSpecAgentConfigChecksdItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecAgentConfigChecksdItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentConfigChecksdItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecAgentConfigChecksdItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigChecksdItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigChecksdItems(obj: DatadogAgentSpecAgentConfigChecksdItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecAgentConfigConfdItems
 */
export interface DatadogAgentSpecAgentConfigConfdItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecAgentConfigConfdItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentConfigConfdItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecAgentConfigConfdItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigConfdItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigConfdItems(obj: DatadogAgentSpecAgentConfigConfdItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Dogstasd Mapper Profiles. Can be passed as raw data or via a json encoded string in a config map. See also: https://docs.datadoghq.com/developers/dogstatsd/dogstatsd_mapper/
 *
 * @schema DatadogAgentSpecAgentConfigDogstatsdMapperProfiles
 */
export interface DatadogAgentSpecAgentConfigDogstatsdMapperProfiles {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentSpecAgentConfigDogstatsdMapperProfiles#configData
   */
  readonly configData?: string;

  /**
   * Enable to specify a reference to an already existing ConfigMap.
   *
   * @schema DatadogAgentSpecAgentConfigDogstatsdMapperProfiles#configMap
   */
  readonly configMap?: DatadogAgentSpecAgentConfigDogstatsdMapperProfilesConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigDogstatsdMapperProfiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigDogstatsdMapperProfiles(obj: DatadogAgentSpecAgentConfigDogstatsdMapperProfiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentSpecAgentConfigDogstatsdMapperProfilesConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Dogstatsd Unix Domain Socket. See also: https://docs.datadoghq.com/developers/dogstatsd/unix_socket/
 *
 * @schema DatadogAgentSpecAgentConfigDogstatsdUnixDomainSocket
 */
export interface DatadogAgentSpecAgentConfigDogstatsdUnixDomainSocket {
  /**
   * Enable APM over Unix Domain Socket. See also: https://docs.datadoghq.com/developers/dogstatsd/unix_socket/
   *
   * @schema DatadogAgentSpecAgentConfigDogstatsdUnixDomainSocket#enabled
   */
  readonly enabled?: boolean;

  /**
   * Define the host APM socket filepath used when APM over Unix Domain Socket is enabled. (default value: /var/run/datadog/statsd.sock). See also: https://docs.datadoghq.com/developers/dogstatsd/unix_socket/
   *
   * @schema DatadogAgentSpecAgentConfigDogstatsdUnixDomainSocket#hostFilepath
   */
  readonly hostFilepath?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigDogstatsdUnixDomainSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigDogstatsdUnixDomainSocket(obj: DatadogAgentSpecAgentConfigDogstatsdUnixDomainSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'hostFilepath': obj.hostFilepath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentSpecAgentConfigEnvValueFrom
 */
export interface DatadogAgentSpecAgentConfigEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecAgentConfigEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigEnvValueFrom(obj: DatadogAgentSpecAgentConfigEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentSpecAgentConfigEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Host overrides the host used to contact kubelet API (default to status.hostIP).
 *
 * @schema DatadogAgentSpecAgentConfigKubeletHost
 */
export interface DatadogAgentSpecAgentConfigKubeletHost {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHost#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHost#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecAgentConfigKubeletHostFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHost#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHost#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigKubeletHost' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigKubeletHost(obj: DatadogAgentSpecAgentConfigKubeletHost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentSpecAgentConfigKubeletHostFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema DatadogAgentSpecAgentConfigLivenessProbeExec
 */
export interface DatadogAgentSpecAgentConfigLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigLivenessProbeExec(obj: DatadogAgentSpecAgentConfigLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema DatadogAgentSpecAgentConfigLivenessProbeGrpc
 */
export interface DatadogAgentSpecAgentConfigLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigLivenessProbeGrpc(obj: DatadogAgentSpecAgentConfigLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGet
 */
export interface DatadogAgentSpecAgentConfigLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: DatadogAgentSpecAgentConfigLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGet#port
   */
  readonly port: DatadogAgentSpecAgentConfigLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigLivenessProbeHttpGet(obj: DatadogAgentSpecAgentConfigLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_DatadogAgentSpecAgentConfigLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema DatadogAgentSpecAgentConfigLivenessProbeTcpSocket
 */
export interface DatadogAgentSpecAgentConfigLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeTcpSocket#port
   */
  readonly port: DatadogAgentSpecAgentConfigLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigLivenessProbeTcpSocket(obj: DatadogAgentSpecAgentConfigLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema DatadogAgentSpecAgentConfigReadinessProbeExec
 */
export interface DatadogAgentSpecAgentConfigReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigReadinessProbeExec(obj: DatadogAgentSpecAgentConfigReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema DatadogAgentSpecAgentConfigReadinessProbeGrpc
 */
export interface DatadogAgentSpecAgentConfigReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigReadinessProbeGrpc(obj: DatadogAgentSpecAgentConfigReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGet
 */
export interface DatadogAgentSpecAgentConfigReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: DatadogAgentSpecAgentConfigReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGet#port
   */
  readonly port: DatadogAgentSpecAgentConfigReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigReadinessProbeHttpGet(obj: DatadogAgentSpecAgentConfigReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_DatadogAgentSpecAgentConfigReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema DatadogAgentSpecAgentConfigReadinessProbeTcpSocket
 */
export interface DatadogAgentSpecAgentConfigReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeTcpSocket#port
   */
  readonly port: DatadogAgentSpecAgentConfigReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigReadinessProbeTcpSocket(obj: DatadogAgentSpecAgentConfigReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecAgentConfigResourcesLimits
 */
export class DatadogAgentSpecAgentConfigResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigResourcesLimits {
    return new DatadogAgentSpecAgentConfigResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigResourcesLimits {
    return new DatadogAgentSpecAgentConfigResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecAgentConfigResourcesRequests
 */
export class DatadogAgentSpecAgentConfigResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigResourcesRequests {
    return new DatadogAgentSpecAgentConfigResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigResourcesRequests {
    return new DatadogAgentSpecAgentConfigResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions
 */
export interface DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions(obj: DatadogAgentSpecAgentConfigSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentSpecAgentConfigSecurityContextSeccompProfile
 */
export interface DatadogAgentSpecAgentConfigSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigSecurityContextSeccompProfile(obj: DatadogAgentSpecAgentConfigSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema DatadogAgentSpecAgentConfigSecurityContextSysctls
 */
export interface DatadogAgentSpecAgentConfigSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigSecurityContextSysctls(obj: DatadogAgentSpecAgentConfigSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema DatadogAgentSpecAgentConfigSecurityContextWindowsOptions
 */
export interface DatadogAgentSpecAgentConfigSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema DatadogAgentSpecAgentConfigSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema DatadogAgentSpecAgentConfigSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigSecurityContextWindowsOptions(obj: DatadogAgentSpecAgentConfigSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore
 */
export interface DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore(obj: DatadogAgentSpecAgentConfigVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesAzureDisk
 */
export interface DatadogAgentSpecAgentConfigVolumesAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecAgentConfigVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesAzureDisk(obj: DatadogAgentSpecAgentConfigVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesAzureFile
 */
export interface DatadogAgentSpecAgentConfigVolumesAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecAgentConfigVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema DatadogAgentSpecAgentConfigVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesAzureFile(obj: DatadogAgentSpecAgentConfigVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema DatadogAgentSpecAgentConfigVolumesCephfs
 */
export interface DatadogAgentSpecAgentConfigVolumesCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema DatadogAgentSpecAgentConfigVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCephfs#secretRef
   */
  readonly secretRef?: DatadogAgentSpecAgentConfigVolumesCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesCephfs(obj: DatadogAgentSpecAgentConfigVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_DatadogAgentSpecAgentConfigVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema DatadogAgentSpecAgentConfigVolumesCinder
 */
export interface DatadogAgentSpecAgentConfigVolumesCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * @schema DatadogAgentSpecAgentConfigVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCinder#secretRef
   */
  readonly secretRef?: DatadogAgentSpecAgentConfigVolumesCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesCinder(obj: DatadogAgentSpecAgentConfigVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecAgentConfigVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap represents a configMap that should populate this volume
 *
 * @schema DatadogAgentSpecAgentConfigVolumesConfigMap
 */
export interface DatadogAgentSpecAgentConfigVolumesConfigMap {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentSpecAgentConfigVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesConfigMap#items
   */
  readonly items?: DatadogAgentSpecAgentConfigVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema DatadogAgentSpecAgentConfigVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesConfigMap(obj: DatadogAgentSpecAgentConfigVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentConfigVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema DatadogAgentSpecAgentConfigVolumesCsi
 */
export interface DatadogAgentSpecAgentConfigVolumesCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: DatadogAgentSpecAgentConfigVolumesCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema DatadogAgentSpecAgentConfigVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesCsi(obj: DatadogAgentSpecAgentConfigVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_DatadogAgentSpecAgentConfigVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema DatadogAgentSpecAgentConfigVolumesDownwardApi
 */
export interface DatadogAgentSpecAgentConfigVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApi#items
   */
  readonly items?: DatadogAgentSpecAgentConfigVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesDownwardApi(obj: DatadogAgentSpecAgentConfigVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentConfigVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEmptyDir
 */
export interface DatadogAgentSpecAgentConfigVolumesEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: DatadogAgentSpecAgentConfigVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesEmptyDir(obj: DatadogAgentSpecAgentConfigVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeral
 */
export interface DatadogAgentSpecAgentConfigVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesEphemeral(obj: DatadogAgentSpecAgentConfigVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesFc
 */
export interface DatadogAgentSpecAgentConfigVolumesFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecAgentConfigVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesFc(obj: DatadogAgentSpecAgentConfigVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesFlexVolume
 */
export interface DatadogAgentSpecAgentConfigVolumesFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecAgentConfigVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFlexVolume#secretRef
   */
  readonly secretRef?: DatadogAgentSpecAgentConfigVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesFlexVolume(obj: DatadogAgentSpecAgentConfigVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecAgentConfigVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema DatadogAgentSpecAgentConfigVolumesFlocker
 */
export interface DatadogAgentSpecAgentConfigVolumesFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesFlocker(obj: DatadogAgentSpecAgentConfigVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema DatadogAgentSpecAgentConfigVolumesGcePersistentDisk
 */
export interface DatadogAgentSpecAgentConfigVolumesGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecAgentConfigVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentSpecAgentConfigVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentSpecAgentConfigVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema DatadogAgentSpecAgentConfigVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesGcePersistentDisk(obj: DatadogAgentSpecAgentConfigVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesGitRepo
 */
export interface DatadogAgentSpecAgentConfigVolumesGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema DatadogAgentSpecAgentConfigVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesGitRepo(obj: DatadogAgentSpecAgentConfigVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema DatadogAgentSpecAgentConfigVolumesGlusterfs
 */
export interface DatadogAgentSpecAgentConfigVolumesGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema DatadogAgentSpecAgentConfigVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema DatadogAgentSpecAgentConfigVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema DatadogAgentSpecAgentConfigVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesGlusterfs(obj: DatadogAgentSpecAgentConfigVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesHostPath
 */
export interface DatadogAgentSpecAgentConfigVolumesHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema DatadogAgentSpecAgentConfigVolumesHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema DatadogAgentSpecAgentConfigVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesHostPath(obj: DatadogAgentSpecAgentConfigVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema DatadogAgentSpecAgentConfigVolumesIscsi
 */
export interface DatadogAgentSpecAgentConfigVolumesIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#secretRef
   */
  readonly secretRef?: DatadogAgentSpecAgentConfigVolumesIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesIscsi(obj: DatadogAgentSpecAgentConfigVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecAgentConfigVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema DatadogAgentSpecAgentConfigVolumesNfs
 */
export interface DatadogAgentSpecAgentConfigVolumesNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentSpecAgentConfigVolumesNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema DatadogAgentSpecAgentConfigVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentSpecAgentConfigVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesNfs(obj: DatadogAgentSpecAgentConfigVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema DatadogAgentSpecAgentConfigVolumesPersistentVolumeClaim
 */
export interface DatadogAgentSpecAgentConfigVolumesPersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema DatadogAgentSpecAgentConfigVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesPersistentVolumeClaim(obj: DatadogAgentSpecAgentConfigVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentSpecAgentConfigVolumesPhotonPersistentDisk
 */
export interface DatadogAgentSpecAgentConfigVolumesPhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema DatadogAgentSpecAgentConfigVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesPhotonPersistentDisk(obj: DatadogAgentSpecAgentConfigVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentSpecAgentConfigVolumesPortworxVolume
 */
export interface DatadogAgentSpecAgentConfigVolumesPortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecAgentConfigVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema DatadogAgentSpecAgentConfigVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesPortworxVolume(obj: DatadogAgentSpecAgentConfigVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Items for all in one resources secrets, configmaps, and downward API
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjected
 */
export interface DatadogAgentSpecAgentConfigVolumesProjected {
  /**
   * Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjected#sources
   */
  readonly sources?: DatadogAgentSpecAgentConfigVolumesProjectedSources[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjected(obj: DatadogAgentSpecAgentConfigVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_DatadogAgentSpecAgentConfigVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema DatadogAgentSpecAgentConfigVolumesQuobyte
 */
export interface DatadogAgentSpecAgentConfigVolumesQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema DatadogAgentSpecAgentConfigVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecAgentConfigVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema DatadogAgentSpecAgentConfigVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema DatadogAgentSpecAgentConfigVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema DatadogAgentSpecAgentConfigVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesQuobyte(obj: DatadogAgentSpecAgentConfigVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema DatadogAgentSpecAgentConfigVolumesRbd
 */
export interface DatadogAgentSpecAgentConfigVolumesRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecAgentConfigVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecAgentConfigVolumesRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecAgentConfigVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecAgentConfigVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecAgentConfigVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecAgentConfigVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecAgentConfigVolumesRbd#secretRef
   */
  readonly secretRef?: DatadogAgentSpecAgentConfigVolumesRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecAgentConfigVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesRbd(obj: DatadogAgentSpecAgentConfigVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecAgentConfigVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesScaleIo
 */
export interface DatadogAgentSpecAgentConfigVolumesScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#secretRef
   */
  readonly secretRef: DatadogAgentSpecAgentConfigVolumesScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesScaleIo(obj: DatadogAgentSpecAgentConfigVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecAgentConfigVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema DatadogAgentSpecAgentConfigVolumesSecret
 */
export interface DatadogAgentSpecAgentConfigVolumesSecret {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentSpecAgentConfigVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesSecret#items
   */
  readonly items?: DatadogAgentSpecAgentConfigVolumesSecretItems[];

  /**
   * Specify whether the Secret or its keys must be defined
   *
   * @schema DatadogAgentSpecAgentConfigVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema DatadogAgentSpecAgentConfigVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesSecret(obj: DatadogAgentSpecAgentConfigVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentConfigVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesStorageos
 */
export interface DatadogAgentSpecAgentConfigVolumesStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecAgentConfigVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesStorageos#secretRef
   */
  readonly secretRef?: DatadogAgentSpecAgentConfigVolumesStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesStorageos(obj: DatadogAgentSpecAgentConfigVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecAgentConfigVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentSpecAgentConfigVolumesVsphereVolume
 */
export interface DatadogAgentSpecAgentConfigVolumesVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema DatadogAgentSpecAgentConfigVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesVsphereVolume(obj: DatadogAgentSpecAgentConfigVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtendedDaemonSetSpecStrategyCanaryAutoFail defines the canary deployment AutoFail parameters of the ExtendedDaemonSet.
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail
 */
export interface DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail {
  /**
   * CanaryTimeout defines the maximum duration of a Canary, after which the Canary deployment is autofailed. This is a safeguard against lengthy Canary pauses. There is no default value.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail#canaryTimeout
   */
  readonly canaryTimeout?: string;

  /**
   * Enabled enables AutoFail. Default value is true.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail#enabled
   */
  readonly enabled?: boolean;

  /**
   * MaxRestarts defines the number of tolerable (per pod) Canary pod restarts after which the Canary deployment is autofailed. Default value is 5.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail#maxRestarts
   */
  readonly maxRestarts?: number;

  /**
   * MaxRestartsDuration defines the maximum duration of tolerable Canary pod restarts after which the Canary deployment is autofailed. There is no default value.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail#maxRestartsDuration
   */
  readonly maxRestartsDuration?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail(obj: DatadogAgentSpecAgentDeploymentStrategyCanaryAutoFail | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'canaryTimeout': obj.canaryTimeout,
    'enabled': obj.enabled,
    'maxRestarts': obj.maxRestarts,
    'maxRestartsDuration': obj.maxRestartsDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExtendedDaemonSetSpecStrategyCanaryAutoPause defines the canary deployment AutoPause parameters of the ExtendedDaemonSet.
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause
 */
export interface DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause {
  /**
   * Enabled enables AutoPause. Default value is true.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause#enabled
   */
  readonly enabled?: boolean;

  /**
   * MaxRestarts defines the number of tolerable (per pod) Canary pod restarts after which the Canary deployment is autopaused. Default value is 2.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause#maxRestarts
   */
  readonly maxRestarts?: number;

  /**
   * MaxSlowStartDuration defines the maximum slow start duration for a pod (stuck in Creating state) after which the Canary deployment is autopaused. There is no default value.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause#maxSlowStartDuration
   */
  readonly maxSlowStartDuration?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause(obj: DatadogAgentSpecAgentDeploymentStrategyCanaryAutoPause | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'maxRestarts': obj.maxRestarts,
    'maxSlowStartDuration': obj.maxSlowStartDuration,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelector
 */
export interface DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelector(obj: DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryReplicas
 */
export class DatadogAgentSpecAgentDeploymentStrategyCanaryReplicas {
  public static fromNumber(value: number): DatadogAgentSpecAgentDeploymentStrategyCanaryReplicas {
    return new DatadogAgentSpecAgentDeploymentStrategyCanaryReplicas(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentDeploymentStrategyCanaryReplicas {
    return new DatadogAgentSpecAgentDeploymentStrategyCanaryReplicas(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ValidationMode used to configure how a canary deployment is validated. Possible values are 'auto' (default) and 'manual'
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryValidationMode
 */
export enum DatadogAgentSpecAgentDeploymentStrategyCanaryValidationMode {
  /** auto */
  AUTO = "auto",
  /** manual */
  MANUAL = "manual",
}

/**
 * MaxPodSchedulerFailure the maxinum number of not scheduled on its Node due to a scheduler failure: resource constraints. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxPodSchedulerFailure
 */
export class DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxPodSchedulerFailure {
  public static fromNumber(value: number): DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxPodSchedulerFailure {
    return new DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxPodSchedulerFailure(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxPodSchedulerFailure {
    return new DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxPodSchedulerFailure(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1.
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxUnavailable
 */
export class DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxUnavailable {
  public static fromNumber(value: number): DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxUnavailable {
    return new DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxUnavailable(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxUnavailable {
    return new DatadogAgentSpecAgentDeploymentStrategyRollingUpdateMaxUnavailable(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * SlowStartAdditiveIncrease Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Default value is 5.
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyRollingUpdateSlowStartAdditiveIncrease
 */
export class DatadogAgentSpecAgentDeploymentStrategyRollingUpdateSlowStartAdditiveIncrease {
  public static fromNumber(value: number): DatadogAgentSpecAgentDeploymentStrategyRollingUpdateSlowStartAdditiveIncrease {
    return new DatadogAgentSpecAgentDeploymentStrategyRollingUpdateSlowStartAdditiveIncrease(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentDeploymentStrategyRollingUpdateSlowStartAdditiveIncrease {
    return new DatadogAgentSpecAgentDeploymentStrategyRollingUpdateSlowStartAdditiveIncrease(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef(obj: DatadogAgentSpecAgentEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentSpecAgentEnvValueFromFieldRef
 */
export interface DatadogAgentSpecAgentEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecAgentEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecAgentEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentEnvValueFromFieldRef(obj: DatadogAgentSpecAgentEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentSpecAgentEnvValueFromResourceFieldRef
 */
export interface DatadogAgentSpecAgentEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecAgentEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecAgentEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecAgentEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecAgentEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentEnvValueFromResourceFieldRef(obj: DatadogAgentSpecAgentEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentSpecAgentEnvValueFromSecretKeyRef
 */
export interface DatadogAgentSpecAgentEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentSpecAgentEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecAgentEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentEnvValueFromSecretKeyRef(obj: DatadogAgentSpecAgentEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions
 */
export interface DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions(obj: DatadogAgentSpecAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocols contains configuration for the OTLP ingest receiver protocols.
 *
 * @schema DatadogAgentSpecAgentOtlpReceiverProtocols
 */
export interface DatadogAgentSpecAgentOtlpReceiverProtocols {
  /**
   * GRPC contains configuration for the OTLP ingest OTLP/gRPC receiver.
   *
   * @schema DatadogAgentSpecAgentOtlpReceiverProtocols#grpc
   */
  readonly grpc?: DatadogAgentSpecAgentOtlpReceiverProtocolsGrpc;

  /**
   * HTTP contains configuration for the OTLP ingest OTLP/HTTP receiver.
   *
   * @schema DatadogAgentSpecAgentOtlpReceiverProtocols#http
   */
  readonly http?: DatadogAgentSpecAgentOtlpReceiverProtocolsHttp;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentOtlpReceiverProtocols' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentOtlpReceiverProtocols(obj: DatadogAgentSpecAgentOtlpReceiverProtocols | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_DatadogAgentSpecAgentOtlpReceiverProtocolsGrpc(obj.grpc),
    'http': toJson_DatadogAgentSpecAgentOtlpReceiverProtocolsHttp(obj.http),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentSpecAgentProcessEnvValueFrom
 */
export interface DatadogAgentSpecAgentProcessEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecAgentProcessEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentProcessEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentProcessEnvValueFrom(obj: DatadogAgentSpecAgentProcessEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentSpecAgentProcessEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecAgentProcessResourcesLimits
 */
export class DatadogAgentSpecAgentProcessResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecAgentProcessResourcesLimits {
    return new DatadogAgentSpecAgentProcessResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentProcessResourcesLimits {
    return new DatadogAgentSpecAgentProcessResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecAgentProcessResourcesRequests
 */
export class DatadogAgentSpecAgentProcessResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecAgentProcessResourcesRequests {
    return new DatadogAgentSpecAgentProcessResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentProcessResourcesRequests {
    return new DatadogAgentSpecAgentProcessResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Config dir containing compliance benchmarks.
 *
 * @schema DatadogAgentSpecAgentSecurityComplianceConfigDir
 */
export interface DatadogAgentSpecAgentSecurityComplianceConfigDir {
  /**
   * ConfigMapName name of a ConfigMap used to mount a directory.
   *
   * @schema DatadogAgentSpecAgentSecurityComplianceConfigDir#configMapName
   */
  readonly configMapName?: string;

  /**
   * items mapping between configMap data key and file path mount.
   *
   * @schema DatadogAgentSpecAgentSecurityComplianceConfigDir#items
   */
  readonly items?: DatadogAgentSpecAgentSecurityComplianceConfigDirItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityComplianceConfigDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityComplianceConfigDir(obj: DatadogAgentSpecAgentSecurityComplianceConfigDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapName': obj.configMapName,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentSecurityComplianceConfigDirItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentSpecAgentSecurityEnvValueFrom
 */
export interface DatadogAgentSpecAgentSecurityEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecAgentSecurityEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityEnvValueFrom(obj: DatadogAgentSpecAgentSecurityEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentSpecAgentSecurityEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecAgentSecurityResourcesLimits
 */
export class DatadogAgentSpecAgentSecurityResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecAgentSecurityResourcesLimits {
    return new DatadogAgentSpecAgentSecurityResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentSecurityResourcesLimits {
    return new DatadogAgentSpecAgentSecurityResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecAgentSecurityResourcesRequests
 */
export class DatadogAgentSpecAgentSecurityResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecAgentSecurityResourcesRequests {
    return new DatadogAgentSpecAgentSecurityResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentSecurityResourcesRequests {
    return new DatadogAgentSpecAgentSecurityResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConfigDir containing security policies.
 *
 * @schema DatadogAgentSpecAgentSecurityRuntimePoliciesDir
 */
export interface DatadogAgentSpecAgentSecurityRuntimePoliciesDir {
  /**
   * ConfigMapName name of a ConfigMap used to mount a directory.
   *
   * @schema DatadogAgentSpecAgentSecurityRuntimePoliciesDir#configMapName
   */
  readonly configMapName?: string;

  /**
   * items mapping between configMap data key and file path mount.
   *
   * @schema DatadogAgentSpecAgentSecurityRuntimePoliciesDir#items
   */
  readonly items?: DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityRuntimePoliciesDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityRuntimePoliciesDir(obj: DatadogAgentSpecAgentSecurityRuntimePoliciesDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapName': obj.configMapName,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Syscall monitor configuration.
 *
 * @schema DatadogAgentSpecAgentSecurityRuntimeSyscallMonitor
 */
export interface DatadogAgentSpecAgentSecurityRuntimeSyscallMonitor {
  /**
   * Enabled enables syscall monitor
   *
   * @schema DatadogAgentSpecAgentSecurityRuntimeSyscallMonitor#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityRuntimeSyscallMonitor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityRuntimeSyscallMonitor(obj: DatadogAgentSpecAgentSecurityRuntimeSyscallMonitor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enable to specify a reference to an already existing ConfigMap.
 *
 * @schema DatadogAgentSpecAgentSystemProbeCustomConfigConfigMap
 */
export interface DatadogAgentSpecAgentSystemProbeCustomConfigConfigMap {
  /**
   * FileKey corresponds to the key used in the ConfigMap.Data to store the configuration file content.
   *
   * @schema DatadogAgentSpecAgentSystemProbeCustomConfigConfigMap#fileKey
   */
  readonly fileKey?: string;

  /**
   * The name of source ConfigMap.
   *
   * @schema DatadogAgentSpecAgentSystemProbeCustomConfigConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeCustomConfigConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeCustomConfigConfigMap(obj: DatadogAgentSpecAgentSystemProbeCustomConfigConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileKey': obj.fileKey,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentSpecAgentSystemProbeEnvValueFrom
 */
export interface DatadogAgentSpecAgentSystemProbeEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecAgentSystemProbeEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeEnvValueFrom(obj: DatadogAgentSpecAgentSystemProbeEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentSpecAgentSystemProbeEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecAgentSystemProbeResourcesLimits
 */
export class DatadogAgentSpecAgentSystemProbeResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecAgentSystemProbeResourcesLimits {
    return new DatadogAgentSpecAgentSystemProbeResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentSystemProbeResourcesLimits {
    return new DatadogAgentSpecAgentSystemProbeResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecAgentSystemProbeResourcesRequests
 */
export class DatadogAgentSpecAgentSystemProbeResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecAgentSystemProbeResourcesRequests {
    return new DatadogAgentSpecAgentSystemProbeResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentSystemProbeResourcesRequests {
    return new DatadogAgentSpecAgentSystemProbeResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema DatadogAgentSpecAgentSystemProbeSecurityContextCapabilities
 */
export interface DatadogAgentSpecAgentSystemProbeSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeSecurityContextCapabilities(obj: DatadogAgentSpecAgentSystemProbeSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions
 */
export interface DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions(obj: DatadogAgentSpecAgentSystemProbeSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentSpecAgentSystemProbeSecurityContextSeccompProfile
 */
export interface DatadogAgentSpecAgentSystemProbeSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeSecurityContextSeccompProfile(obj: DatadogAgentSpecAgentSystemProbeSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions
 */
export interface DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions(obj: DatadogAgentSpecAgentSystemProbeSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecClusterAgentConfigConfdItems
 */
export interface DatadogAgentSpecClusterAgentConfigConfdItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecClusterAgentConfigConfdItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterAgentConfigConfdItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigConfdItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigConfdItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigConfdItems(obj: DatadogAgentSpecClusterAgentConfigConfdItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentSpecClusterAgentConfigEnvValueFrom
 */
export interface DatadogAgentSpecClusterAgentConfigEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecClusterAgentConfigEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigEnvValueFrom(obj: DatadogAgentSpecClusterAgentConfigEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentSpecClusterAgentConfigEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Datadog credentials used by external metrics server to query Datadog. If not set, the external metrics server uses the global .spec.Credentials
 *
 * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials
 */
export interface DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials {
  /**
   * APIKey Set this to your Datadog API key before the Agent runs. See also: https://app.datadoghq.com/account/settings#agent/kubernetes
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials#apiKey
   */
  readonly apiKey?: string;

  /**
   * APIKeyExistingSecret is DEPRECATED. In order to pass the API key through an existing secret, please consider "apiSecret" instead. If set, this parameter takes precedence over "apiKey".
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials#apiKeyExistingSecret
   */
  readonly apiKeyExistingSecret?: string;

  /**
   * APISecret Use existing Secret which stores API key instead of creating a new one. If set, this parameter takes precedence over "apiKey" and "apiKeyExistingSecret".
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials#apiSecret
   */
  readonly apiSecret?: DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsApiSecret;

  /**
   * If you are using clusterAgent.metricsProvider.enabled = true, you must set a Datadog application key for read access to your metrics.
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials#appKey
   */
  readonly appKey?: string;

  /**
   * AppKeyExistingSecret is DEPRECATED. In order to pass the APP key through an existing secret, please consider "appSecret" instead. If set, this parameter takes precedence over "appKey".
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials#appKeyExistingSecret
   */
  readonly appKeyExistingSecret?: string;

  /**
   * APPSecret Use existing Secret which stores API key instead of creating a new one. If set, this parameter takes precedence over "apiKey" and "appKeyExistingSecret".
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials#appSecret
   */
  readonly appSecret?: DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsAppSecret;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials(obj: DatadogAgentSpecClusterAgentConfigExternalMetricsCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiKeyExistingSecret': obj.apiKeyExistingSecret,
    'apiSecret': toJson_DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsApiSecret(obj.apiSecret),
    'appKey': obj.appKey,
    'appKeyExistingSecret': obj.appKeyExistingSecret,
    'appSecret': toJson_DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsAppSecret(obj.appSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecClusterAgentConfigResourcesLimits
 */
export class DatadogAgentSpecClusterAgentConfigResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecClusterAgentConfigResourcesLimits {
    return new DatadogAgentSpecClusterAgentConfigResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterAgentConfigResourcesLimits {
    return new DatadogAgentSpecClusterAgentConfigResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecClusterAgentConfigResourcesRequests
 */
export class DatadogAgentSpecClusterAgentConfigResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecClusterAgentConfigResourcesRequests {
    return new DatadogAgentSpecClusterAgentConfigResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterAgentConfigResourcesRequests {
    return new DatadogAgentSpecClusterAgentConfigResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions
 */
export interface DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions(obj: DatadogAgentSpecClusterAgentConfigSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSeccompProfile
 */
export interface DatadogAgentSpecClusterAgentConfigSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigSecurityContextSeccompProfile(obj: DatadogAgentSpecClusterAgentConfigSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSysctls
 */
export interface DatadogAgentSpecClusterAgentConfigSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigSecurityContextSysctls(obj: DatadogAgentSpecClusterAgentConfigSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions
 */
export interface DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions(obj: DatadogAgentSpecClusterAgentConfigSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore(obj: DatadogAgentSpecClusterAgentConfigVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureDisk
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesAzureDisk(obj: DatadogAgentSpecClusterAgentConfigVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureFile
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesAzureFile(obj: DatadogAgentSpecClusterAgentConfigVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesCephfs
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCephfs#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterAgentConfigVolumesCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesCephfs(obj: DatadogAgentSpecClusterAgentConfigVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesCinder
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCinder#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterAgentConfigVolumesCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesCinder(obj: DatadogAgentSpecClusterAgentConfigVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap represents a configMap that should populate this volume
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesConfigMap
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesConfigMap {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesConfigMap#items
   */
  readonly items?: DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesConfigMap(obj: DatadogAgentSpecClusterAgentConfigVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesCsi
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: DatadogAgentSpecClusterAgentConfigVolumesCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesCsi(obj: DatadogAgentSpecClusterAgentConfigVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApi
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApi#items
   */
  readonly items?: DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesDownwardApi(obj: DatadogAgentSpecClusterAgentConfigVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEmptyDir
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: DatadogAgentSpecClusterAgentConfigVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesEmptyDir(obj: DatadogAgentSpecClusterAgentConfigVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeral
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeral(obj: DatadogAgentSpecClusterAgentConfigVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesFc
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesFc(obj: DatadogAgentSpecClusterAgentConfigVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesFlexVolume
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFlexVolume#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterAgentConfigVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesFlexVolume(obj: DatadogAgentSpecClusterAgentConfigVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesFlocker
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesFlocker(obj: DatadogAgentSpecClusterAgentConfigVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk(obj: DatadogAgentSpecClusterAgentConfigVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesGitRepo
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesGitRepo(obj: DatadogAgentSpecClusterAgentConfigVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesGlusterfs
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema DatadogAgentSpecClusterAgentConfigVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesGlusterfs(obj: DatadogAgentSpecClusterAgentConfigVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesHostPath
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema DatadogAgentSpecClusterAgentConfigVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesHostPath(obj: DatadogAgentSpecClusterAgentConfigVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterAgentConfigVolumesIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesIscsi(obj: DatadogAgentSpecClusterAgentConfigVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesNfs
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema DatadogAgentSpecClusterAgentConfigVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesNfs(obj: DatadogAgentSpecClusterAgentConfigVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesPersistentVolumeClaim
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesPersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesPersistentVolumeClaim(obj: DatadogAgentSpecClusterAgentConfigVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesPhotonPersistentDisk
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesPhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesPhotonPersistentDisk(obj: DatadogAgentSpecClusterAgentConfigVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume(obj: DatadogAgentSpecClusterAgentConfigVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Items for all in one resources secrets, configmaps, and downward API
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjected
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjected {
  /**
   * Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjected#sources
   */
  readonly sources?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSources[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjected(obj: DatadogAgentSpecClusterAgentConfigVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesQuobyte
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema DatadogAgentSpecClusterAgentConfigVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema DatadogAgentSpecClusterAgentConfigVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesQuobyte(obj: DatadogAgentSpecClusterAgentConfigVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesRbd
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterAgentConfigVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterAgentConfigVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterAgentConfigVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterAgentConfigVolumesRbd#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterAgentConfigVolumesRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterAgentConfigVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesRbd(obj: DatadogAgentSpecClusterAgentConfigVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#secretRef
   */
  readonly secretRef: DatadogAgentSpecClusterAgentConfigVolumesScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesScaleIo(obj: DatadogAgentSpecClusterAgentConfigVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesSecret
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesSecret {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesSecret#items
   */
  readonly items?: DatadogAgentSpecClusterAgentConfigVolumesSecretItems[];

  /**
   * Specify whether the Secret or its keys must be defined
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesSecret(obj: DatadogAgentSpecClusterAgentConfigVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesStorageos
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesStorageos#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterAgentConfigVolumesStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesStorageos(obj: DatadogAgentSpecClusterAgentConfigVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume(obj: DatadogAgentSpecClusterAgentConfigVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions(obj: DatadogAgentSpecClusterAgentNetworkPolicyDnsSelectorEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom(obj: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeExec
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeExec(obj: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeGrpc
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeGrpc(obj: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet#port
   */
  readonly port: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet(obj: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocket
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocket#port
   */
  readonly port: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocket(obj: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeExec
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeExec(obj: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeGrpc
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeGrpc(obj: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet#port
   */
  readonly port: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet(obj: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocket
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocket#port
   */
  readonly port: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocket(obj: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecClusterChecksRunnerConfigResourcesLimits
 */
export class DatadogAgentSpecClusterChecksRunnerConfigResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigResourcesLimits {
    return new DatadogAgentSpecClusterChecksRunnerConfigResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigResourcesLimits {
    return new DatadogAgentSpecClusterChecksRunnerConfigResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecClusterChecksRunnerConfigResourcesRequests
 */
export class DatadogAgentSpecClusterChecksRunnerConfigResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigResourcesRequests {
    return new DatadogAgentSpecClusterChecksRunnerConfigResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigResourcesRequests {
    return new DatadogAgentSpecClusterChecksRunnerConfigResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions(obj: DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeccompProfile
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeccompProfile(obj: DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSysctls
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSysctls(obj: DatadogAgentSpecClusterChecksRunnerConfigSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions(obj: DatadogAgentSpecClusterChecksRunnerConfigSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap represents a configMap that should populate this volume
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap#items
   */
  readonly items?: DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApi
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApi#items
   */
  readonly items?: DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApi(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDir
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDir(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeral
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeral(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFc
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesFc(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlocker
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesFlocker(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesHostPath
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesHostPath(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPersistentVolumeClaim
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesPersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesPersistentVolumeClaim(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPhotonPersistentDisk
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesPhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesPhotonPersistentDisk(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Items for all in one resources secrets, configmaps, and downward API
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjected
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjected {
  /**
   * Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjected#sources
   */
  readonly sources?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjected(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#secretRef
   */
  readonly secretRef: DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret#items
   */
  readonly items?: DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems[];

  /**
   * Specify whether the Secret or its keys must be defined
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos#secretRef
   */
  readonly secretRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerNetworkPolicyDnsSelectorEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enable to specify a reference to an already existing ConfigMap.
 *
 * @schema DatadogAgentSpecFeaturesKubeStateMetricsCoreConfConfigMap
 */
export interface DatadogAgentSpecFeaturesKubeStateMetricsCoreConfConfigMap {
  /**
   * FileKey corresponds to the key used in the ConfigMap.Data to store the configuration file content.
   *
   * @schema DatadogAgentSpecFeaturesKubeStateMetricsCoreConfConfigMap#fileKey
   */
  readonly fileKey?: string;

  /**
   * The name of source ConfigMap.
   *
   * @schema DatadogAgentSpecFeaturesKubeStateMetricsCoreConfConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesKubeStateMetricsCoreConfConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesKubeStateMetricsCoreConfConfigMap(obj: DatadogAgentSpecFeaturesKubeStateMetricsCoreConfConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileKey': obj.fileKey,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Enable to specify a reference to an already existing ConfigMap.
 *
 * @schema DatadogAgentSpecFeaturesOrchestratorExplorerConfConfigMap
 */
export interface DatadogAgentSpecFeaturesOrchestratorExplorerConfConfigMap {
  /**
   * FileKey corresponds to the key used in the ConfigMap.Data to store the configuration file content.
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorerConfConfigMap#fileKey
   */
  readonly fileKey?: string;

  /**
   * The name of source ConfigMap.
   *
   * @schema DatadogAgentSpecFeaturesOrchestratorExplorerConfConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecFeaturesOrchestratorExplorerConfConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecFeaturesOrchestratorExplorerConfConfigMap(obj: DatadogAgentSpecFeaturesOrchestratorExplorerConfConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileKey': obj.fileKey,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef(obj: DatadogAgentSpecAgentApmEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentSpecAgentApmEnvValueFromFieldRef
 */
export interface DatadogAgentSpecAgentApmEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmEnvValueFromFieldRef(obj: DatadogAgentSpecAgentApmEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef
 */
export interface DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecAgentApmEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef(obj: DatadogAgentSpecAgentApmEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef
 */
export interface DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef(obj: DatadogAgentSpecAgentApmEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGetHttpHeaders
 */
export interface DatadogAgentSpecAgentApmLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentApmLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentApmLivenessProbeHttpGetHttpHeaders(obj: DatadogAgentSpecAgentApmLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecAgentApmLivenessProbeHttpGetPort
 */
export class DatadogAgentSpecAgentApmLivenessProbeHttpGetPort {
  public static fromNumber(value: number): DatadogAgentSpecAgentApmLivenessProbeHttpGetPort {
    return new DatadogAgentSpecAgentApmLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentApmLivenessProbeHttpGetPort {
    return new DatadogAgentSpecAgentApmLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecAgentApmLivenessProbeTcpSocketPort
 */
export class DatadogAgentSpecAgentApmLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): DatadogAgentSpecAgentApmLivenessProbeTcpSocketPort {
    return new DatadogAgentSpecAgentApmLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentApmLivenessProbeTcpSocketPort {
    return new DatadogAgentSpecAgentApmLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Enable to specify a reference to an already existing ConfigMap.
 *
 * @schema DatadogAgentSpecAgentConfigDogstatsdMapperProfilesConfigMap
 */
export interface DatadogAgentSpecAgentConfigDogstatsdMapperProfilesConfigMap {
  /**
   * FileKey corresponds to the key used in the ConfigMap.Data to store the configuration file content.
   *
   * @schema DatadogAgentSpecAgentConfigDogstatsdMapperProfilesConfigMap#fileKey
   */
  readonly fileKey?: string;

  /**
   * The name of source ConfigMap.
   *
   * @schema DatadogAgentSpecAgentConfigDogstatsdMapperProfilesConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigDogstatsdMapperProfilesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigDogstatsdMapperProfilesConfigMap(obj: DatadogAgentSpecAgentConfigDogstatsdMapperProfilesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fileKey': obj.fileKey,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef(obj: DatadogAgentSpecAgentConfigEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentSpecAgentConfigEnvValueFromFieldRef
 */
export interface DatadogAgentSpecAgentConfigEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigEnvValueFromFieldRef(obj: DatadogAgentSpecAgentConfigEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef
 */
export interface DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef(obj: DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef
 */
export interface DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef(obj: DatadogAgentSpecAgentConfigEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef
 */
export interface DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef(obj: DatadogAgentSpecAgentConfigKubeletHostConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentSpecAgentConfigKubeletHostFieldRef
 */
export interface DatadogAgentSpecAgentConfigKubeletHostFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigKubeletHostFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigKubeletHostFieldRef(obj: DatadogAgentSpecAgentConfigKubeletHostFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef
 */
export interface DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecAgentConfigKubeletHostResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef(obj: DatadogAgentSpecAgentConfigKubeletHostResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef
 */
export interface DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef(obj: DatadogAgentSpecAgentConfigKubeletHostSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGetHttpHeaders
 */
export interface DatadogAgentSpecAgentConfigLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigLivenessProbeHttpGetHttpHeaders(obj: DatadogAgentSpecAgentConfigLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecAgentConfigLivenessProbeHttpGetPort
 */
export class DatadogAgentSpecAgentConfigLivenessProbeHttpGetPort {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigLivenessProbeHttpGetPort {
    return new DatadogAgentSpecAgentConfigLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigLivenessProbeHttpGetPort {
    return new DatadogAgentSpecAgentConfigLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecAgentConfigLivenessProbeTcpSocketPort
 */
export class DatadogAgentSpecAgentConfigLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigLivenessProbeTcpSocketPort {
    return new DatadogAgentSpecAgentConfigLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigLivenessProbeTcpSocketPort {
    return new DatadogAgentSpecAgentConfigLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGetHttpHeaders
 */
export interface DatadogAgentSpecAgentConfigReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigReadinessProbeHttpGetHttpHeaders(obj: DatadogAgentSpecAgentConfigReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecAgentConfigReadinessProbeHttpGetPort
 */
export class DatadogAgentSpecAgentConfigReadinessProbeHttpGetPort {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigReadinessProbeHttpGetPort {
    return new DatadogAgentSpecAgentConfigReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigReadinessProbeHttpGetPort {
    return new DatadogAgentSpecAgentConfigReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecAgentConfigReadinessProbeTcpSocketPort
 */
export class DatadogAgentSpecAgentConfigReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigReadinessProbeTcpSocketPort {
    return new DatadogAgentSpecAgentConfigReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigReadinessProbeTcpSocketPort {
    return new DatadogAgentSpecAgentConfigReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema DatadogAgentSpecAgentConfigVolumesCephfsSecretRef
 */
export interface DatadogAgentSpecAgentConfigVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesCephfsSecretRef(obj: DatadogAgentSpecAgentConfigVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesCinderSecretRef
 */
export interface DatadogAgentSpecAgentConfigVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesCinderSecretRef(obj: DatadogAgentSpecAgentConfigVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesConfigMapItems
 */
export interface DatadogAgentSpecAgentConfigVolumesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesConfigMapItems(obj: DatadogAgentSpecAgentConfigVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesCsiNodePublishSecretRef
 */
export interface DatadogAgentSpecAgentConfigVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesCsiNodePublishSecretRef(obj: DatadogAgentSpecAgentConfigVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItems
 */
export interface DatadogAgentSpecAgentConfigVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecAgentConfigVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesDownwardApiItems(obj: DatadogAgentSpecAgentConfigVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_DatadogAgentSpecAgentConfigVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEmptyDirSizeLimit
 */
export class DatadogAgentSpecAgentConfigVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigVolumesEmptyDirSizeLimit {
    return new DatadogAgentSpecAgentConfigVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigVolumesEmptyDirSizeLimit {
    return new DatadogAgentSpecAgentConfigVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplate
 */
export interface DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplate(obj: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesFlexVolumeSecretRef
 */
export interface DatadogAgentSpecAgentConfigVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesFlexVolumeSecretRef(obj: DatadogAgentSpecAgentConfigVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema DatadogAgentSpecAgentConfigVolumesIscsiSecretRef
 */
export interface DatadogAgentSpecAgentConfigVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesIscsiSecretRef(obj: DatadogAgentSpecAgentConfigVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSources
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSources {
  /**
   * information about the configMap data to project
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSources#configMap
   */
  readonly configMap?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap;

  /**
   * information about the downwardAPI data to project
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApi;

  /**
   * information about the secret data to project
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSources#secret
   */
  readonly secret?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret;

  /**
   * information about the serviceAccountToken data to project
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSources(obj: DatadogAgentSpecAgentConfigVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema DatadogAgentSpecAgentConfigVolumesRbdSecretRef
 */
export interface DatadogAgentSpecAgentConfigVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesRbdSecretRef(obj: DatadogAgentSpecAgentConfigVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesScaleIoSecretRef
 */
export interface DatadogAgentSpecAgentConfigVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesScaleIoSecretRef(obj: DatadogAgentSpecAgentConfigVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesSecretItems
 */
export interface DatadogAgentSpecAgentConfigVolumesSecretItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesSecretItems(obj: DatadogAgentSpecAgentConfigVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesStorageosSecretRef
 */
export interface DatadogAgentSpecAgentConfigVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesStorageosSecretRef(obj: DatadogAgentSpecAgentConfigVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions(obj: DatadogAgentSpecAgentDeploymentStrategyCanaryNodeSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecAgentEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentSpecAgentEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecAgentEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * GRPC contains configuration for the OTLP ingest OTLP/gRPC receiver.
 *
 * @schema DatadogAgentSpecAgentOtlpReceiverProtocolsGrpc
 */
export interface DatadogAgentSpecAgentOtlpReceiverProtocolsGrpc {
  /**
   * Enable the OTLP/gRPC endpoint.
   *
   * @schema DatadogAgentSpecAgentOtlpReceiverProtocolsGrpc#enabled
   */
  readonly enabled?: boolean;

  /**
   * Endpoint for OTLP/gRPC. gRPC supports several naming schemes: https://github.com/grpc/grpc/blob/master/doc/naming.md The Datadog Operator supports only 'host:port' (usually '0.0.0.0:port'). Default: '0.0.0.0:4317'.
   *
   * @schema DatadogAgentSpecAgentOtlpReceiverProtocolsGrpc#endpoint
   */
  readonly endpoint?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentOtlpReceiverProtocolsGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentOtlpReceiverProtocolsGrpc(obj: DatadogAgentSpecAgentOtlpReceiverProtocolsGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP contains configuration for the OTLP ingest OTLP/HTTP receiver.
 *
 * @schema DatadogAgentSpecAgentOtlpReceiverProtocolsHttp
 */
export interface DatadogAgentSpecAgentOtlpReceiverProtocolsHttp {
  /**
   * Enable the OTLP/HTTP endpoint.
   *
   * @schema DatadogAgentSpecAgentOtlpReceiverProtocolsHttp#enabled
   */
  readonly enabled?: boolean;

  /**
   * Endpoint for OTLP/HTTP. Default: '0.0.0.0:4318'.
   *
   * @schema DatadogAgentSpecAgentOtlpReceiverProtocolsHttp#endpoint
   */
  readonly endpoint?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentOtlpReceiverProtocolsHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentOtlpReceiverProtocolsHttp(obj: DatadogAgentSpecAgentOtlpReceiverProtocolsHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef(obj: DatadogAgentSpecAgentProcessEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentSpecAgentProcessEnvValueFromFieldRef
 */
export interface DatadogAgentSpecAgentProcessEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentProcessEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentProcessEnvValueFromFieldRef(obj: DatadogAgentSpecAgentProcessEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef
 */
export interface DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef(obj: DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef
 */
export interface DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef(obj: DatadogAgentSpecAgentProcessEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecAgentSecurityComplianceConfigDirItems
 */
export interface DatadogAgentSpecAgentSecurityComplianceConfigDirItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecAgentSecurityComplianceConfigDirItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentSecurityComplianceConfigDirItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecAgentSecurityComplianceConfigDirItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityComplianceConfigDirItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityComplianceConfigDirItems(obj: DatadogAgentSpecAgentSecurityComplianceConfigDirItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef(obj: DatadogAgentSpecAgentSecurityEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentSpecAgentSecurityEnvValueFromFieldRef
 */
export interface DatadogAgentSpecAgentSecurityEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityEnvValueFromFieldRef(obj: DatadogAgentSpecAgentSecurityEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef
 */
export interface DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef(obj: DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef
 */
export interface DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef(obj: DatadogAgentSpecAgentSecurityEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems
 */
export interface DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems(obj: DatadogAgentSpecAgentSecurityRuntimePoliciesDirItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef(obj: DatadogAgentSpecAgentSystemProbeEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromFieldRef
 */
export interface DatadogAgentSpecAgentSystemProbeEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeEnvValueFromFieldRef(obj: DatadogAgentSpecAgentSystemProbeEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef
 */
export interface DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef(obj: DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef
 */
export interface DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef(obj: DatadogAgentSpecAgentSystemProbeEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef(obj: DatadogAgentSpecClusterAgentConfigEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromFieldRef
 */
export interface DatadogAgentSpecClusterAgentConfigEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigEnvValueFromFieldRef(obj: DatadogAgentSpecClusterAgentConfigEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef
 */
export interface DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef(obj: DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef
 */
export interface DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef(obj: DatadogAgentSpecClusterAgentConfigEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APISecret Use existing Secret which stores API key instead of creating a new one. If set, this parameter takes precedence over "apiKey" and "apiKeyExistingSecret".
 *
 * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsApiSecret
 */
export interface DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsApiSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsApiSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsApiSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsApiSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsApiSecret(obj: DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsApiSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APPSecret Use existing Secret which stores API key instead of creating a new one. If set, this parameter takes precedence over "apiKey" and "appKeyExistingSecret".
 *
 * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsAppSecret
 */
export interface DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsAppSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsAppSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsAppSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsAppSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsAppSecret(obj: DatadogAgentSpecClusterAgentConfigExternalMetricsCredentialsAppSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesCephfsSecretRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesCephfsSecretRef(obj: DatadogAgentSpecClusterAgentConfigVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesCinderSecretRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesCinderSecretRef(obj: DatadogAgentSpecClusterAgentConfigVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems(obj: DatadogAgentSpecClusterAgentConfigVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesCsiNodePublishSecretRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesCsiNodePublishSecretRef(obj: DatadogAgentSpecClusterAgentConfigVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems(obj: DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEmptyDirSizeLimit
 */
export class DatadogAgentSpecClusterAgentConfigVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): DatadogAgentSpecClusterAgentConfigVolumesEmptyDirSizeLimit {
    return new DatadogAgentSpecClusterAgentConfigVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterAgentConfigVolumesEmptyDirSizeLimit {
    return new DatadogAgentSpecClusterAgentConfigVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplate
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplate(obj: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesFlexVolumeSecretRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesFlexVolumeSecretRef(obj: DatadogAgentSpecClusterAgentConfigVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsiSecretRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesIscsiSecretRef(obj: DatadogAgentSpecClusterAgentConfigVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSources
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSources {
  /**
   * information about the configMap data to project
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSources#configMap
   */
  readonly configMap?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap;

  /**
   * information about the downwardAPI data to project
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApi;

  /**
   * information about the secret data to project
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSources#secret
   */
  readonly secret?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret;

  /**
   * information about the serviceAccountToken data to project
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSources(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema DatadogAgentSpecClusterAgentConfigVolumesRbdSecretRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesRbdSecretRef(obj: DatadogAgentSpecClusterAgentConfigVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIoSecretRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesScaleIoSecretRef(obj: DatadogAgentSpecClusterAgentConfigVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesSecretItems
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesSecretItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesSecretItems(obj: DatadogAgentSpecClusterAgentConfigVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesStorageosSecretRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesStorageosSecretRef(obj: DatadogAgentSpecClusterAgentConfigVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef(obj: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromFieldRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromFieldRef(obj: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef(obj: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef(obj: DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetHttpHeaders
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetHttpHeaders(obj: DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetPort
 */
export class DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetPort {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetPort {
    return new DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetPort {
    return new DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocketPort
 */
export class DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocketPort {
    return new DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocketPort {
    return new DatadogAgentSpecClusterChecksRunnerConfigLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetHttpHeaders
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetHttpHeaders(obj: DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetPort
 */
export class DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetPort {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetPort {
    return new DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetPort {
    return new DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocketPort
 */
export class DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocketPort {
    return new DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocketPort {
    return new DatadogAgentSpecClusterChecksRunnerConfigReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfsSecretRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfsSecretRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCinderSecretRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCinderSecretRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCsiNodePublishSecretRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesCsiNodePublishSecretRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDirSizeLimit
 */
export class DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDirSizeLimit {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDirSizeLimit {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplate
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplate(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolumeSecretRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolumeSecretRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsiSecretRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsiSecretRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources {
  /**
   * information about the configMap data to project
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources#configMap
   */
  readonly configMap?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap;

  /**
   * information about the downwardAPI data to project
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApi;

  /**
   * information about the secret data to project
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources#secret
   */
  readonly secret?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret;

  /**
   * information about the serviceAccountToken data to project
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbdSecretRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesRbdSecretRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIoSecretRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIoSecretRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageosSecretRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageosSecretRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: DatadogAgentSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: DatadogAgentSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecAgentApmEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentSpecAgentApmEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecAgentApmEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentApmEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentApmEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentApmEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentConfigEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecAgentConfigKubeletHostResourceFieldRefDivisor
 */
export class DatadogAgentSpecAgentConfigKubeletHostResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigKubeletHostResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentConfigKubeletHostResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigKubeletHostResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentConfigKubeletHostResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItemsFieldRef
 */
export interface DatadogAgentSpecAgentConfigVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesDownwardApiItemsFieldRef(obj: DatadogAgentSpecAgentConfigVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef
 */
export interface DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef(obj: DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * A label query over volumes to consider for binding.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec(obj: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the configMap data to project
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap(obj: DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the downwardAPI data to project
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApi
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApi(obj: DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the secret data to project
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret#items
   */
  readonly items?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret(obj: DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the serviceAccountToken data to project
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken(obj: DatadogAgentSpecAgentConfigVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentProcessEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentSecurityEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentSystemProbeEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: DatadogAgentSpecClusterAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: DatadogAgentSpecClusterAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterAgentConfigEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsFieldRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsFieldRef(obj: DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef(obj: DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * A label query over volumes to consider for binding.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec(obj: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the configMap data to project
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the downwardAPI data to project
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApi
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApi(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the secret data to project
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret#items
   */
  readonly items?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the serviceAccountToken data to project
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: DatadogAgentSpecClusterChecksRunnerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterChecksRunnerConfigEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsFieldRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsFieldRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * A label query over volumes to consider for binding.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the configMap data to project
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the downwardAPI data to project
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApi
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApi(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the secret data to project
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret#items
   */
  readonly items?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the serviceAccountToken data to project
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources(obj: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over volumes to consider for binding.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems(obj: DatadogAgentSpecAgentConfigVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems(obj: DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems(obj: DatadogAgentSpecAgentConfigVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecClusterAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterAgentConfigVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources(obj: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over volumes to consider for binding.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResources(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over volumes to consider for binding.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: DatadogAgentSpecAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: DatadogAgentSpecClusterAgentConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterAgentConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentSpecClusterChecksRunnerConfigVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * DatadogAgent Deployment with the Datadog Operator.
 *
 * @schema DatadogAgentV2Alpha1
 */
export class DatadogAgentV2Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatadogAgentV2Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datadoghq.com/v2alpha1',
    kind: 'DatadogAgent',
  }

  /**
   * Renders a Kubernetes manifest for "DatadogAgentV2Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatadogAgentV2Alpha1Props = {}): any {
    return {
      ...DatadogAgentV2Alpha1.GVK,
      ...toJson_DatadogAgentV2Alpha1Props(props),
    };
  }

  /**
   * Defines a "DatadogAgentV2Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatadogAgentV2Alpha1Props = {}) {
    super(scope, id, {
      ...DatadogAgentV2Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatadogAgentV2Alpha1.GVK,
      ...toJson_DatadogAgentV2Alpha1Props(resolved),
    };
  }
}

/**
 * DatadogAgent Deployment with the Datadog Operator.
 *
 * @schema DatadogAgentV2Alpha1
 */
export interface DatadogAgentV2Alpha1Props {
  /**
   * @schema DatadogAgentV2Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatadogAgentSpec defines the desired state of DatadogAgent
   *
   * @schema DatadogAgentV2Alpha1#spec
   */
  readonly spec?: DatadogAgentV2Alpha1Spec;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1Props(obj: DatadogAgentV2Alpha1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatadogAgentV2Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatadogAgentSpec defines the desired state of DatadogAgent
 *
 * @schema DatadogAgentV2Alpha1Spec
 */
export interface DatadogAgentV2Alpha1Spec {
  /**
   * Features running on the Agent and Cluster Agent
   *
   * @schema DatadogAgentV2Alpha1Spec#features
   */
  readonly features?: DatadogAgentV2Alpha1SpecFeatures;

  /**
   * Global settings to configure the agents
   *
   * @schema DatadogAgentV2Alpha1Spec#global
   */
  readonly global?: DatadogAgentV2Alpha1SpecGlobal;

  /**
   * Override the default configurations of the agents
   *
   * @schema DatadogAgentV2Alpha1Spec#override
   */
  readonly override?: { [key: string]: DatadogAgentV2Alpha1SpecOverride };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1Spec(obj: DatadogAgentV2Alpha1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'features': toJson_DatadogAgentV2Alpha1SpecFeatures(obj.features),
    'global': toJson_DatadogAgentV2Alpha1SpecGlobal(obj.global),
    'override': ((obj.override) === undefined) ? undefined : (Object.entries(obj.override).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_DatadogAgentV2Alpha1SpecOverride(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Features running on the Agent and Cluster Agent
 *
 * @schema DatadogAgentV2Alpha1SpecFeatures
 */
export interface DatadogAgentV2Alpha1SpecFeatures {
  /**
   * AdmissionController configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#admissionController
   */
  readonly admissionController?: DatadogAgentV2Alpha1SpecFeaturesAdmissionController;

  /**
   * APM (Application Performance Monitoring) configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#apm
   */
  readonly apm?: DatadogAgentV2Alpha1SpecFeaturesApm;

  /**
   * ClusterChecks configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#clusterChecks
   */
  readonly clusterChecks?: DatadogAgentV2Alpha1SpecFeaturesClusterChecks;

  /**
   * CSPM (Cloud Security Posture Management) configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#cspm
   */
  readonly cspm?: DatadogAgentV2Alpha1SpecFeaturesCspm;

  /**
   * CWS (Cloud Workload Security) configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#cws
   */
  readonly cws?: DatadogAgentV2Alpha1SpecFeaturesCws;

  /**
   * Dogstatsd configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#dogstatsd
   */
  readonly dogstatsd?: DatadogAgentV2Alpha1SpecFeaturesDogstatsd;

  /**
   * EBPFCheck configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#ebpfCheck
   */
  readonly ebpfCheck?: DatadogAgentV2Alpha1SpecFeaturesEbpfCheck;

  /**
   * EventCollection configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#eventCollection
   */
  readonly eventCollection?: DatadogAgentV2Alpha1SpecFeaturesEventCollection;

  /**
   * ExternalMetricsServer configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#externalMetricsServer
   */
  readonly externalMetricsServer?: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer;

  /**
   * KubeStateMetricsCore check configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#kubeStateMetricsCore
   */
  readonly kubeStateMetricsCore?: DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCore;

  /**
   * LiveContainerCollection configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#liveContainerCollection
   */
  readonly liveContainerCollection?: DatadogAgentV2Alpha1SpecFeaturesLiveContainerCollection;

  /**
   * LiveProcessCollection configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#liveProcessCollection
   */
  readonly liveProcessCollection?: DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection;

  /**
   * LogCollection configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#logCollection
   */
  readonly logCollection?: DatadogAgentV2Alpha1SpecFeaturesLogCollection;

  /**
   * NPM (Network Performance Monitoring) configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#npm
   */
  readonly npm?: DatadogAgentV2Alpha1SpecFeaturesNpm;

  /**
   * OOMKill configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#oomKill
   */
  readonly oomKill?: DatadogAgentV2Alpha1SpecFeaturesOomKill;

  /**
   * OrchestratorExplorer check configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#orchestratorExplorer
   */
  readonly orchestratorExplorer?: DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer;

  /**
   * OTLP ingest configuration
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#otlp
   */
  readonly otlp?: DatadogAgentV2Alpha1SpecFeaturesOtlp;

  /**
   * PrometheusScrape configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#prometheusScrape
   */
  readonly prometheusScrape?: DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape;

  /**
   * Remote Configuration configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#remoteConfiguration
   */
  readonly remoteConfiguration?: DatadogAgentV2Alpha1SpecFeaturesRemoteConfiguration;

  /**
   * TCPQueueLength configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#tcpQueueLength
   */
  readonly tcpQueueLength?: DatadogAgentV2Alpha1SpecFeaturesTcpQueueLength;

  /**
   * USM (Universal Service Monitoring) configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeatures#usm
   */
  readonly usm?: DatadogAgentV2Alpha1SpecFeaturesUsm;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeatures' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeatures(obj: DatadogAgentV2Alpha1SpecFeatures | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admissionController': toJson_DatadogAgentV2Alpha1SpecFeaturesAdmissionController(obj.admissionController),
    'apm': toJson_DatadogAgentV2Alpha1SpecFeaturesApm(obj.apm),
    'clusterChecks': toJson_DatadogAgentV2Alpha1SpecFeaturesClusterChecks(obj.clusterChecks),
    'cspm': toJson_DatadogAgentV2Alpha1SpecFeaturesCspm(obj.cspm),
    'cws': toJson_DatadogAgentV2Alpha1SpecFeaturesCws(obj.cws),
    'dogstatsd': toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsd(obj.dogstatsd),
    'ebpfCheck': toJson_DatadogAgentV2Alpha1SpecFeaturesEbpfCheck(obj.ebpfCheck),
    'eventCollection': toJson_DatadogAgentV2Alpha1SpecFeaturesEventCollection(obj.eventCollection),
    'externalMetricsServer': toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer(obj.externalMetricsServer),
    'kubeStateMetricsCore': toJson_DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCore(obj.kubeStateMetricsCore),
    'liveContainerCollection': toJson_DatadogAgentV2Alpha1SpecFeaturesLiveContainerCollection(obj.liveContainerCollection),
    'liveProcessCollection': toJson_DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection(obj.liveProcessCollection),
    'logCollection': toJson_DatadogAgentV2Alpha1SpecFeaturesLogCollection(obj.logCollection),
    'npm': toJson_DatadogAgentV2Alpha1SpecFeaturesNpm(obj.npm),
    'oomKill': toJson_DatadogAgentV2Alpha1SpecFeaturesOomKill(obj.oomKill),
    'orchestratorExplorer': toJson_DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer(obj.orchestratorExplorer),
    'otlp': toJson_DatadogAgentV2Alpha1SpecFeaturesOtlp(obj.otlp),
    'prometheusScrape': toJson_DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape(obj.prometheusScrape),
    'remoteConfiguration': toJson_DatadogAgentV2Alpha1SpecFeaturesRemoteConfiguration(obj.remoteConfiguration),
    'tcpQueueLength': toJson_DatadogAgentV2Alpha1SpecFeaturesTcpQueueLength(obj.tcpQueueLength),
    'usm': toJson_DatadogAgentV2Alpha1SpecFeaturesUsm(obj.usm),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Global settings to configure the agents
 *
 * @schema DatadogAgentV2Alpha1SpecGlobal
 */
export interface DatadogAgentV2Alpha1SpecGlobal {
  /**
   * ClusterAgentToken is the token for communication between the NodeAgent and ClusterAgent.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#clusterAgentToken
   */
  readonly clusterAgentToken?: string;

  /**
   * ClusterAgentTokenSecret is the secret containing the Cluster Agent token.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#clusterAgentTokenSecret
   */
  readonly clusterAgentTokenSecret?: DatadogAgentV2Alpha1SpecGlobalClusterAgentTokenSecret;

  /**
   * ClusterName sets a unique cluster name for the deployment to easily scope monitoring data in the Datadog app.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#clusterName
   */
  readonly clusterName?: string;

  /**
   * Credentials defines the Datadog credentials used to submit data to/query data from Datadog.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#credentials
   */
  readonly credentials?: DatadogAgentV2Alpha1SpecGlobalCredentials;

  /**
   * Path to the container runtime socket (if different from Docker).
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#criSocketPath
   */
  readonly criSocketPath?: string;

  /**
   * Path to the docker runtime socket.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#dockerSocketPath
   */
  readonly dockerSocketPath?: string;

  /**
   * Endpoint is the Datadog intake URL the Agent data are sent to. Only set this option if you need the Agent to send data to a custom URL. Overrides the site setting defined in `Site`.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#endpoint
   */
  readonly endpoint?: DatadogAgentV2Alpha1SpecGlobalEndpoint;

  /**
   * Kubelet contains the kubelet configuration parameters.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#kubelet
   */
  readonly kubelet?: DatadogAgentV2Alpha1SpecGlobalKubelet;

  /**
   * LocalService contains configuration to customize the internal traffic policy service.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#localService
   */
  readonly localService?: DatadogAgentV2Alpha1SpecGlobalLocalService;

  /**
   * LogLevel sets logging verbosity. This can be overridden by container. Valid log levels are: trace, debug, info, warn, error, critical, and off. Default: 'info'
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#logLevel
   */
  readonly logLevel?: string;

  /**
   * Provide a mapping of Kubernetes Namespace Labels to Datadog Tags. <KUBERNETES_NAMESPACE_LABEL>: <DATADOG_TAG_KEY>
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#namespaceLabelsAsTags
   */
  readonly namespaceLabelsAsTags?: { [key: string]: string };

  /**
   * NetworkPolicy contains the network configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#networkPolicy
   */
  readonly networkPolicy?: DatadogAgentV2Alpha1SpecGlobalNetworkPolicy;

  /**
   * Provide a mapping of Kubernetes Node Labels to Datadog Tags. <KUBERNETES_NODE_LABEL>: <DATADOG_TAG_KEY>
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#nodeLabelsAsTags
   */
  readonly nodeLabelsAsTags?: { [key: string]: string };

  /**
   * Provide a mapping of Kubernetes Annotations to Datadog Tags. <KUBERNETES_ANNOTATIONS>: <DATADOG_TAG_KEY>
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#podAnnotationsAsTags
   */
  readonly podAnnotationsAsTags?: { [key: string]: string };

  /**
   * Provide a mapping of Kubernetes Labels to Datadog Tags. <KUBERNETES_LABEL>: <DATADOG_TAG_KEY>
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#podLabelsAsTags
   */
  readonly podLabelsAsTags?: { [key: string]: string };

  /**
   * Registry is the image registry to use for all Agent images. Use 'public.ecr.aws/datadog' for AWS ECR. Use 'docker.io/datadog' for DockerHub. Default: 'gcr.io/datadoghq'
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#registry
   */
  readonly registry?: string;

  /**
   * Site is the Datadog intake site Agent data are sent to. Set to 'datadoghq.eu' to send data to the EU site. Default: 'datadoghq.com'
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#site
   */
  readonly site?: string;

  /**
   * Tags contains a list of tags to attach to every metric, event and service check collected. Learn more about tagging: https://docs.datadoghq.com/tagging/
   *
   * @schema DatadogAgentV2Alpha1SpecGlobal#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobal(obj: DatadogAgentV2Alpha1SpecGlobal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterAgentToken': obj.clusterAgentToken,
    'clusterAgentTokenSecret': toJson_DatadogAgentV2Alpha1SpecGlobalClusterAgentTokenSecret(obj.clusterAgentTokenSecret),
    'clusterName': obj.clusterName,
    'credentials': toJson_DatadogAgentV2Alpha1SpecGlobalCredentials(obj.credentials),
    'criSocketPath': obj.criSocketPath,
    'dockerSocketPath': obj.dockerSocketPath,
    'endpoint': toJson_DatadogAgentV2Alpha1SpecGlobalEndpoint(obj.endpoint),
    'kubelet': toJson_DatadogAgentV2Alpha1SpecGlobalKubelet(obj.kubelet),
    'localService': toJson_DatadogAgentV2Alpha1SpecGlobalLocalService(obj.localService),
    'logLevel': obj.logLevel,
    'namespaceLabelsAsTags': ((obj.namespaceLabelsAsTags) === undefined) ? undefined : (Object.entries(obj.namespaceLabelsAsTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'networkPolicy': toJson_DatadogAgentV2Alpha1SpecGlobalNetworkPolicy(obj.networkPolicy),
    'nodeLabelsAsTags': ((obj.nodeLabelsAsTags) === undefined) ? undefined : (Object.entries(obj.nodeLabelsAsTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podAnnotationsAsTags': ((obj.podAnnotationsAsTags) === undefined) ? undefined : (Object.entries(obj.podAnnotationsAsTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'podLabelsAsTags': ((obj.podLabelsAsTags) === undefined) ? undefined : (Object.entries(obj.podLabelsAsTags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'registry': obj.registry,
    'site': obj.site,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatadogAgentComponentOverride is the generic description equivalent to a subset of the PodTemplate for a component.
 *
 * @schema DatadogAgentV2Alpha1SpecOverride
 */
export interface DatadogAgentV2Alpha1SpecOverride {
  /**
   * If specified, the pod's scheduling constraints.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#affinity
   */
  readonly affinity?: DatadogAgentV2Alpha1SpecOverrideAffinity;

  /**
   * Annotations provide annotations that are added to the different component (Datadog Agent, Cluster Agent, Cluster Check Runner) pods.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Configure the basic configurations for each Agent container. Valid Agent container names are: `agent`, `cluster-agent`, `init-config`, `init-volume`, `process-agent`, `seccomp-setup`, `security-agent`, `system-probe`, `trace-agent`, and `all`. Configuration under `all` applies to all configured containers.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#containers
   */
  readonly containers?: { [key: string]: DatadogAgentV2Alpha1SpecOverrideContainers };

  /**
   * Set CreateRbac to false to prevent automatic creation of Role/ClusterRole for this component
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#createRbac
   */
  readonly createRbac?: boolean;

  /**
   * CustomConfiguration allows to specify custom configuration files for `datadog.yaml`, `datadog-cluster.yaml`, `security-agent.yaml`, and `system-probe.yaml`. The content is merged with configuration generated by the Datadog Operator, with priority given to custom configuration. WARNING: It is possible to override values set in the `DatadogAgent`.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#customConfigurations
   */
  readonly customConfigurations?: { [key: string]: DatadogAgentV2Alpha1SpecOverrideCustomConfigurations };

  /**
   * Disabled force disables a component.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#disabled
   */
  readonly disabled?: boolean;

  /**
   * Specify additional environment variables for all containers in this component Priority is Container > Component. See also: https://docs.datadoghq.com/agent/kubernetes/?tab=helm#environment-variables
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#env
   */
  readonly env?: DatadogAgentV2Alpha1SpecOverrideEnv[];

  /**
   * Checksd configuration allowing to specify custom checks placed under /etc/datadog-agent/checks.d/ See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#extraChecksd
   */
  readonly extraChecksd?: DatadogAgentV2Alpha1SpecOverrideExtraChecksd;

  /**
   * Confd configuration allowing to specify config files for custom checks placed under /etc/datadog-agent/conf.d/. See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#extraConfd
   */
  readonly extraConfd?: DatadogAgentV2Alpha1SpecOverrideExtraConfd;

  /**
   * Host networking requested for this pod. Use the host's network namespace.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#hostNetwork
   */
  readonly hostNetwork?: boolean;

  /**
   * Use the host's PID namespace.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#hostPID
   */
  readonly hostPid?: boolean;

  /**
   * The container image of the different components (Datadog Agent, Cluster Agent, Cluster Check Runner).
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#image
   */
  readonly image?: DatadogAgentV2Alpha1SpecOverrideImage;

  /**
   * AdditionalLabels provide labels that are added to the different component (Datadog Agent, Cluster Agent, Cluster Check Runner) pods.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name overrides the default name for the resource
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#name
   */
  readonly name?: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#nodeSelector
   */
  readonly nodeSelector?: { [key: string]: string };

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority is default, or zero if there is no default.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Number of the replicas. Not applicable for a DaemonSet/ExtendedDaemonSet deployment
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#replicas
   */
  readonly replicas?: number;

  /**
   * Pod-level SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#securityContext
   */
  readonly securityContext?: DatadogAgentV2Alpha1SpecOverrideSecurityContext;

  /**
   * Configure the SecurityContextConstraints for each component.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#securityContextConstraints
   */
  readonly securityContextConstraints?: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraints;

  /**
   * Sets the ServiceAccount used by this component. Ignored if the field CreateRbac is true.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * Configure the component tolerations.
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#tolerations
   */
  readonly tolerations?: DatadogAgentV2Alpha1SpecOverrideTolerations[];

  /**
   * Specify additional volumes in the different components (Datadog Agent, Cluster Agent, Cluster Check Runner).
   *
   * @schema DatadogAgentV2Alpha1SpecOverride#volumes
   */
  readonly volumes?: DatadogAgentV2Alpha1SpecOverrideVolumes[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverride' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverride(obj: DatadogAgentV2Alpha1SpecOverride | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'affinity': toJson_DatadogAgentV2Alpha1SpecOverrideAffinity(obj.affinity),
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'containers': ((obj.containers) === undefined) ? undefined : (Object.entries(obj.containers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_DatadogAgentV2Alpha1SpecOverrideContainers(i[1]) }), {})),
    'createRbac': obj.createRbac,
    'customConfigurations': ((obj.customConfigurations) === undefined) ? undefined : (Object.entries(obj.customConfigurations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_DatadogAgentV2Alpha1SpecOverrideCustomConfigurations(i[1]) }), {})),
    'disabled': obj.disabled,
    'env': obj.env?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideEnv(y)),
    'extraChecksd': toJson_DatadogAgentV2Alpha1SpecOverrideExtraChecksd(obj.extraChecksd),
    'extraConfd': toJson_DatadogAgentV2Alpha1SpecOverrideExtraConfd(obj.extraConfd),
    'hostNetwork': obj.hostNetwork,
    'hostPID': obj.hostPid,
    'image': toJson_DatadogAgentV2Alpha1SpecOverrideImage(obj.image),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'nodeSelector': ((obj.nodeSelector) === undefined) ? undefined : (Object.entries(obj.nodeSelector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'priorityClassName': obj.priorityClassName,
    'replicas': obj.replicas,
    'securityContext': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContext(obj.securityContext),
    'securityContextConstraints': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraints(obj.securityContextConstraints),
    'serviceAccountName': obj.serviceAccountName,
    'tolerations': obj.tolerations?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideTolerations(y)),
    'volumes': obj.volumes?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AdmissionController configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesAdmissionController
 */
export interface DatadogAgentV2Alpha1SpecFeaturesAdmissionController {
  /**
   * AgentCommunicationMode corresponds to the mode used by the Datadog application libraries to communicate with the Agent. It can be "hostip", "service", or "socket".
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesAdmissionController#agentCommunicationMode
   */
  readonly agentCommunicationMode?: string;

  /**
   * Enabled enables the Admission Controller. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesAdmissionController#enabled
   */
  readonly enabled?: boolean;

  /**
   * FailurePolicy determines how unrecognized and timeout errors are handled.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesAdmissionController#failurePolicy
   */
  readonly failurePolicy?: string;

  /**
   * MutateUnlabelled enables config injection without the need of pod label 'admission.datadoghq.com/enabled="true"'. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesAdmissionController#mutateUnlabelled
   */
  readonly mutateUnlabelled?: boolean;

  /**
   * ServiceName corresponds to the webhook service name.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesAdmissionController#serviceName
   */
  readonly serviceName?: string;

  /**
   * WebhookName is a custom name for the MutatingWebhookConfiguration. Default: "datadog-webhook"
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesAdmissionController#webhookName
   */
  readonly webhookName?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesAdmissionController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesAdmissionController(obj: DatadogAgentV2Alpha1SpecFeaturesAdmissionController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agentCommunicationMode': obj.agentCommunicationMode,
    'enabled': obj.enabled,
    'failurePolicy': obj.failurePolicy,
    'mutateUnlabelled': obj.mutateUnlabelled,
    'serviceName': obj.serviceName,
    'webhookName': obj.webhookName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APM (Application Performance Monitoring) configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesApm
 */
export interface DatadogAgentV2Alpha1SpecFeaturesApm {
  /**
   * Enabled enables Application Performance Monitoring. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesApm#enabled
   */
  readonly enabled?: boolean;

  /**
   * HostPortConfig contains host port configuration. Enabled Default: false Port Default: 8126
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesApm#hostPortConfig
   */
  readonly hostPortConfig?: DatadogAgentV2Alpha1SpecFeaturesApmHostPortConfig;

  /**
   * UnixDomainSocketConfig contains socket configuration. See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables Enabled Default: true Path Default: `/var/run/datadog/apm.socket`
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesApm#unixDomainSocketConfig
   */
  readonly unixDomainSocketConfig?: DatadogAgentV2Alpha1SpecFeaturesApmUnixDomainSocketConfig;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesApm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesApm(obj: DatadogAgentV2Alpha1SpecFeaturesApm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'hostPortConfig': toJson_DatadogAgentV2Alpha1SpecFeaturesApmHostPortConfig(obj.hostPortConfig),
    'unixDomainSocketConfig': toJson_DatadogAgentV2Alpha1SpecFeaturesApmUnixDomainSocketConfig(obj.unixDomainSocketConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterChecks configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesClusterChecks
 */
export interface DatadogAgentV2Alpha1SpecFeaturesClusterChecks {
  /**
   * Enables Cluster Checks scheduling in the Cluster Agent. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesClusterChecks#enabled
   */
  readonly enabled?: boolean;

  /**
   * Enabled enables Cluster Checks Runners to run all Cluster Checks. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesClusterChecks#useClusterChecksRunners
   */
  readonly useClusterChecksRunners?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesClusterChecks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesClusterChecks(obj: DatadogAgentV2Alpha1SpecFeaturesClusterChecks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'useClusterChecksRunners': obj.useClusterChecksRunners,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSPM (Cloud Security Posture Management) configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesCspm
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCspm {
  /**
   * CheckInterval defines the check interval.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspm#checkInterval
   */
  readonly checkInterval?: string;

  /**
   * CustomBenchmarks contains CSPM benchmarks. The content of the ConfigMap will be merged with the benchmarks bundled with the agent. Any benchmarks with the same name as those existing in the agent will take precedence.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspm#customBenchmarks
   */
  readonly customBenchmarks?: DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarks;

  /**
   * Enabled enables Cloud Security Posture Management. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspm#enabled
   */
  readonly enabled?: boolean;

  /**
   * HostBenchmarks contains configuration for host benchmarks.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspm#hostBenchmarks
   */
  readonly hostBenchmarks?: DatadogAgentV2Alpha1SpecFeaturesCspmHostBenchmarks;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCspm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCspm(obj: DatadogAgentV2Alpha1SpecFeaturesCspm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkInterval': obj.checkInterval,
    'customBenchmarks': toJson_DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarks(obj.customBenchmarks),
    'enabled': obj.enabled,
    'hostBenchmarks': toJson_DatadogAgentV2Alpha1SpecFeaturesCspmHostBenchmarks(obj.hostBenchmarks),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CWS (Cloud Workload Security) configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesCws
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCws {
  /**
   * CustomPolicies contains security policies. The content of the ConfigMap will be merged with the policies bundled with the agent. Any policies with the same name as those existing in the agent will take precedence.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCws#customPolicies
   */
  readonly customPolicies?: DatadogAgentV2Alpha1SpecFeaturesCwsCustomPolicies;

  /**
   * Enabled enables Cloud Workload Security. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCws#enabled
   */
  readonly enabled?: boolean;

  /**
   * @schema DatadogAgentV2Alpha1SpecFeaturesCws#network
   */
  readonly network?: DatadogAgentV2Alpha1SpecFeaturesCwsNetwork;

  /**
   * @schema DatadogAgentV2Alpha1SpecFeaturesCws#remoteConfiguration
   */
  readonly remoteConfiguration?: DatadogAgentV2Alpha1SpecFeaturesCwsRemoteConfiguration;

  /**
   * @schema DatadogAgentV2Alpha1SpecFeaturesCws#securityProfiles
   */
  readonly securityProfiles?: DatadogAgentV2Alpha1SpecFeaturesCwsSecurityProfiles;

  /**
   * SyscallMonitorEnabled enables Syscall Monitoring (recommended for troubleshooting only). Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCws#syscallMonitorEnabled
   */
  readonly syscallMonitorEnabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCws' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCws(obj: DatadogAgentV2Alpha1SpecFeaturesCws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customPolicies': toJson_DatadogAgentV2Alpha1SpecFeaturesCwsCustomPolicies(obj.customPolicies),
    'enabled': obj.enabled,
    'network': toJson_DatadogAgentV2Alpha1SpecFeaturesCwsNetwork(obj.network),
    'remoteConfiguration': toJson_DatadogAgentV2Alpha1SpecFeaturesCwsRemoteConfiguration(obj.remoteConfiguration),
    'securityProfiles': toJson_DatadogAgentV2Alpha1SpecFeaturesCwsSecurityProfiles(obj.securityProfiles),
    'syscallMonitorEnabled': obj.syscallMonitorEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Dogstatsd configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsd
 */
export interface DatadogAgentV2Alpha1SpecFeaturesDogstatsd {
  /**
   * HostPortConfig contains host port configuration. Enabled Default: false Port Default: 8125
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsd#hostPortConfig
   */
  readonly hostPortConfig?: DatadogAgentV2Alpha1SpecFeaturesDogstatsdHostPortConfig;

  /**
   * Configure the Dogstasd Mapper Profiles. Can be passed as raw data or via a json encoded string in a config map. See also: https://docs.datadoghq.com/developers/dogstatsd/dogstatsd_mapper/
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsd#mapperProfiles
   */
  readonly mapperProfiles?: DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfiles;

  /**
   * OriginDetectionEnabled enables origin detection for container tagging. See also: https://docs.datadoghq.com/developers/dogstatsd/unix_socket/#using-origin-detection-for-container-tagging
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsd#originDetectionEnabled
   */
  readonly originDetectionEnabled?: boolean;

  /**
   * UnixDomainSocketConfig contains socket configuration. See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables Enabled Default: true Path Default: `/var/run/datadog/dsd.socket`
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsd#unixDomainSocketConfig
   */
  readonly unixDomainSocketConfig?: DatadogAgentV2Alpha1SpecFeaturesDogstatsdUnixDomainSocketConfig;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesDogstatsd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsd(obj: DatadogAgentV2Alpha1SpecFeaturesDogstatsd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostPortConfig': toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdHostPortConfig(obj.hostPortConfig),
    'mapperProfiles': toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfiles(obj.mapperProfiles),
    'originDetectionEnabled': obj.originDetectionEnabled,
    'unixDomainSocketConfig': toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdUnixDomainSocketConfig(obj.unixDomainSocketConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EBPFCheck configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesEbpfCheck
 */
export interface DatadogAgentV2Alpha1SpecFeaturesEbpfCheck {
  /**
   * Enables the eBPF check. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesEbpfCheck#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesEbpfCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesEbpfCheck(obj: DatadogAgentV2Alpha1SpecFeaturesEbpfCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventCollection configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesEventCollection
 */
export interface DatadogAgentV2Alpha1SpecFeaturesEventCollection {
  /**
   * CollectKubernetesEvents enables Kubernetes event collection. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesEventCollection#collectKubernetesEvents
   */
  readonly collectKubernetesEvents?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesEventCollection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesEventCollection(obj: DatadogAgentV2Alpha1SpecFeaturesEventCollection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectKubernetesEvents': obj.collectKubernetesEvents,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalMetricsServer configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer
 */
export interface DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer {
  /**
   * Enabled enables the External Metrics Server. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer#enabled
   */
  readonly enabled?: boolean;

  /**
   * Override the API endpoint for the External Metrics Server. URL Default: "https://app.datadoghq.com".
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer#endpoint
   */
  readonly endpoint?: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpoint;

  /**
   * Port specifies the metricsProvider External Metrics Server service port. Default: 8443
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer#port
   */
  readonly port?: number;

  /**
   * UseDatadogMetrics enables usage of the DatadogMetrics CRD (allowing one to scale on arbitrary Datadog metric queries). Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer#useDatadogMetrics
   */
  readonly useDatadogMetrics?: boolean;

  /**
   * WPAController enables the informer and controller of the Watermark Pod Autoscaler. NOTE: The Watermark Pod Autoscaler controller needs to be installed. See also: https://github.com/DataDog/watermarkpodautoscaler. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer#wpaController
   */
  readonly wpaController?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer(obj: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'endpoint': toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpoint(obj.endpoint),
    'port': obj.port,
    'useDatadogMetrics': obj.useDatadogMetrics,
    'wpaController': obj.wpaController,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KubeStateMetricsCore check configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCore
 */
export interface DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCore {
  /**
   * Conf overrides the configuration for the default Kubernetes State Metrics Core check. This must point to a ConfigMap containing a valid cluster check configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCore#conf
   */
  readonly conf?: DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConf;

  /**
   * Enabled enables Kube State Metrics Core. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCore#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCore(obj: DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conf': toJson_DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConf(obj.conf),
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LiveContainerCollection configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesLiveContainerCollection
 */
export interface DatadogAgentV2Alpha1SpecFeaturesLiveContainerCollection {
  /**
   * Enables container collection for the Live Container View. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLiveContainerCollection#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesLiveContainerCollection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesLiveContainerCollection(obj: DatadogAgentV2Alpha1SpecFeaturesLiveContainerCollection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LiveProcessCollection configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection
 */
export interface DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection {
  /**
   * Enabled enables Process monitoring. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection#enabled
   */
  readonly enabled?: boolean;

  /**
   * ScrubProcessArguments enables scrubbing of sensitive data in process command-lines (passwords, tokens, etc. ). Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection#scrubProcessArguments
   */
  readonly scrubProcessArguments?: boolean;

  /**
   * StripProcessArguments enables stripping of all process arguments. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection#stripProcessArguments
   */
  readonly stripProcessArguments?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection(obj: DatadogAgentV2Alpha1SpecFeaturesLiveProcessCollection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'scrubProcessArguments': obj.scrubProcessArguments,
    'stripProcessArguments': obj.stripProcessArguments,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LogCollection configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesLogCollection
 */
export interface DatadogAgentV2Alpha1SpecFeaturesLogCollection {
  /**
   * ContainerCollectAll enables Log collection from all containers. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLogCollection#containerCollectAll
   */
  readonly containerCollectAll?: boolean;

  /**
   * ContainerCollectUsingFiles enables log collection from files in `/var/log/pods instead` of using the container runtime API. Collecting logs from files is usually the most efficient way of collecting logs. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLogCollection#containerCollectUsingFiles
   */
  readonly containerCollectUsingFiles?: boolean;

  /**
   * ContainerLogsPath allows log collection from the container log path. Set to a different path if you are not using the Docker runtime. See also: https://docs.datadoghq.com/agent/kubernetes/daemonset_setup/?tab=k8sfile#create-manifest Default: `/var/lib/docker/containers`
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLogCollection#containerLogsPath
   */
  readonly containerLogsPath?: string;

  /**
   * ContainerSymlinksPath allows log collection to use symbolic links in this directory to validate container ID -> pod. Default: `/var/log/containers`
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLogCollection#containerSymlinksPath
   */
  readonly containerSymlinksPath?: string;

  /**
   * Enabled enables Log collection. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLogCollection#enabled
   */
  readonly enabled?: boolean;

  /**
   * OpenFilesLimit sets the maximum number of log files that the Datadog Agent tails. Increasing this limit can increase resource consumption of the Agent. See also: https://docs.datadoghq.com/agent/basic_agent_usage/kubernetes/#log-collection-setup Default: 100
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLogCollection#openFilesLimit
   */
  readonly openFilesLimit?: number;

  /**
   * PodLogsPath allows log collection from a pod log path. Default: `/var/log/pods`
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLogCollection#podLogsPath
   */
  readonly podLogsPath?: string;

  /**
   * TempStoragePath (always mounted from the host) is used by the Agent to store information about processed log files. If the Agent is restarted, it starts tailing the log files immediately. Default: `/var/lib/datadog-agent/logs`
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesLogCollection#tempStoragePath
   */
  readonly tempStoragePath?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesLogCollection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesLogCollection(obj: DatadogAgentV2Alpha1SpecFeaturesLogCollection | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerCollectAll': obj.containerCollectAll,
    'containerCollectUsingFiles': obj.containerCollectUsingFiles,
    'containerLogsPath': obj.containerLogsPath,
    'containerSymlinksPath': obj.containerSymlinksPath,
    'enabled': obj.enabled,
    'openFilesLimit': obj.openFilesLimit,
    'podLogsPath': obj.podLogsPath,
    'tempStoragePath': obj.tempStoragePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NPM (Network Performance Monitoring) configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesNpm
 */
export interface DatadogAgentV2Alpha1SpecFeaturesNpm {
  /**
   * CollectDNSStats enables DNS stat collection. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesNpm#collectDNSStats
   */
  readonly collectDnsStats?: boolean;

  /**
   * EnableConntrack enables the system-probe agent to connect to the netlink/conntrack subsystem to add NAT information to connection data. See also: http://conntrack-tools.netfilter.org/ Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesNpm#enableConntrack
   */
  readonly enableConntrack?: boolean;

  /**
   * Enabled enables Network Performance Monitoring. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesNpm#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesNpm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesNpm(obj: DatadogAgentV2Alpha1SpecFeaturesNpm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectDNSStats': obj.collectDnsStats,
    'enableConntrack': obj.enableConntrack,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OOMKill configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOomKill
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOomKill {
  /**
   * Enables the OOMKill eBPF-based check. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOomKill#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOomKill' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOomKill(obj: DatadogAgentV2Alpha1SpecFeaturesOomKill | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OrchestratorExplorer check configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer {
  /**
   * Conf overrides the configuration for the default Orchestrator Explorer check. This must point to a ConfigMap containing a valid cluster check configuration.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer#conf
   */
  readonly conf?: DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConf;

  /**
   * `CustomResources` defines custom resources for the orchestrator explorer to collect. Each item should follow the convention `group/version/kind`. For example, `datadoghq.com/v1alpha1/datadogmetrics`.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer#customResources
   */
  readonly customResources?: string[];

  /**
   * Override the API endpoint for the Orchestrator Explorer. URL Default: "https://orchestrator.datadoghq.com".
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer#ddUrl
   */
  readonly ddUrl?: string;

  /**
   * Enabled enables the Orchestrator Explorer. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer#enabled
   */
  readonly enabled?: boolean;

  /**
   * Additional tags to associate with the collected data in the form of `a b c`. This is a Cluster Agent option distinct from DD_TAGS that is used in the Orchestrator Explorer.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer#extraTags
   */
  readonly extraTags?: string[];

  /**
   * ScrubContainers enables scrubbing of sensitive container data (passwords, tokens, etc. ). Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer#scrubContainers
   */
  readonly scrubContainers?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer(obj: DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conf': toJson_DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConf(obj.conf),
    'customResources': obj.customResources?.map(y => y),
    'ddUrl': obj.ddUrl,
    'enabled': obj.enabled,
    'extraTags': obj.extraTags?.map(y => y),
    'scrubContainers': obj.scrubContainers,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OTLP ingest configuration
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOtlp
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOtlp {
  /**
   * Receiver contains configuration for the OTLP ingest receiver.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOtlp#receiver
   */
  readonly receiver?: DatadogAgentV2Alpha1SpecFeaturesOtlpReceiver;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOtlp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOtlp(obj: DatadogAgentV2Alpha1SpecFeaturesOtlp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'receiver': toJson_DatadogAgentV2Alpha1SpecFeaturesOtlpReceiver(obj.receiver),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrometheusScrape configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape
 */
export interface DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape {
  /**
   * AdditionalConfigs allows adding advanced Prometheus check configurations with custom discovery rules.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape#additionalConfigs
   */
  readonly additionalConfigs?: string;

  /**
   * EnableServiceEndpoints enables generating dedicated checks for service endpoints. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape#enableServiceEndpoints
   */
  readonly enableServiceEndpoints?: boolean;

  /**
   * Enable autodiscovery of pods and services exposing Prometheus metrics. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape#enabled
   */
  readonly enabled?: boolean;

  /**
   * Version specifies the version of the OpenMetrics check. Default: 2
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape#version
   */
  readonly version?: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape(obj: DatadogAgentV2Alpha1SpecFeaturesPrometheusScrape | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalConfigs': obj.additionalConfigs,
    'enableServiceEndpoints': obj.enableServiceEndpoints,
    'enabled': obj.enabled,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Remote Configuration configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesRemoteConfiguration
 */
export interface DatadogAgentV2Alpha1SpecFeaturesRemoteConfiguration {
  /**
   * Enable this option to activate Remote Configuration. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesRemoteConfiguration#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesRemoteConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesRemoteConfiguration(obj: DatadogAgentV2Alpha1SpecFeaturesRemoteConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPQueueLength configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesTcpQueueLength
 */
export interface DatadogAgentV2Alpha1SpecFeaturesTcpQueueLength {
  /**
   * Enables the TCP queue length eBPF-based check. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesTcpQueueLength#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesTcpQueueLength' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesTcpQueueLength(obj: DatadogAgentV2Alpha1SpecFeaturesTcpQueueLength | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * USM (Universal Service Monitoring) configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesUsm
 */
export interface DatadogAgentV2Alpha1SpecFeaturesUsm {
  /**
   * Enabled enables Universal Service Monitoring. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesUsm#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesUsm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesUsm(obj: DatadogAgentV2Alpha1SpecFeaturesUsm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterAgentTokenSecret is the secret containing the Cluster Agent token.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalClusterAgentTokenSecret
 */
export interface DatadogAgentV2Alpha1SpecGlobalClusterAgentTokenSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalClusterAgentTokenSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalClusterAgentTokenSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalClusterAgentTokenSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalClusterAgentTokenSecret(obj: DatadogAgentV2Alpha1SpecGlobalClusterAgentTokenSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials defines the Datadog credentials used to submit data to/query data from Datadog.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalCredentials
 */
export interface DatadogAgentV2Alpha1SpecGlobalCredentials {
  /**
   * APIKey configures your Datadog API key. See also: https://app.datadoghq.com/account/settings#agent/kubernetes
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalCredentials#apiKey
   */
  readonly apiKey?: string;

  /**
   * APISecret references an existing Secret which stores the API key instead of creating a new one. If set, this parameter takes precedence over "APIKey".
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalCredentials#apiSecret
   */
  readonly apiSecret?: DatadogAgentV2Alpha1SpecGlobalCredentialsApiSecret;

  /**
   * AppKey configures your Datadog application key. If you are using features.externalMetricsServer.enabled = true, you must set a Datadog application key for read access to your metrics.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalCredentials#appKey
   */
  readonly appKey?: string;

  /**
   * AppSecret references an existing Secret which stores the application key instead of creating a new one. If set, this parameter takes precedence over "AppKey".
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalCredentials#appSecret
   */
  readonly appSecret?: DatadogAgentV2Alpha1SpecGlobalCredentialsAppSecret;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalCredentials(obj: DatadogAgentV2Alpha1SpecGlobalCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiSecret': toJson_DatadogAgentV2Alpha1SpecGlobalCredentialsApiSecret(obj.apiSecret),
    'appKey': obj.appKey,
    'appSecret': toJson_DatadogAgentV2Alpha1SpecGlobalCredentialsAppSecret(obj.appSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Endpoint is the Datadog intake URL the Agent data are sent to. Only set this option if you need the Agent to send data to a custom URL. Overrides the site setting defined in `Site`.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalEndpoint
 */
export interface DatadogAgentV2Alpha1SpecGlobalEndpoint {
  /**
   * Credentials defines the Datadog credentials used to submit data to/query data from Datadog.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpoint#credentials
   */
  readonly credentials?: DatadogAgentV2Alpha1SpecGlobalEndpointCredentials;

  /**
   * URL defines the endpoint URL.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpoint#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalEndpoint(obj: DatadogAgentV2Alpha1SpecGlobalEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_DatadogAgentV2Alpha1SpecGlobalEndpointCredentials(obj.credentials),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kubelet contains the kubelet configuration parameters.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalKubelet
 */
export interface DatadogAgentV2Alpha1SpecGlobalKubelet {
  /**
   * AgentCAPath is the container path where the kubelet CA certificate is stored. Default: '/var/run/host-kubelet-ca.crt' if hostCAPath is set, else '/var/run/secrets/kubernetes.io/serviceaccount/ca.crt'
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubelet#agentCAPath
   */
  readonly agentCaPath?: string;

  /**
   * Host overrides the host used to contact kubelet API (default to status.hostIP).
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubelet#host
   */
  readonly host?: DatadogAgentV2Alpha1SpecGlobalKubeletHost;

  /**
   * HostCAPath is the host path where the kubelet CA certificate is stored.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubelet#hostCAPath
   */
  readonly hostCaPath?: string;

  /**
   * TLSVerify toggles kubelet TLS verification. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubelet#tlsVerify
   */
  readonly tlsVerify?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalKubelet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalKubelet(obj: DatadogAgentV2Alpha1SpecGlobalKubelet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agentCAPath': obj.agentCaPath,
    'host': toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHost(obj.host),
    'hostCAPath': obj.hostCaPath,
    'tlsVerify': obj.tlsVerify,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalService contains configuration to customize the internal traffic policy service.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalLocalService
 */
export interface DatadogAgentV2Alpha1SpecGlobalLocalService {
  /**
   * ForceEnableLocalService forces the creation of the internal traffic policy service to target the agent running on the local node. This parameter only applies to Kubernetes 1.21, where the feature is in alpha and is disabled by default. (On Kubernetes 1.22+, the feature entered beta and the internal traffic service is created by default, so this parameter is ignored.) Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalLocalService#forceEnableLocalService
   */
  readonly forceEnableLocalService?: boolean;

  /**
   * NameOverride defines the name of the internal traffic service to target the agent running on the local node.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalLocalService#nameOverride
   */
  readonly nameOverride?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalLocalService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalLocalService(obj: DatadogAgentV2Alpha1SpecGlobalLocalService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceEnableLocalService': obj.forceEnableLocalService,
    'nameOverride': obj.nameOverride,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NetworkPolicy contains the network configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicy
 */
export interface DatadogAgentV2Alpha1SpecGlobalNetworkPolicy {
  /**
   * Create defines whether to create a NetworkPolicy for the current deployment.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicy#create
   */
  readonly create?: boolean;

  /**
   * DNSSelectorEndpoints defines the cilium selector of the DNSserver entity.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicy#dnsSelectorEndpoints
   */
  readonly dnsSelectorEndpoints?: DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpoints[];

  /**
   * Flavor defines Which network policy to use.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicy#flavor
   */
  readonly flavor?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalNetworkPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalNetworkPolicy(obj: DatadogAgentV2Alpha1SpecGlobalNetworkPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'create': obj.create,
    'dnsSelectorEndpoints': obj.dnsSelectorEndpoints?.map(y => toJson_DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpoints(y)),
    'flavor': obj.flavor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If specified, the pod's scheduling constraints.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinity
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinity {
  /**
   * Describes node affinity scheduling rules for the pod.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinity#nodeAffinity
   */
  readonly nodeAffinity?: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinity#podAffinity
   */
  readonly podAffinity?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinity(obj: DatadogAgentV2Alpha1SpecOverrideAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatadogAgentGenericContainer is the generic structure describing any container's common configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainers
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainers {
  /**
   * AppArmorProfileName specifies an apparmor profile.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#appArmorProfileName
   */
  readonly appArmorProfileName?: string;

  /**
   * Args allows the specification of extra args to the `Command` parameter
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#args
   */
  readonly args?: string[];

  /**
   * Command allows the specification of a custom entrypoint for container
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#command
   */
  readonly command?: string[];

  /**
   * Specify additional environment variables in the container. See also: https://docs.datadoghq.com/agent/kubernetes/?tab=helm#environment-variables
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#env
   */
  readonly env?: DatadogAgentV2Alpha1SpecOverrideContainersEnv[];

  /**
   * HealthPort of the container for the internal liveness probe. Must be the same as the Liveness/Readiness probes.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#healthPort
   */
  readonly healthPort?: number;

  /**
   * Configure the Liveness Probe of the container
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#livenessProbe
   */
  readonly livenessProbe?: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe;

  /**
   * LogLevel sets logging verbosity (overrides global setting). Valid log levels are: trace, debug, info, warn, error, critical, and off. Default: 'info'
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#logLevel
   */
  readonly logLevel?: string;

  /**
   * Name of the container that is overridden
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#name
   */
  readonly name?: string;

  /**
   * Configure the Readiness Probe of the container
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#readinessProbe
   */
  readonly readinessProbe?: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe;

  /**
   * Specify the Request and Limits of the pods To get guaranteed QoS class, specify requests and limits equal. See also: http://kubernetes.io/docs/user-guide/compute-resources/
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#resources
   */
  readonly resources?: DatadogAgentV2Alpha1SpecOverrideContainersResources;

  /**
   * Seccomp configurations to override Operator actions. For all other Seccomp Profile manipulation, use SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#seccompConfig
   */
  readonly seccompConfig?: DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfig;

  /**
   * Container-level SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#securityContext
   */
  readonly securityContext?: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext;

  /**
   * Specify additional volume mounts in the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainers#volumeMounts
   */
  readonly volumeMounts?: DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainers(obj: DatadogAgentV2Alpha1SpecOverrideContainers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appArmorProfileName': obj.appArmorProfileName,
    'args': obj.args?.map(y => y),
    'command': obj.command?.map(y => y),
    'env': obj.env?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnv(y)),
    'healthPort': obj.healthPort,
    'livenessProbe': toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe(obj.livenessProbe),
    'logLevel': obj.logLevel,
    'name': obj.name,
    'readinessProbe': toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe(obj.readinessProbe),
    'resources': toJson_DatadogAgentV2Alpha1SpecOverrideContainersResources(obj.resources),
    'seccompConfig': toJson_DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfig(obj.seccompConfig),
    'securityContext': toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext(obj.securityContext),
    'volumeMounts': obj.volumeMounts?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomConfig provides a place for custom configuration of the Agent or Cluster Agent, corresponding to datadog.yaml, system-probe.yaml, security-agent.yaml or datadog-cluster.yaml. The configuration can be provided in the ConfigData field as raw data, or referenced in a ConfigMap. Note: `ConfigData` and `ConfigMap` cannot be set together.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurations
 */
export interface DatadogAgentV2Alpha1SpecOverrideCustomConfigurations {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurations#configData
   */
  readonly configData?: string;

  /**
   * ConfigMap references an existing ConfigMap with the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurations#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideCustomConfigurations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideCustomConfigurations(obj: DatadogAgentV2Alpha1SpecOverrideCustomConfigurations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideEnv
 */
export interface DatadogAgentV2Alpha1SpecOverrideEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentV2Alpha1SpecOverrideEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentV2Alpha1SpecOverrideEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideEnv(obj: DatadogAgentV2Alpha1SpecOverrideEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Checksd configuration allowing to specify custom checks placed under /etc/datadog-agent/checks.d/ See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksd
 */
export interface DatadogAgentV2Alpha1SpecOverrideExtraChecksd {
  /**
   * ConfigDataMap corresponds to the content of the configuration files. The key should be the filename the contents get mounted to; for instance check.py or check.yaml.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksd#configDataMap
   */
  readonly configDataMap?: { [key: string]: string };

  /**
   * ConfigMap references an existing ConfigMap with the content of the configuration files.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksd#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideExtraChecksd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideExtraChecksd(obj: DatadogAgentV2Alpha1SpecOverrideExtraChecksd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configDataMap': ((obj.configDataMap) === undefined) ? undefined : (Object.entries(obj.configDataMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'configMap': toJson_DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Confd configuration allowing to specify config files for custom checks placed under /etc/datadog-agent/conf.d/. See https://docs.datadoghq.com/agent/guide/agent-configuration-files/?tab=agentv6 for more details.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfd
 */
export interface DatadogAgentV2Alpha1SpecOverrideExtraConfd {
  /**
   * ConfigDataMap corresponds to the content of the configuration files. The key should be the filename the contents get mounted to; for instance check.py or check.yaml.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfd#configDataMap
   */
  readonly configDataMap?: { [key: string]: string };

  /**
   * ConfigMap references an existing ConfigMap with the content of the configuration files.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfd#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideExtraConfd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideExtraConfd(obj: DatadogAgentV2Alpha1SpecOverrideExtraConfd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configDataMap': ((obj.configDataMap) === undefined) ? undefined : (Object.entries(obj.configDataMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'configMap': toJson_DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The container image of the different components (Datadog Agent, Cluster Agent, Cluster Check Runner).
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideImage
 */
export interface DatadogAgentV2Alpha1SpecOverrideImage {
  /**
   * Define whether the Agent image should support JMX. To be used if the Name field does not correspond to a full image string.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideImage#jmxEnabled
   */
  readonly jmxEnabled?: boolean;

  /**
   * Define the image to use: Use "gcr.io/datadoghq/agent:latest" for Datadog Agent 7. Use "datadog/dogstatsd:latest" for standalone Datadog Agent DogStatsD 7. Use "gcr.io/datadoghq/cluster-agent:latest" for Datadog Cluster Agent. Use "agent" with the registry and tag configurations for <registry>/agent:<tag>. Use "cluster-agent" with the registry and tag configurations for <registry>/cluster-agent:<tag>. If the name is the full image string`<name>:<tag>` or `<registry>/<name>:<tag>`, then `tag`, `jmxEnabled`, and `global.registry` values are ignored. Otherwise, image string is created by overriding default settings with supplied `name`, `tag`, and `jmxEnabled` values; image string is created using default registry unless `global.registry` is configured.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideImage#name
   */
  readonly name?: string;

  /**
   * The Kubernetes pull policy: Use Always, Never, or IfNotPresent.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideImage#pullPolicy
   */
  readonly pullPolicy?: string;

  /**
   * It is possible to specify Docker registry credentials. See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideImage#pullSecrets
   */
  readonly pullSecrets?: DatadogAgentV2Alpha1SpecOverrideImagePullSecrets[];

  /**
   * Define the image tag to use. To be used if the Name field does not correspond to a full image string.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideImage(obj: DatadogAgentV2Alpha1SpecOverrideImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmxEnabled': obj.jmxEnabled,
    'name': obj.name,
    'pullPolicy': obj.pullPolicy,
    'pullSecrets': obj.pullSecrets?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideImagePullSecrets(y)),
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod-level SecurityContext.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
   * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
   * If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#seccompProfile
   */
  readonly seccompProfile?: DatadogAgentV2Alpha1SpecOverrideSecurityContextSeccompProfile;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#sysctls
   */
  readonly sysctls?: DatadogAgentV2Alpha1SpecOverrideSecurityContextSysctls[];

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContext#windowsOptions
   */
  readonly windowsOptions?: DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContext(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextSysctls(y)),
    'windowsOptions': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the SecurityContextConstraints for each component.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraints
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraints {
  /**
   * Create defines whether to create a SecurityContextConstraints for the current component. If CustomConfiguration is not set, setting Create to `true` creates a default SCC.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraints#create
   */
  readonly create?: boolean;

  /**
   * CustomConfiguration defines a custom SCC configuration to use if Create is `true`.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraints#customConfiguration
   */
  readonly customConfiguration?: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraints(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'create': obj.create,
    'customConfiguration': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration(obj.customConfiguration),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideTolerations
 */
export interface DatadogAgentV2Alpha1SpecOverrideTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema DatadogAgentV2Alpha1SpecOverrideTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideTolerations(obj: DatadogAgentV2Alpha1SpecOverrideTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumes
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumes {
  /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#azureDisk
   */
  readonly azureDisk?: DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#azureFile
   */
  readonly azureFile?: DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile;

  /**
   * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#cephfs
   */
  readonly cephfs?: DatadogAgentV2Alpha1SpecOverrideVolumesCephfs;

  /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#cinder
   */
  readonly cinder?: DatadogAgentV2Alpha1SpecOverrideVolumesCinder;

  /**
   * ConfigMap represents a configMap that should populate this volume
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap;

  /**
   * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#csi
   */
  readonly csi?: DatadogAgentV2Alpha1SpecOverrideVolumesCsi;

  /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#downwardAPI
   */
  readonly downwardApi?: DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApi;

  /**
   * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#emptyDir
   */
  readonly emptyDir?: DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDir;

  /**
   * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
   * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
   * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
   * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#ephemeral
   */
  readonly ephemeral?: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeral;

  /**
   * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#fc
   */
  readonly fc?: DatadogAgentV2Alpha1SpecOverrideVolumesFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#flexVolume
   */
  readonly flexVolume?: DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume;

  /**
   * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#flocker
   */
  readonly flocker?: DatadogAgentV2Alpha1SpecOverrideVolumesFlocker;

  /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#gcePersistentDisk
   */
  readonly gcePersistentDisk?: DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk;

  /**
   * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#gitRepo
   */
  readonly gitRepo?: DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo;

  /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#glusterfs
   */
  readonly glusterfs?: DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs;

  /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#hostPath
   */
  readonly hostPath?: DatadogAgentV2Alpha1SpecOverrideVolumesHostPath;

  /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#iscsi
   */
  readonly iscsi?: DatadogAgentV2Alpha1SpecOverrideVolumesIscsi;

  /**
   * Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#name
   */
  readonly name: string;

  /**
   * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#nfs
   */
  readonly nfs?: DatadogAgentV2Alpha1SpecOverrideVolumesNfs;

  /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: DatadogAgentV2Alpha1SpecOverrideVolumesPersistentVolumeClaim;

  /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#photonPersistentDisk
   */
  readonly photonPersistentDisk?: DatadogAgentV2Alpha1SpecOverrideVolumesPhotonPersistentDisk;

  /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#portworxVolume
   */
  readonly portworxVolume?: DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume;

  /**
   * Items for all in one resources secrets, configmaps, and downward API
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#projected
   */
  readonly projected?: DatadogAgentV2Alpha1SpecOverrideVolumesProjected;

  /**
   * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#quobyte
   */
  readonly quobyte?: DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte;

  /**
   * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#rbd
   */
  readonly rbd?: DatadogAgentV2Alpha1SpecOverrideVolumesRbd;

  /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#scaleIO
   */
  readonly scaleIo?: DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo;

  /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#secret
   */
  readonly secret?: DatadogAgentV2Alpha1SpecOverrideVolumesSecret;

  /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#storageos
   */
  readonly storageos?: DatadogAgentV2Alpha1SpecOverrideVolumesStorageos;

  /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumes#vsphereVolume
   */
  readonly vsphereVolume?: DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumes(obj: DatadogAgentV2Alpha1SpecOverrideVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsElasticBlockStore': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore(obj.awsElasticBlockStore),
    'azureDisk': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk(obj.azureDisk),
    'azureFile': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile(obj.azureFile),
    'cephfs': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCephfs(obj.cephfs),
    'cinder': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCinder(obj.cinder),
    'configMap': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap(obj.configMap),
    'csi': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCsi(obj.csi),
    'downwardAPI': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApi(obj.downwardApi),
    'emptyDir': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDir(obj.emptyDir),
    'ephemeral': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeral(obj.ephemeral),
    'fc': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesFc(obj.fc),
    'flexVolume': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume(obj.flexVolume),
    'flocker': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesFlocker(obj.flocker),
    'gcePersistentDisk': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk(obj.gcePersistentDisk),
    'gitRepo': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo(obj.gitRepo),
    'glusterfs': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs(obj.glusterfs),
    'hostPath': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesHostPath(obj.hostPath),
    'iscsi': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesIscsi(obj.iscsi),
    'name': obj.name,
    'nfs': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesNfs(obj.nfs),
    'persistentVolumeClaim': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesPersistentVolumeClaim(obj.persistentVolumeClaim),
    'photonPersistentDisk': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesPhotonPersistentDisk(obj.photonPersistentDisk),
    'portworxVolume': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume(obj.portworxVolume),
    'projected': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjected(obj.projected),
    'quobyte': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte(obj.quobyte),
    'rbd': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesRbd(obj.rbd),
    'scaleIO': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo(obj.scaleIo),
    'secret': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesSecret(obj.secret),
    'storageos': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesStorageos(obj.storageos),
    'vsphereVolume': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume(obj.vsphereVolume),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPortConfig contains host port configuration. Enabled Default: false Port Default: 8126
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesApmHostPortConfig
 */
export interface DatadogAgentV2Alpha1SpecFeaturesApmHostPortConfig {
  /**
   * Enabled enables host port configuration Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesApmHostPortConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * Port takes a port number (0 < x < 65536) to expose on the host. (Most containers do not need this.) If HostNetwork is enabled, this value must match the ContainerPort.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesApmHostPortConfig#hostPort
   */
  readonly hostPort?: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesApmHostPortConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesApmHostPortConfig(obj: DatadogAgentV2Alpha1SpecFeaturesApmHostPortConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'hostPort': obj.hostPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UnixDomainSocketConfig contains socket configuration. See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables Enabled Default: true Path Default: `/var/run/datadog/apm.socket`
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesApmUnixDomainSocketConfig
 */
export interface DatadogAgentV2Alpha1SpecFeaturesApmUnixDomainSocketConfig {
  /**
   * Enabled enables Unix Domain Socket. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesApmUnixDomainSocketConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * Path defines the socket path used when enabled.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesApmUnixDomainSocketConfig#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesApmUnixDomainSocketConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesApmUnixDomainSocketConfig(obj: DatadogAgentV2Alpha1SpecFeaturesApmUnixDomainSocketConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomBenchmarks contains CSPM benchmarks. The content of the ConfigMap will be merged with the benchmarks bundled with the agent. Any benchmarks with the same name as those existing in the agent will take precedence.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarks
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarks {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarks#configData
   */
  readonly configData?: string;

  /**
   * ConfigMap references an existing ConfigMap with the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarks#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarks(obj: DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostBenchmarks contains configuration for host benchmarks.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesCspmHostBenchmarks
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCspmHostBenchmarks {
  /**
   * Enabled enables host benchmarks. Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspmHostBenchmarks#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCspmHostBenchmarks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCspmHostBenchmarks(obj: DatadogAgentV2Alpha1SpecFeaturesCspmHostBenchmarks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomPolicies contains security policies. The content of the ConfigMap will be merged with the policies bundled with the agent. Any policies with the same name as those existing in the agent will take precedence.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPolicies
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCwsCustomPolicies {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPolicies#configData
   */
  readonly configData?: string;

  /**
   * ConfigMap references an existing ConfigMap with the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPolicies#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCwsCustomPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCwsCustomPolicies(obj: DatadogAgentV2Alpha1SpecFeaturesCwsCustomPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentV2Alpha1SpecFeaturesCwsNetwork
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCwsNetwork {
  /**
   * Enabled enables Cloud Workload Security Network detections. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsNetwork#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCwsNetwork' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCwsNetwork(obj: DatadogAgentV2Alpha1SpecFeaturesCwsNetwork | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentV2Alpha1SpecFeaturesCwsRemoteConfiguration
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCwsRemoteConfiguration {
  /**
   * Enabled enables Remote Configuration for Cloud Workload Security. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsRemoteConfiguration#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCwsRemoteConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCwsRemoteConfiguration(obj: DatadogAgentV2Alpha1SpecFeaturesCwsRemoteConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentV2Alpha1SpecFeaturesCwsSecurityProfiles
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCwsSecurityProfiles {
  /**
   * Enabled enables Security Profiles collection for Cloud Workload Security. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsSecurityProfiles#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCwsSecurityProfiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCwsSecurityProfiles(obj: DatadogAgentV2Alpha1SpecFeaturesCwsSecurityProfiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPortConfig contains host port configuration. Enabled Default: false Port Default: 8125
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdHostPortConfig
 */
export interface DatadogAgentV2Alpha1SpecFeaturesDogstatsdHostPortConfig {
  /**
   * Enabled enables host port configuration Default: false
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdHostPortConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * Port takes a port number (0 < x < 65536) to expose on the host. (Most containers do not need this.) If HostNetwork is enabled, this value must match the ContainerPort.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdHostPortConfig#hostPort
   */
  readonly hostPort?: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesDogstatsdHostPortConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdHostPortConfig(obj: DatadogAgentV2Alpha1SpecFeaturesDogstatsdHostPortConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'hostPort': obj.hostPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Dogstasd Mapper Profiles. Can be passed as raw data or via a json encoded string in a config map. See also: https://docs.datadoghq.com/developers/dogstatsd/dogstatsd_mapper/
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfiles
 */
export interface DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfiles {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfiles#configData
   */
  readonly configData?: string;

  /**
   * ConfigMap references an existing ConfigMap with the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfiles#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfiles' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfiles(obj: DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfiles | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UnixDomainSocketConfig contains socket configuration. See also: https://docs.datadoghq.com/agent/kubernetes/apm/?tab=helm#agent-environment-variables Enabled Default: true Path Default: `/var/run/datadog/dsd.socket`
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdUnixDomainSocketConfig
 */
export interface DatadogAgentV2Alpha1SpecFeaturesDogstatsdUnixDomainSocketConfig {
  /**
   * Enabled enables Unix Domain Socket. Default: true
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdUnixDomainSocketConfig#enabled
   */
  readonly enabled?: boolean;

  /**
   * Path defines the socket path used when enabled.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdUnixDomainSocketConfig#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesDogstatsdUnixDomainSocketConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdUnixDomainSocketConfig(obj: DatadogAgentV2Alpha1SpecFeaturesDogstatsdUnixDomainSocketConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Override the API endpoint for the External Metrics Server. URL Default: "https://app.datadoghq.com".
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpoint
 */
export interface DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpoint {
  /**
   * Credentials defines the Datadog credentials used to submit data to/query data from Datadog.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpoint#credentials
   */
  readonly credentials?: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials;

  /**
   * URL defines the endpoint URL.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpoint#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpoint(obj: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentials': toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials(obj.credentials),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Conf overrides the configuration for the default Kubernetes State Metrics Core check. This must point to a ConfigMap containing a valid cluster check configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConf
 */
export interface DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConf {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConf#configData
   */
  readonly configData?: string;

  /**
   * ConfigMap references an existing ConfigMap with the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConf#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConf' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConf(obj: DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConf | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Conf overrides the configuration for the default Orchestrator Explorer check. This must point to a ConfigMap containing a valid cluster check configuration.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConf
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConf {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConf#configData
   */
  readonly configData?: string;

  /**
   * ConfigMap references an existing ConfigMap with the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConf#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConf' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConf(obj: DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConf | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Receiver contains configuration for the OTLP ingest receiver.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiver
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOtlpReceiver {
  /**
   * Protocols contains configuration for the OTLP ingest receiver protocols.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiver#protocols
   */
  readonly protocols?: DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocols;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOtlpReceiver' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOtlpReceiver(obj: DatadogAgentV2Alpha1SpecFeaturesOtlpReceiver | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocols': toJson_DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocols(obj.protocols),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APISecret references an existing Secret which stores the API key instead of creating a new one. If set, this parameter takes precedence over "APIKey".
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalCredentialsApiSecret
 */
export interface DatadogAgentV2Alpha1SpecGlobalCredentialsApiSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalCredentialsApiSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalCredentialsApiSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalCredentialsApiSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalCredentialsApiSecret(obj: DatadogAgentV2Alpha1SpecGlobalCredentialsApiSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppSecret references an existing Secret which stores the application key instead of creating a new one. If set, this parameter takes precedence over "AppKey".
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalCredentialsAppSecret
 */
export interface DatadogAgentV2Alpha1SpecGlobalCredentialsAppSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalCredentialsAppSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalCredentialsAppSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalCredentialsAppSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalCredentialsAppSecret(obj: DatadogAgentV2Alpha1SpecGlobalCredentialsAppSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials defines the Datadog credentials used to submit data to/query data from Datadog.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentials
 */
export interface DatadogAgentV2Alpha1SpecGlobalEndpointCredentials {
  /**
   * APIKey configures your Datadog API key. See also: https://app.datadoghq.com/account/settings#agent/kubernetes
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentials#apiKey
   */
  readonly apiKey?: string;

  /**
   * APISecret references an existing Secret which stores the API key instead of creating a new one. If set, this parameter takes precedence over "APIKey".
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentials#apiSecret
   */
  readonly apiSecret?: DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsApiSecret;

  /**
   * AppKey configures your Datadog application key. If you are using features.externalMetricsServer.enabled = true, you must set a Datadog application key for read access to your metrics.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentials#appKey
   */
  readonly appKey?: string;

  /**
   * AppSecret references an existing Secret which stores the application key instead of creating a new one. If set, this parameter takes precedence over "AppKey".
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentials#appSecret
   */
  readonly appSecret?: DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsAppSecret;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalEndpointCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalEndpointCredentials(obj: DatadogAgentV2Alpha1SpecGlobalEndpointCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiSecret': toJson_DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsApiSecret(obj.apiSecret),
    'appKey': obj.appKey,
    'appSecret': toJson_DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsAppSecret(obj.appSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Host overrides the host used to contact kubelet API (default to status.hostIP).
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHost
 */
export interface DatadogAgentV2Alpha1SpecGlobalKubeletHost {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHost#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHost#fieldRef
   */
  readonly fieldRef?: DatadogAgentV2Alpha1SpecGlobalKubeletHostFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHost#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHost#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalKubeletHost' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHost(obj: DatadogAgentV2Alpha1SpecGlobalKubeletHost | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHostFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpoints
 */
export interface DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpoints {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpoints#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpoints#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpoints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpoints(obj: DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpoints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes node affinity scheduling rules for the pod.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinity
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinity(obj: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinity
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinity(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinity
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinity(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnv
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnv#value
   */
  readonly value?: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnv#valueFrom
   */
  readonly valueFrom?: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnv(obj: DatadogAgentV2Alpha1SpecOverrideContainersEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Liveness Probe of the container
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#exec
   */
  readonly exec?: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#grpc
   */
  readonly grpc?: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#httpGet
   */
  readonly httpGet?: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe(obj: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeGrpc(obj.grpc),
    'httpGet': toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configure the Readiness Probe of the container
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe {
  /**
   * Exec specifies the action to take.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#exec
   */
  readonly exec?: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#grpc
   */
  readonly grpc?: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeGrpc;

  /**
   * HTTPGet specifies the http request to perform.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#httpGet
   */
  readonly httpGet?: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness and startup. Minimum value is 1.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocket specifies an action involving a TCP port.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocket;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe(obj: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exec': toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeExec(obj.exec),
    'failureThreshold': obj.failureThreshold,
    'grpc': toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeGrpc(obj.grpc),
    'httpGet': toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet(obj.httpGet),
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'tcpSocket': toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocket(obj.tcpSocket),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specify the Request and Limits of the pods To get guaranteed QoS class, specify requests and limits equal. See also: http://kubernetes.io/docs/user-guide/compute-resources/
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersResources
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentV2Alpha1SpecOverrideContainersResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentV2Alpha1SpecOverrideContainersResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersResources(obj: DatadogAgentV2Alpha1SpecOverrideContainersResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Seccomp configurations to override Operator actions. For all other Seccomp Profile manipulation, use SecurityContext.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfig
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfig {
  /**
   * CustomProfile specifies a ConfigMap containing a custom Seccomp Profile. ConfigMap data must either have the key `system-probe-seccomp.json` or CustomProfile.Items must include a corev1.KeytoPath that maps the key to the path `system-probe-seccomp.json`.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfig#customProfile
   */
  readonly customProfile?: DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfile;

  /**
   * CustomRootPath specifies a custom Seccomp Profile root location.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfig#customRootPath
   */
  readonly customRootPath?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfig(obj: DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customProfile': toJson_DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfile(obj.customProfile),
    'customRootPath': obj.customRootPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Container-level SecurityContext.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#capabilities
   */
  readonly capabilities?: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default false. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions;

  /**
   * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#seccompProfile
   */
  readonly seccompProfile?: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeccompProfile;

  /**
   * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext#windowsOptions
   */
  readonly windowsOptions?: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext(obj: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts(obj: DatadogAgentV2Alpha1SpecOverrideContainersVolumeMounts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'mountPropagation': obj.mountPropagation,
    'name': obj.name,
    'readOnly': obj.readOnly,
    'subPath': obj.subPath,
    'subPathExpr': obj.subPathExpr,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap references an existing ConfigMap with the configuration file content.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMap
 */
export interface DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMap {
  /**
   * Items maps a ConfigMap data `key` to a file `path` mount.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems[];

  /**
   * Name is the name of the ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMap(obj: DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFrom
 */
export interface DatadogAgentV2Alpha1SpecOverrideEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentV2Alpha1SpecOverrideEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFrom(obj: DatadogAgentV2Alpha1SpecOverrideEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap references an existing ConfigMap with the content of the configuration files.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMap
 */
export interface DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMap {
  /**
   * Items maps a ConfigMap data `key` to a file `path` mount.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems[];

  /**
   * Name is the name of the ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMap(obj: DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap references an existing ConfigMap with the content of the configuration files.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMap
 */
export interface DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMap {
  /**
   * Items maps a ConfigMap data `key` to a file `path` mount.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems[];

  /**
   * Name is the name of the ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMap(obj: DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideImagePullSecrets
 */
export interface DatadogAgentV2Alpha1SpecOverrideImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideImagePullSecrets(obj: DatadogAgentV2Alpha1SpecOverrideImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSeccompProfile
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextSeccompProfile(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSysctls
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextSysctls(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomConfiguration defines a custom SCC configuration to use if Create is `true`.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration {
  /**
   * AllowHostDirVolumePlugin determines if the policy allow containers to use the HostDir volume plugin
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#allowHostDirVolumePlugin
   */
  readonly allowHostDirVolumePlugin: boolean;

  /**
   * AllowHostIPC determines if the policy allows host ipc in the containers.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#allowHostIPC
   */
  readonly allowHostIpc: boolean;

  /**
   * AllowHostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#allowHostNetwork
   */
  readonly allowHostNetwork: boolean;

  /**
   * AllowHostPID determines if the policy allows host pid in the containers.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#allowHostPID
   */
  readonly allowHostPid: boolean;

  /**
   * AllowHostPorts determines if the policy allows host ports in the containers.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#allowHostPorts
   */
  readonly allowHostPorts: boolean;

  /**
   * AllowPrivilegedContainer determines if a container can request to be run as privileged.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#allowPrivilegedContainer
   */
  readonly allowPrivilegedContainer: boolean;

  /**
   * AllowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field maybe added at the pod author's discretion. You must not list a capability in both AllowedCapabilities and RequiredDropCapabilities. To allow all capabilities you may use '*'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#allowedCapabilities
   */
  readonly allowedCapabilities: string[];

  /**
   * AllowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that all Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes is allowed in the "Volumes" field.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#allowedFlexVolumes
   */
  readonly allowedFlexVolumes: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationAllowedFlexVolumes[];

  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * DefaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec specifically drops the capability.  You may not list a capabiility in both DefaultAddCapabilities and RequiredDropCapabilities.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#defaultAddCapabilities
   */
  readonly defaultAddCapabilities: string[];

  /**
   * FSGroup is the strategy that will dictate what fs group is used by the SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#fsGroup
   */
  readonly fsGroup?: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroup;

  /**
   * The groups that have permission to use this security context constraints
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#groups
   */
  readonly groups?: string[];

  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#kind
   */
  readonly kind?: string;

  /**
   * Standard object's metadata. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#metadata
   */
  readonly metadata?: any;

  /**
   * Priority influences the sort order of SCCs when evaluating which SCCs to try first for a given pod request based on access in the Users and Groups fields.  The higher the int, the higher priority. An unset value is considered a 0 priority. If scores for multiple SCCs are equal they will be sorted from most restrictive to least restrictive. If both priorities and restrictions are equal the SCCs will be sorted by name.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#priority
   */
  readonly priority: number;

  /**
   * ReadOnlyRootFilesystem when set to true will force containers to run with a read only root file system.  If the container specifically requests to run with a non-read only root file system the SCC should deny the pod. If set to false the container may run with a read only root file system if it wishes but it will not be forced to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem: boolean;

  /**
   * RequiredDropCapabilities are the capabilities that will be dropped from the container.  These are required to be dropped and cannot be added.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#requiredDropCapabilities
   */
  readonly requiredDropCapabilities: string[];

  /**
   * RunAsUser is the strategy that will dictate what RunAsUser is used in the SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#runAsUser
   */
  readonly runAsUser?: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser;

  /**
   * SELinuxContext is the strategy that will dictate what labels will be set in the SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#seLinuxContext
   */
  readonly seLinuxContext?: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContext;

  /**
   * SeccompProfiles lists the allowed profiles that may be set for the pod or container's seccomp annotations.  An unset (nil) or empty value means that no profiles may be specifid by the pod or container.	The wildcard '*' may be used to allow all profiles.  When used to generate a value for a pod the first non-wildcard profile will be used as the default.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#seccompProfiles
   */
  readonly seccompProfiles?: string[];

  /**
   * SupplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#supplementalGroups
   */
  readonly supplementalGroups?: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroups;

  /**
   * The users who have permissions to use this security context constraints
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#users
   */
  readonly users?: string[];

  /**
   * Volumes is a white list of allowed volume plugins.  FSType corresponds directly with the field names of a VolumeSource (azureFile, configMap, emptyDir).  To allow all volumes you may use "*". To allow no volumes, set to ["none"].
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration#volumes
   */
  readonly volumes: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowHostDirVolumePlugin': obj.allowHostDirVolumePlugin,
    'allowHostIPC': obj.allowHostIpc,
    'allowHostNetwork': obj.allowHostNetwork,
    'allowHostPID': obj.allowHostPid,
    'allowHostPorts': obj.allowHostPorts,
    'allowPrivilegedContainer': obj.allowPrivilegedContainer,
    'allowedCapabilities': obj.allowedCapabilities?.map(y => y),
    'allowedFlexVolumes': obj.allowedFlexVolumes?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationAllowedFlexVolumes(y)),
    'apiVersion': obj.apiVersion,
    'defaultAddCapabilities': obj.defaultAddCapabilities?.map(y => y),
    'fsGroup': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroup(obj.fsGroup),
    'groups': obj.groups?.map(y => y),
    'kind': obj.kind,
    'metadata': obj.metadata,
    'priority': obj.priority,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'requiredDropCapabilities': obj.requiredDropCapabilities?.map(y => y),
    'runAsUser': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser(obj.runAsUser),
    'seLinuxContext': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContext(obj.seLinuxContext),
    'seccompProfiles': obj.seccompProfiles?.map(y => y),
    'supplementalGroups': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroups(obj.supplementalGroups),
    'users': obj.users?.map(y => y),
    'volumes': obj.volumes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore(obj: DatadogAgentV2Alpha1SpecOverrideVolumesAwsElasticBlockStore | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk#diskURI
   */
  readonly diskUri: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk(obj: DatadogAgentV2Alpha1SpecOverrideVolumesAzureDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingMode': obj.cachingMode,
    'diskName': obj.diskName,
    'diskURI': obj.diskUri,
    'fsType': obj.fsType,
    'kind': obj.kind,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile(obj: DatadogAgentV2Alpha1SpecOverrideVolumesAzureFile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'readOnly': obj.readOnly,
    'secretName': obj.secretName,
    'shareName': obj.shareName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCephfs
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCephfs#secretRef
   */
  readonly secretRef?: DatadogAgentV2Alpha1SpecOverrideVolumesCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCephfs#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesCephfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCephfs(obj: DatadogAgentV2Alpha1SpecOverrideVolumesCephfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'monitors': obj.monitors?.map(y => y),
    'path': obj.path,
    'readOnly': obj.readOnly,
    'secretFile': obj.secretFile,
    'secretRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCephfsSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCinder
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: points to a secret object containing parameters used to connect to OpenStack.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCinder#secretRef
   */
  readonly secretRef?: DatadogAgentV2Alpha1SpecOverrideVolumesCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCinder#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesCinder' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCinder(obj: DatadogAgentV2Alpha1SpecOverrideVolumesCinder | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCinderSecretRef(obj.secretRef),
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap represents a configMap that should populate this volume
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap(obj: DatadogAgentV2Alpha1SpecOverrideVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCsi
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCsi#fsType
   */
  readonly fsType?: string;

  /**
   * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: DatadogAgentV2Alpha1SpecOverrideVolumesCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCsi#volumeAttributes
   */
  readonly volumeAttributes?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesCsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCsi(obj: DatadogAgentV2Alpha1SpecOverrideVolumesCsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'nodePublishSecretRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCsiNodePublishSecretRef(obj.nodePublishSecretRef),
    'readOnly': obj.readOnly,
    'volumeAttributes': ((obj.volumeAttributes) === undefined) ? undefined : (Object.entries(obj.volumeAttributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPI represents downward API about the pod that should populate this volume
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApi
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApi#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApi(obj: DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDir
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDir#sizeLimit
   */
  readonly sizeLimit?: DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDirSizeLimit;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDir' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDir(obj: DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDir | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'medium': obj.medium,
    'sizeLimit': obj.sizeLimit?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
 * Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity    tracking are needed, c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through    a PersistentVolumeClaim (see EphemeralVolumeSource for more    information on the connection between this volume type    and PersistentVolumeClaim).
 * Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
 * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
 * A pod can use both types of ephemeral volumes and persistent volumes at the same time.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeral
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesEphemeral {
  /**
   * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
   * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
   * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
   * Required, must not be nil.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeral#volumeClaimTemplate
   */
  readonly volumeClaimTemplate?: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplate;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesEphemeral' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeral(obj: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeral | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'volumeClaimTemplate': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplate(obj.volumeClaimTemplate),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFc
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFc#targetWWNs
   */
  readonly targetWwNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesFc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesFc(obj: DatadogAgentV2Alpha1SpecOverrideVolumesFc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'lun': obj.lun,
    'readOnly': obj.readOnly,
    'targetWWNs': obj.targetWwNs?.map(y => y),
    'wwids': obj.wwids?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume#options
   */
  readonly options?: { [key: string]: string };

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume#secretRef
   */
  readonly secretRef?: DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolumeSecretRef;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume(obj: DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
    'fsType': obj.fsType,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolumeSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlocker
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlocker#datasetUUID
   */
  readonly datasetUuid?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesFlocker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesFlocker(obj: DatadogAgentV2Alpha1SpecOverrideVolumesFlocker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'datasetName': obj.datasetName,
    'datasetUUID': obj.datasetUuid,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk(obj: DatadogAgentV2Alpha1SpecOverrideVolumesGcePersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'partition': obj.partition,
    'pdName': obj.pdName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo(obj: DatadogAgentV2Alpha1SpecOverrideVolumesGitRepo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'directory': obj.directory,
    'repository': obj.repository,
    'revision': obj.revision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs(obj: DatadogAgentV2Alpha1SpecOverrideVolumesGlusterfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoints': obj.endpoints,
    'path': obj.path,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath --- TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not mount host directories as read/write.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesHostPath
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesHostPath#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesHostPath' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesHostPath(obj: DatadogAgentV2Alpha1SpecOverrideVolumesHostPath | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * CHAP Secret for iSCSI target and initiator authentication
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#secretRef
   */
  readonly secretRef?: DatadogAgentV2Alpha1SpecOverrideVolumesIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesIscsi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesIscsi(obj: DatadogAgentV2Alpha1SpecOverrideVolumesIscsi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chapAuthDiscovery': obj.chapAuthDiscovery,
    'chapAuthSession': obj.chapAuthSession,
    'fsType': obj.fsType,
    'initiatorName': obj.initiatorName,
    'iqn': obj.iqn,
    'iscsiInterface': obj.iscsiInterface,
    'lun': obj.lun,
    'portals': obj.portals?.map(y => y),
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesIscsiSecretRef(obj.secretRef),
    'targetPortal': obj.targetPortal,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesNfs
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesNfs#server
   */
  readonly server: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesNfs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesNfs(obj: DatadogAgentV2Alpha1SpecOverrideVolumesNfs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'readOnly': obj.readOnly,
    'server': obj.server,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPersistentVolumeClaim
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesPersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesPersistentVolumeClaim' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesPersistentVolumeClaim(obj: DatadogAgentV2Alpha1SpecOverrideVolumesPersistentVolumeClaim | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claimName': obj.claimName,
    'readOnly': obj.readOnly,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPhotonPersistentDisk
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesPhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPhotonPersistentDisk#pdID
   */
  readonly pdId: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesPhotonPersistentDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesPhotonPersistentDisk(obj: DatadogAgentV2Alpha1SpecOverrideVolumesPhotonPersistentDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'pdID': obj.pdId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume#volumeID
   */
  readonly volumeId: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume(obj: DatadogAgentV2Alpha1SpecOverrideVolumesPortworxVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'volumeID': obj.volumeId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Items for all in one resources secrets, configmaps, and downward API
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjected
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjected {
  /**
   * Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjected#sources
   */
  readonly sources?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjected' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjected(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjected | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'sources': obj.sources?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte(obj: DatadogAgentV2Alpha1SpecOverrideVolumesQuobyte | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'readOnly': obj.readOnly,
    'registry': obj.registry,
    'tenant': obj.tenant,
    'user': obj.user,
    'volume': obj.volume,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbd
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd TODO: how do we prevent errors in the filesystem from compromising the machine
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbd#secretRef
   */
  readonly secretRef?: DatadogAgentV2Alpha1SpecOverrideVolumesRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbd#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesRbd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesRbd(obj: DatadogAgentV2Alpha1SpecOverrideVolumesRbd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'image': obj.image,
    'keyring': obj.keyring,
    'monitors': obj.monitors?.map(y => y),
    'pool': obj.pool,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesRbdSecretRef(obj.secretRef),
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#secretRef
   */
  readonly secretRef: DatadogAgentV2Alpha1SpecOverrideVolumesScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo(obj: DatadogAgentV2Alpha1SpecOverrideVolumesScaleIo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'gateway': obj.gateway,
    'protectionDomain': obj.protectionDomain,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesScaleIoSecretRef(obj.secretRef),
    'sslEnabled': obj.sslEnabled,
    'storageMode': obj.storageMode,
    'storagePool': obj.storagePool,
    'system': obj.system,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesSecret
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesSecret {
  /**
   * Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesSecret#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems[];

  /**
   * Specify whether the Secret or its keys must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesSecret(obj: DatadogAgentV2Alpha1SpecOverrideVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesStorageos
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesStorageos#secretRef
   */
  readonly secretRef?: DatadogAgentV2Alpha1SpecOverrideVolumesStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesStorageos' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesStorageos(obj: DatadogAgentV2Alpha1SpecOverrideVolumesStorageos | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'readOnly': obj.readOnly,
    'secretRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesStorageosSecretRef(obj.secretRef),
    'volumeName': obj.volumeName,
    'volumeNamespace': obj.volumeNamespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume#storagePolicyID
   */
  readonly storagePolicyId?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume(obj: DatadogAgentV2Alpha1SpecOverrideVolumesVsphereVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsType': obj.fsType,
    'storagePolicyID': obj.storagePolicyId,
    'storagePolicyName': obj.storagePolicyName,
    'volumePath': obj.volumePath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap references an existing ConfigMap with the configuration file content.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMap
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMap {
  /**
   * Items maps a ConfigMap data `key` to a file `path` mount.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems[];

  /**
   * Name is the name of the ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMap(obj: DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap references an existing ConfigMap with the configuration file content.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMap
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMap {
  /**
   * Items maps a ConfigMap data `key` to a file `path` mount.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems[];

  /**
   * Name is the name of the ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMap(obj: DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap references an existing ConfigMap with the configuration file content.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMap
 */
export interface DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMap {
  /**
   * Items maps a ConfigMap data `key` to a file `path` mount.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems[];

  /**
   * Name is the name of the ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMap(obj: DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Credentials defines the Datadog credentials used to submit data to/query data from Datadog.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials
 */
export interface DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials {
  /**
   * APIKey configures your Datadog API key. See also: https://app.datadoghq.com/account/settings#agent/kubernetes
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials#apiKey
   */
  readonly apiKey?: string;

  /**
   * APISecret references an existing Secret which stores the API key instead of creating a new one. If set, this parameter takes precedence over "APIKey".
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials#apiSecret
   */
  readonly apiSecret?: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsApiSecret;

  /**
   * AppKey configures your Datadog application key. If you are using features.externalMetricsServer.enabled = true, you must set a Datadog application key for read access to your metrics.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials#appKey
   */
  readonly appKey?: string;

  /**
   * AppSecret references an existing Secret which stores the application key instead of creating a new one. If set, this parameter takes precedence over "AppKey".
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials#appSecret
   */
  readonly appSecret?: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsAppSecret;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials(obj: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentials | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKey': obj.apiKey,
    'apiSecret': toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsApiSecret(obj.apiSecret),
    'appKey': obj.appKey,
    'appSecret': toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsAppSecret(obj.appSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap references an existing ConfigMap with the configuration file content.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMap
 */
export interface DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMap {
  /**
   * Items maps a ConfigMap data `key` to a file `path` mount.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems[];

  /**
   * Name is the name of the ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMap(obj: DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap references an existing ConfigMap with the configuration file content.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMap
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMap {
  /**
   * Items maps a ConfigMap data `key` to a file `path` mount.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems[];

  /**
   * Name is the name of the ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMap(obj: DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Protocols contains configuration for the OTLP ingest receiver protocols.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocols
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocols {
  /**
   * GRPC contains configuration for the OTLP ingest OTLP/gRPC receiver.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocols#grpc
   */
  readonly grpc?: DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsGrpc;

  /**
   * HTTP contains configuration for the OTLP ingest OTLP/HTTP receiver.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocols#http
   */
  readonly http?: DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsHttp;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocols' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocols(obj: DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocols | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'grpc': toJson_DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsGrpc(obj.grpc),
    'http': toJson_DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsHttp(obj.http),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APISecret references an existing Secret which stores the API key instead of creating a new one. If set, this parameter takes precedence over "APIKey".
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsApiSecret
 */
export interface DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsApiSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsApiSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsApiSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsApiSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsApiSecret(obj: DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsApiSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppSecret references an existing Secret which stores the application key instead of creating a new one. If set, this parameter takes precedence over "AppKey".
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsAppSecret
 */
export interface DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsAppSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsAppSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsAppSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsAppSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsAppSecret(obj: DatadogAgentV2Alpha1SpecGlobalEndpointCredentialsAppSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef
 */
export interface DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef(obj: DatadogAgentV2Alpha1SpecGlobalKubeletHostConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostFieldRef
 */
export interface DatadogAgentV2Alpha1SpecGlobalKubeletHostFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalKubeletHostFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHostFieldRef(obj: DatadogAgentV2Alpha1SpecGlobalKubeletHostFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef
 */
export interface DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef(obj: DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef
 */
export interface DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef(obj: DatadogAgentV2Alpha1SpecGlobalKubeletHostSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions(obj: DatadogAgentV2Alpha1SpecGlobalNetworkPolicyDnsSelectorEndpointsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Source for the environment variable's value. Cannot be used if value is not empty.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom {
  /**
   * Selects a key of a ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef;

  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromFieldRef;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef;

  /**
   * Selects a key of a secret in the pod's namespace
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom(obj: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'fieldRef': toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromFieldRef(obj.fieldRef),
    'resourceFieldRef': toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef(obj.resourceFieldRef),
    'secretKeyRef': toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeExec
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeExec(obj: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeGrpc
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeGrpc(obj: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet#port
   */
  readonly port: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet(obj: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocket
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocket#port
   */
  readonly port: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocket(obj: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Exec specifies the action to take.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeExec
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeExec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeExec(obj: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeExec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'command': obj.command?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeGrpc
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeGrpc {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeGrpc#port
   */
  readonly port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   * If this is not specified, the default behavior is defined by gRPC.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeGrpc#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeGrpc(obj: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPGet specifies the http request to perform.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet#port
   */
  readonly port: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet(obj: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'httpHeaders': obj.httpHeaders?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetHttpHeaders(y)),
    'path': obj.path,
    'port': obj.port?.value,
    'scheme': obj.scheme,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TCPSocket specifies an action involving a TCP port.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocket
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocket#port
   */
  readonly port: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocketPort;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocket' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocket(obj: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'port': obj.port?.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersResourcesLimits
 */
export class DatadogAgentV2Alpha1SpecOverrideContainersResourcesLimits {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideContainersResourcesLimits {
    return new DatadogAgentV2Alpha1SpecOverrideContainersResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideContainersResourcesLimits {
    return new DatadogAgentV2Alpha1SpecOverrideContainersResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersResourcesRequests
 */
export class DatadogAgentV2Alpha1SpecOverrideContainersResourcesRequests {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideContainersResourcesRequests {
    return new DatadogAgentV2Alpha1SpecOverrideContainersResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideContainersResourcesRequests {
    return new DatadogAgentV2Alpha1SpecOverrideContainersResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * CustomProfile specifies a ConfigMap containing a custom Seccomp Profile. ConfigMap data must either have the key `system-probe-seccomp.json` or CustomProfile.Items must include a corev1.KeytoPath that maps the key to the path `system-probe-seccomp.json`.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfile
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfile {
  /**
   * ConfigData corresponds to the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfile#configData
   */
  readonly configData?: string;

  /**
   * ConfigMap references an existing ConfigMap with the configuration file content.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfile#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMap;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfile(obj: DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configData': obj.configData,
    'configMap': toJson_DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMap(obj.configMap),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 *
 * @default the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextCapabilities
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextCapabilities(obj: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions(obj: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The seccomp options to use by this container. If seccomp options are provided at both the pod & container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeccompProfile
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeccompProfile {
  /**
   * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * type indicates which kind of seccomp profile will be applied. Valid options are:
   * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeccompProfile#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeccompProfile(obj: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions {
  /**
   * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions(obj: DatadogAgentV2Alpha1SpecOverrideContainersSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems(obj: DatadogAgentV2Alpha1SpecOverrideCustomConfigurationsConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef(obj: DatadogAgentV2Alpha1SpecOverrideEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromFieldRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFromFieldRef(obj: DatadogAgentV2Alpha1SpecOverrideEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef(obj: DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef(obj: DatadogAgentV2Alpha1SpecOverrideEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems(obj: DatadogAgentV2Alpha1SpecOverrideExtraChecksdConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems(obj: DatadogAgentV2Alpha1SpecOverrideExtraConfdConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AllowedFlexVolume represents a single Flexvolume that is allowed to be used.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationAllowedFlexVolumes
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationAllowedFlexVolumes {
  /**
   * Driver is the name of the Flexvolume driver.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationAllowedFlexVolumes#driver
   */
  readonly driver?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationAllowedFlexVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationAllowedFlexVolumes(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationAllowedFlexVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'driver': obj.driver,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FSGroup is the strategy that will dictate what fs group is used by the SecurityContext.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroup
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroup {
  /**
   * Ranges are the allowed ranges of fs groups.  If you would like to force a single fs group then supply a single range with the same start and end.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroup#ranges
   */
  readonly ranges?: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroupRanges[];

  /**
   * Type is the strategy that will dictate what FSGroup is used in the SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroup#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroup(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ranges': obj.ranges?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroupRanges(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RunAsUser is the strategy that will dictate what RunAsUser is used in the SecurityContext.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser {
  /**
   * Type is the strategy that will dictate what RunAsUser is used in the SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser#type
   */
  readonly type?: string;

  /**
   * UID is the user id that containers must run as.  Required for the MustRunAs strategy if not using namespace/service account allocated uids.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser#uid
   */
  readonly uid?: number;

  /**
   * UIDRangeMax defines the max value for a strategy that allocates by range.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser#uidRangeMax
   */
  readonly uidRangeMax?: number;

  /**
   * UIDRangeMin defines the min value for a strategy that allocates by range.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser#uidRangeMin
   */
  readonly uidRangeMin?: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationRunAsUser | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'uid': obj.uid,
    'uidRangeMax': obj.uidRangeMax,
    'uidRangeMin': obj.uidRangeMin,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SELinuxContext is the strategy that will dictate what labels will be set in the SecurityContext.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContext
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContext {
  /**
   * seLinuxOptions required to run as; required for MustRunAs
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContext#seLinuxOptions
   */
  readonly seLinuxOptions?: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions;

  /**
   * Type is the strategy that will dictate what SELinux context is used in the SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContext#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContext(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'seLinuxOptions': toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions(obj.seLinuxOptions),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SupplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroups
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroups {
  /**
   * Ranges are the allowed ranges of supplemental groups.  If you would like to force a single supplemental group then supply a single range with the same start and end.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroups#ranges
   */
  readonly ranges?: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroupsRanges[];

  /**
   * Type is the strategy that will dictate what supplemental groups is used in the SecurityContext.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroups#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroups' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroups(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroups | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ranges': obj.ranges?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroupsRanges(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCephfsSecretRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesCephfsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCephfsSecretRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesCephfsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: points to a secret object containing parameters used to connect to OpenStack.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCinderSecretRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesCinderSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCinderSecretRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesCinderSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems(obj: DatadogAgentV2Alpha1SpecOverrideVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCsiNodePublishSecretRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesCsiNodePublishSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesCsiNodePublishSecretRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesCsiNodePublishSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems(obj: DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDirSizeLimit
 */
export class DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDirSizeLimit {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDirSizeLimit {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDirSizeLimit(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDirSizeLimit {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesEmptyDirSizeLimit(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `<pod name>-<volume name>` where `<volume name>` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
 * An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
 * This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
 * Required, must not be nil.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplate
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplate {
  /**
   * May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplate#metadata
   */
  readonly metadata?: any;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplate#spec
   */
  readonly spec: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplate(obj: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolumeSecretRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolumeSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolumeSecretRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesFlexVolumeSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CHAP Secret for iSCSI target and initiator authentication
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsiSecretRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesIscsiSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesIscsiSecretRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesIscsiSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources {
  /**
   * information about the configMap data to project
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources#configMap
   */
  readonly configMap?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap;

  /**
   * information about the downwardAPI data to project
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources#downwardAPI
   */
  readonly downwardApi?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApi;

  /**
   * information about the secret data to project
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources#secret
   */
  readonly secret?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret;

  /**
   * information about the serviceAccountToken data to project
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap(obj.configMap),
    'downwardAPI': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApi(obj.downwardApi),
    'secret': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret(obj.secret),
    'serviceAccountToken': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken(obj.serviceAccountToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 *
 * @default nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbdSecretRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesRbdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesRbdSecretRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesRbdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIoSecretRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesScaleIoSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesScaleIoSecretRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesScaleIoSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems(obj: DatadogAgentV2Alpha1SpecOverrideVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesStorageosSecretRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesStorageosSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesStorageosSecretRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesStorageosSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems(obj: DatadogAgentV2Alpha1SpecFeaturesCspmCustomBenchmarksConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems(obj: DatadogAgentV2Alpha1SpecFeaturesCwsCustomPoliciesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems(obj: DatadogAgentV2Alpha1SpecFeaturesDogstatsdMapperProfilesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APISecret references an existing Secret which stores the API key instead of creating a new one. If set, this parameter takes precedence over "APIKey".
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsApiSecret
 */
export interface DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsApiSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsApiSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsApiSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsApiSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsApiSecret(obj: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsApiSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppSecret references an existing Secret which stores the application key instead of creating a new one. If set, this parameter takes precedence over "AppKey".
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsAppSecret
 */
export interface DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsAppSecret {
  /**
   * KeyName is the key of the secret to use.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsAppSecret#keyName
   */
  readonly keyName?: string;

  /**
   * SecretName is the name of the secret.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsAppSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsAppSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsAppSecret(obj: DatadogAgentV2Alpha1SpecFeaturesExternalMetricsServerEndpointCredentialsAppSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyName': obj.keyName,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems(obj: DatadogAgentV2Alpha1SpecFeaturesKubeStateMetricsCoreConfConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems(obj: DatadogAgentV2Alpha1SpecFeaturesOrchestratorExplorerConfConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GRPC contains configuration for the OTLP ingest OTLP/gRPC receiver.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsGrpc
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsGrpc {
  /**
   * Enable the OTLP/gRPC endpoint.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsGrpc#enabled
   */
  readonly enabled?: boolean;

  /**
   * Endpoint for OTLP/gRPC. gRPC supports several naming schemes: https://github.com/grpc/grpc/blob/master/doc/naming.md The Datadog Operator supports only 'host:port' (usually `0.0.0.0:port`). Default: `0.0.0.0:4317`.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsGrpc#endpoint
   */
  readonly endpoint?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsGrpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsGrpc(obj: DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsGrpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTP contains configuration for the OTLP ingest OTLP/HTTP receiver.
 *
 * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsHttp
 */
export interface DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsHttp {
  /**
   * Enable the OTLP/HTTP endpoint.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsHttp#enabled
   */
  readonly enabled?: boolean;

  /**
   * Endpoint for OTLP/HTTP. Default: '0.0.0.0:4318'.
   *
   * @schema DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsHttp#endpoint
   */
  readonly endpoint?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsHttp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsHttp(obj: DatadogAgentV2Alpha1SpecFeaturesOtlpReceiverProtocolsHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRefDivisor
 */
export class DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecGlobalKubeletHostResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A node selector term, associated with the corresponding weight.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required. A pod affinity term, associated with the corresponding weight.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label query over a set of resources, in this case pods.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a ConfigMap.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef(obj: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromFieldRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromFieldRef(obj: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef(obj: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a key of a secret in the pod's namespace
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef(obj: DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetHttpHeaders
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetHttpHeaders(obj: DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetPort
 */
export class DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetPort {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetPort {
    return new DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetPort(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetPort {
    return new DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocketPort
 */
export class DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocketPort {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocketPort {
    return new DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocketPort {
    return new DatadogAgentV2Alpha1SpecOverrideContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetHttpHeaders
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetHttpHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetHttpHeaders(obj: DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetHttpHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetPort
 */
export class DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetPort {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetPort {
    return new DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetPort(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetPort {
    return new DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocketPort
 */
export class DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocketPort {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocketPort {
    return new DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocketPort {
    return new DatadogAgentV2Alpha1SpecOverrideContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ConfigMap references an existing ConfigMap with the configuration file content.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMap
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMap {
  /**
   * Items maps a ConfigMap data `key` to a file `path` mount.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems[];

  /**
   * Name is the name of the ConfigMap.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMap#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMap(obj: DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecOverrideEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * IDRange provides a min/max of an allowed range of IDs. TODO: this could be reused for UIDs.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroupRanges
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroupRanges {
  /**
   * Max is the end of the range, inclusive.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroupRanges#max
   */
  readonly max?: number;

  /**
   * Min is the start of the range, inclusive.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroupRanges#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroupRanges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroupRanges(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationFsGroupRanges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * seLinuxOptions required to run as; required for MustRunAs
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSeLinuxContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IDRange provides a min/max of an allowed range of IDs. TODO: this could be reused for UIDs.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroupsRanges
 */
export interface DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroupsRanges {
  /**
   * Max is the end of the range, inclusive.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroupsRanges#max
   */
  readonly max?: number;

  /**
   * Min is the start of the range, inclusive.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroupsRanges#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroupsRanges' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroupsRanges(obj: DatadogAgentV2Alpha1SpecOverrideSecurityContextConstraintsCustomConfigurationSupplementalGroupsRanges | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsFieldRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsFieldRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec#dataSource
   */
  readonly dataSource?: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource;

  /**
   * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec#dataSourceRef
   */
  readonly dataSourceRef?: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef;

  /**
   * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec#resources
   */
  readonly resources?: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResources;

  /**
   * A label query over volumes to consider for binding.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec#selector
   */
  readonly selector?: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec(obj: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessModes': obj.accessModes?.map(y => y),
    'dataSource': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj.dataSource),
    'dataSourceRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj.dataSourceRef),
    'resources': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResources(obj.resources),
    'selector': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelector(obj.selector),
    'storageClassName': obj.storageClassName,
    'volumeMode': obj.volumeMode,
    'volumeName': obj.volumeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the configMap data to project
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or its keys must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the downwardAPI data to project
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApi
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApi#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApi' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApi(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the secret data to project
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret#items
   */
  readonly items?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * information about the serviceAccountToken data to project
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audience': obj.audience,
    'expirationSeconds': obj.expirationSeconds,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: DatadogAgentV2Alpha1SpecOverrideAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over a set of resources, in this case pods.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRefDivisor
 */
export class DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecOverrideContainersEnvValueFromResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems(obj: DatadogAgentV2Alpha1SpecOverrideContainersSeccompConfigCustomProfileConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRefDivisor
 */
export class DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource(obj: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef   allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef   preserves all values, and generates an error if a disallowed value is   specified. (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResources
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResources#limits
   */
  readonly limits?: { [key: string]: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits };

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResources#requests
   */
  readonly requests?: { [key: string]: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResources(obj: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'limits': ((obj.limits) === undefined) ? undefined : (Object.entries(obj.limits).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
    'requests': ((obj.requests) === undefined) ? undefined : (Object.entries(obj.requests).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.value }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label query over volumes to consider for binding.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelector
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelector#matchExpressions
   */
  readonly matchExpressions?: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelector(obj: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems {
  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsFieldRef(obj.fieldRef),
    'mode': obj.mode,
    'path': obj.path,
    'resourceFieldRef': toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj.resourceFieldRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Maps a string key to a path within a volume.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits
 */
export class DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesLimits(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests
 */
export class DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecResourcesRequests(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions(obj: DatadogAgentV2Alpha1SpecOverrideVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsFieldRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsFieldRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'fieldPath': obj.fieldPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor;

  /**
   * Required: resource to select
   *
   * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Converts an object of type 'DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef(obj: DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'divisor': obj.divisor?.value,
    'resource': obj.resource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the output format of the exposed resources, defaults to "1"
 *
 * @schema DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor
 */
export class DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
  public static fromNumber(value: number): DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  public static fromString(value: string): DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor {
    return new DatadogAgentV2Alpha1SpecOverrideVolumesProjectedSourcesDownwardApiItemsResourceFieldRefDivisor(value);
  }
  private constructor(public readonly value: number | string) {
  }
}


/**
 * DatadogMetric allows autoscaling on arbitrary Datadog query
 *
 * @schema DatadogMetric
 */
export class DatadogMetric extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatadogMetric"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datadoghq.com/v1alpha1',
    kind: 'DatadogMetric',
  }

  /**
   * Renders a Kubernetes manifest for "DatadogMetric".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatadogMetricProps = {}): any {
    return {
      ...DatadogMetric.GVK,
      ...toJson_DatadogMetricProps(props),
    };
  }

  /**
   * Defines a "DatadogMetric" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatadogMetricProps = {}) {
    super(scope, id, {
      ...DatadogMetric.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatadogMetric.GVK,
      ...toJson_DatadogMetricProps(resolved),
    };
  }
}

/**
 * DatadogMetric allows autoscaling on arbitrary Datadog query
 *
 * @schema DatadogMetric
 */
export interface DatadogMetricProps {
  /**
   * @schema DatadogMetric#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatadogMetricSpec defines the desired state of DatadogMetric
   *
   * @schema DatadogMetric#spec
   */
  readonly spec?: DatadogMetricSpec;

}

/**
 * Converts an object of type 'DatadogMetricProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogMetricProps(obj: DatadogMetricProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatadogMetricSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatadogMetricSpec defines the desired state of DatadogMetric
 *
 * @schema DatadogMetricSpec
 */
export interface DatadogMetricSpec {
  /**
   * ExternalMetricName is reserved for internal use
   *
   * @schema DatadogMetricSpec#externalMetricName
   */
  readonly externalMetricName?: string;

  /**
   * MaxAge provides the max age for the metric query (overrides the default setting `external_metrics_provider.max_age`)
   *
   * @schema DatadogMetricSpec#maxAge
   */
  readonly maxAge?: string;

  /**
   * Query is the raw datadog query
   *
   * @schema DatadogMetricSpec#query
   */
  readonly query?: string;

  /**
   * TimeWindow provides the time window for the metric query, defaults to MaxAge.
   *
   * @schema DatadogMetricSpec#timeWindow
   */
  readonly timeWindow?: string;

}

/**
 * Converts an object of type 'DatadogMetricSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogMetricSpec(obj: DatadogMetricSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalMetricName': obj.externalMetricName,
    'maxAge': obj.maxAge,
    'query': obj.query,
    'timeWindow': obj.timeWindow,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * DatadogMonitor allows to define and manage Monitors from your Kubernetes Cluster
 *
 * @schema DatadogMonitor
 */
export class DatadogMonitor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatadogMonitor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datadoghq.com/v1alpha1',
    kind: 'DatadogMonitor',
  }

  /**
   * Renders a Kubernetes manifest for "DatadogMonitor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatadogMonitorProps = {}): any {
    return {
      ...DatadogMonitor.GVK,
      ...toJson_DatadogMonitorProps(props),
    };
  }

  /**
   * Defines a "DatadogMonitor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatadogMonitorProps = {}) {
    super(scope, id, {
      ...DatadogMonitor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatadogMonitor.GVK,
      ...toJson_DatadogMonitorProps(resolved),
    };
  }
}

/**
 * DatadogMonitor allows to define and manage Monitors from your Kubernetes Cluster
 *
 * @schema DatadogMonitor
 */
export interface DatadogMonitorProps {
  /**
   * @schema DatadogMonitor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatadogMonitorSpec defines the desired state of DatadogMonitor
   *
   * @schema DatadogMonitor#spec
   */
  readonly spec?: DatadogMonitorSpec;

}

/**
 * Converts an object of type 'DatadogMonitorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogMonitorProps(obj: DatadogMonitorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatadogMonitorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatadogMonitorSpec defines the desired state of DatadogMonitor
 *
 * @schema DatadogMonitorSpec
 */
export interface DatadogMonitorSpec {
  /**
   * ControllerOptions are the optional parameters in the DatadogMonitor controller
   *
   * @schema DatadogMonitorSpec#controllerOptions
   */
  readonly controllerOptions?: DatadogMonitorSpecControllerOptions;

  /**
   * Message is a message to include with notifications for this monitor
   *
   * @schema DatadogMonitorSpec#message
   */
  readonly message?: string;

  /**
   * Name is the monitor name
   *
   * @schema DatadogMonitorSpec#name
   */
  readonly name?: string;

  /**
   * Options are the optional parameters associated with your monitor
   *
   * @schema DatadogMonitorSpec#options
   */
  readonly options?: DatadogMonitorSpecOptions;

  /**
   * Priority is an integer from 1 (high) to 5 (low) indicating alert severity
   *
   * @schema DatadogMonitorSpec#priority
   */
  readonly priority?: number;

  /**
   * Query is the Datadog monitor query
   *
   * @schema DatadogMonitorSpec#query
   */
  readonly query?: string;

  /**
   * RestrictedRoles is a list of unique role identifiers to define which roles are allowed to edit the monitor. `restricted_roles` is the successor of `locked`. For more information about `locked` and `restricted_roles`, see the [monitor options docs](https://docs.datadoghq.com/monitors/guide/monitor_api_options/#permissions-options).
   *
   * @schema DatadogMonitorSpec#restrictedRoles
   */
  readonly restrictedRoles?: string[];

  /**
   * Tags is the monitor tags associated with your monitor
   *
   * @schema DatadogMonitorSpec#tags
   */
  readonly tags?: string[];

  /**
   * Type is the monitor type
   *
   * @schema DatadogMonitorSpec#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatadogMonitorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogMonitorSpec(obj: DatadogMonitorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controllerOptions': toJson_DatadogMonitorSpecControllerOptions(obj.controllerOptions),
    'message': obj.message,
    'name': obj.name,
    'options': toJson_DatadogMonitorSpecOptions(obj.options),
    'priority': obj.priority,
    'query': obj.query,
    'restrictedRoles': obj.restrictedRoles?.map(y => y),
    'tags': obj.tags?.map(y => y),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ControllerOptions are the optional parameters in the DatadogMonitor controller
 *
 * @schema DatadogMonitorSpecControllerOptions
 */
export interface DatadogMonitorSpecControllerOptions {
  /**
   * DisableRequiredTags disables the automatic addition of required tags to monitors.
   *
   * @schema DatadogMonitorSpecControllerOptions#disableRequiredTags
   */
  readonly disableRequiredTags?: boolean;

}

/**
 * Converts an object of type 'DatadogMonitorSpecControllerOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogMonitorSpecControllerOptions(obj: DatadogMonitorSpecControllerOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'disableRequiredTags': obj.disableRequiredTags,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Options are the optional parameters associated with your monitor
 *
 * @schema DatadogMonitorSpecOptions
 */
export interface DatadogMonitorSpecOptions {
  /**
   * A Boolean indicating whether to send a log sample when the log monitor triggers.
   *
   * @schema DatadogMonitorSpecOptions#enableLogsSample
   */
  readonly enableLogsSample?: boolean;

  /**
   * A message to include with a re-notification.
   *
   * @schema DatadogMonitorSpecOptions#escalationMessage
   */
  readonly escalationMessage?: string;

  /**
   * Time (in seconds) to delay evaluation, as a non-negative integer. For example, if the value is set to 300 (5min), the timeframe is set to last_5m and the time is 7:00, the monitor evaluates data from 6:50 to 6:55. This is useful for AWS CloudWatch and other backfilled metrics to ensure the monitor always has data during evaluation.
   *
   * @schema DatadogMonitorSpecOptions#evaluationDelay
   */
  readonly evaluationDelay?: number;

  /**
   * A Boolean indicating whether notifications from this monitor automatically inserts its triggering tags into the title.
   *
   * @schema DatadogMonitorSpecOptions#includeTags
   */
  readonly includeTags?: boolean;

  /**
   * Whether or not the monitor is locked (only editable by creator and admins).
   *
   * @schema DatadogMonitorSpecOptions#locked
   */
  readonly locked?: boolean;

  /**
   * Time (in seconds) to allow a host to boot and applications to fully start before starting the evaluation of monitor results. Should be a non negative integer.
   *
   * @schema DatadogMonitorSpecOptions#newGroupDelay
   */
  readonly newGroupDelay?: number;

  /**
   * The number of minutes before a monitor notifies after data stops reporting. Datadog recommends at least 2x the monitor timeframe for metric alerts or 2 minutes for service checks. If omitted, 2x the evaluation timeframe is used for metric alerts, and 24 hours is used for service checks.
   *
   * @schema DatadogMonitorSpecOptions#noDataTimeframe
   */
  readonly noDataTimeframe?: number;

  /**
   * A Boolean indicating whether tagged users are notified on changes to this monitor.
   *
   * @schema DatadogMonitorSpecOptions#notifyAudit
   */
  readonly notifyAudit?: boolean;

  /**
   * A Boolean indicating whether this monitor notifies when data stops reporting.
   *
   * @schema DatadogMonitorSpecOptions#notifyNoData
   */
  readonly notifyNoData?: boolean;

  /**
   * The number of minutes after the last notification before a monitor re-notifies on the current status. It only re-notifies if its not resolved.
   *
   * @schema DatadogMonitorSpecOptions#renotifyInterval
   */
  readonly renotifyInterval?: number;

  /**
   * A Boolean indicating whether this monitor needs a full window of data before its evaluated. We highly recommend you set this to false for sparse metrics, otherwise some evaluations are skipped. Default is false.
   *
   * @default false.
   * @schema DatadogMonitorSpecOptions#requireFullWindow
   */
  readonly requireFullWindow?: boolean;

  /**
   * A struct of the alerting time window options.
   *
   * @schema DatadogMonitorSpecOptions#thresholdWindows
   */
  readonly thresholdWindows?: DatadogMonitorSpecOptionsThresholdWindows;

  /**
   * A struct of the different monitor threshold values.
   *
   * @schema DatadogMonitorSpecOptions#thresholds
   */
  readonly thresholds?: DatadogMonitorSpecOptionsThresholds;

  /**
   * The number of hours of the monitor not reporting data before it automatically resolves from a triggered state.
   *
   * @schema DatadogMonitorSpecOptions#timeoutH
   */
  readonly timeoutH?: number;

}

/**
 * Converts an object of type 'DatadogMonitorSpecOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogMonitorSpecOptions(obj: DatadogMonitorSpecOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableLogsSample': obj.enableLogsSample,
    'escalationMessage': obj.escalationMessage,
    'evaluationDelay': obj.evaluationDelay,
    'includeTags': obj.includeTags,
    'locked': obj.locked,
    'newGroupDelay': obj.newGroupDelay,
    'noDataTimeframe': obj.noDataTimeframe,
    'notifyAudit': obj.notifyAudit,
    'notifyNoData': obj.notifyNoData,
    'renotifyInterval': obj.renotifyInterval,
    'requireFullWindow': obj.requireFullWindow,
    'thresholdWindows': toJson_DatadogMonitorSpecOptionsThresholdWindows(obj.thresholdWindows),
    'thresholds': toJson_DatadogMonitorSpecOptionsThresholds(obj.thresholds),
    'timeoutH': obj.timeoutH,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A struct of the alerting time window options.
 *
 * @schema DatadogMonitorSpecOptionsThresholdWindows
 */
export interface DatadogMonitorSpecOptionsThresholdWindows {
  /**
   * Describes how long an anomalous metric must be normal before the alert recovers.
   *
   * @schema DatadogMonitorSpecOptionsThresholdWindows#recoveryWindow
   */
  readonly recoveryWindow?: string;

  /**
   * Describes how long a metric must be anomalous before an alert triggers.
   *
   * @schema DatadogMonitorSpecOptionsThresholdWindows#triggerWindow
   */
  readonly triggerWindow?: string;

}

/**
 * Converts an object of type 'DatadogMonitorSpecOptionsThresholdWindows' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogMonitorSpecOptionsThresholdWindows(obj: DatadogMonitorSpecOptionsThresholdWindows | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recoveryWindow': obj.recoveryWindow,
    'triggerWindow': obj.triggerWindow,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A struct of the different monitor threshold values.
 *
 * @schema DatadogMonitorSpecOptionsThresholds
 */
export interface DatadogMonitorSpecOptionsThresholds {
  /**
   * The monitor CRITICAL threshold.
   *
   * @schema DatadogMonitorSpecOptionsThresholds#critical
   */
  readonly critical?: string;

  /**
   * The monitor CRITICAL recovery threshold.
   *
   * @schema DatadogMonitorSpecOptionsThresholds#criticalRecovery
   */
  readonly criticalRecovery?: string;

  /**
   * The monitor OK threshold.
   *
   * @schema DatadogMonitorSpecOptionsThresholds#ok
   */
  readonly ok?: string;

  /**
   * The monitor UNKNOWN threshold.
   *
   * @schema DatadogMonitorSpecOptionsThresholds#unknown
   */
  readonly unknown?: string;

  /**
   * The monitor WARNING threshold.
   *
   * @schema DatadogMonitorSpecOptionsThresholds#warning
   */
  readonly warning?: string;

  /**
   * The monitor WARNING recovery threshold.
   *
   * @schema DatadogMonitorSpecOptionsThresholds#warningRecovery
   */
  readonly warningRecovery?: string;

}

/**
 * Converts an object of type 'DatadogMonitorSpecOptionsThresholds' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatadogMonitorSpecOptionsThresholds(obj: DatadogMonitorSpecOptionsThresholds | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'criticalRecovery': obj.criticalRecovery,
    'ok': obj.ok,
    'unknown': obj.unknown,
    'warning': obj.warning,
    'warningRecovery': obj.warningRecovery,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

